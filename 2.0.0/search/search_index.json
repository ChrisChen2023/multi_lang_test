{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to NebulaGraph 2.0.0 Documentation","text":"<p>Note</p> <p>This manual is revised on 2023-11-8, with GitHub commit 96accae.</p> <p>NebulaGraph is a distributed, scalable, and lightning-fast graph database. It is the optimal solution in the world capable of hosting graphs with dozens of billions of vertices (nodes) and trillions of edges (relationships) with millisecond latency.</p>"},{"location":"#getting_started","title":"Getting started","text":"<ul> <li>Quick start</li> <li>Preparations before deployment</li> <li>nGQL cheatsheet</li> <li>FAQ</li> <li>Ecosystem Tools</li> </ul>"},{"location":"#release_notes","title":"Release notes","text":"<ul> <li>NebulaGraph Community Edition 2.0.0</li> <li>NebulaGraph Dashboard Community</li> <li>NebulaGraph Studio</li> </ul>"},{"location":"#other_sources","title":"Other Sources","text":"<ul> <li>To cite NebulaGraph</li> <li>Forum</li> <li>NebulaGraph Homepage</li> <li>Blogs</li> <li>Videos</li> <li>Chinese Docs</li> </ul>"},{"location":"#symbols_used_in_this_manual","title":"Symbols used in this manual","text":"<p>Note</p> <p>Additional information or operation-related notes.</p> <p>Caution</p> <p>Cautions that need strict observation. If not, systematic breakdown, data loss, and security issues may happen.</p> <p>Danger</p> <p>Operations that may cause danger. If not observed, systematic breakdown, data loss, and security issues will happen.</p> <p>Performance</p> <p>Operations that merit attention as for performance enhancement.</p> <p>Faq</p> <p>Frequently asked questions.</p> <p>Compatibility</p> <p>The compatibility notes between nGQL and openCypher, or between the current version of nGQL and its prior ones. </p> <p>Enterpriseonly</p> <p>Differences between the NebulaGraph Community and Enterprise editions.</p>"},{"location":"#modify_errors","title":"Modify errors","text":"<p>This NebulaGraph manual is written in the Markdown language. Users can click the pencil sign on the upper right side of each document title and modify errors.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/","title":"What is NebulaGraph","text":"<p>NebulaGraph is an open-source, distributed, easily scalable, and native graph database. It is capable of hosting graphs with hundreds of billions of vertices and trillions of edges, and serving queries with millisecond-latency. </p> <p></p>"},{"location":"1.introduction/1.what-is-nebula-graph/#what_is_a_graph_database","title":"What is a graph database","text":"<p>A graph database, such as NebulaGraph, is a database that specializes in storing vast graph networks and retrieving information from them. It efficiently stores data as vertices (nodes) and edges (relationships) in labeled property graphs. Properties can be attached to both vertices and edges. Each vertex can have one or multiple tags (labels).</p> <p></p> <p>Graph databases are well suited for storing most kinds of data models abstracted from reality. Things are connected in almost all fields in the world. Modeling systems like relational databases extract the relationships between entities and squeeze them into table columns alone, with their types and properties stored in other columns or even other tables. This makes data management time-consuming and cost-ineffective.</p> <p>NebulaGraph, as a typical native graph database, allows you to store the rich relationships as edges with edge types and properties directly attached to them.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#advantages_of_nebulagraph","title":"Advantages of NebulaGraph","text":""},{"location":"1.introduction/1.what-is-nebula-graph/#open_source","title":"Open source","text":"<p>NebulaGraph is open under the Apache 2.0 License. More and more people such as database developers, data scientists, security experts, and algorithm engineers are participating in the designing and development of NebulaGraph. To join the opening of source code and ideas, surf the NebulaGraph GitHub page.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#outstanding_performance","title":"Outstanding performance","text":"<p>Written in C++ and born for graphs, NebulaGraph handles graph queries in milliseconds. Among most databases, NebulaGraph shows superior performance in providing graph data services. The larger the data size, the greater the superiority of NebulaGraph.For more information, see NebulaGraph benchmarking.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#high_scalability","title":"High scalability","text":"<p>NebulaGraph is designed in a shared-nothing architecture and supports scaling in and out without interrupting the database service.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#developer_friendly","title":"Developer friendly","text":"<p>NebulaGraph supports clients in popular programming languages like Java, Python, C++, and Go, and more are under development. For more information, see NebulaGraph clients.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#reliable_access_control","title":"Reliable access control","text":"<p>NebulaGraph supports strict role-based access control and external authentication servers such as LDAP (Lightweight Directory Access Protocol) servers to enhance data security. For more information, see Authentication and authorization.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#diversified_ecosystem","title":"Diversified ecosystem","text":"<p>More and more native tools of NebulaGraph have been released, such as NebulaGraph Studio, NebulaGraph Console, and NebulaGraph Exchange. For more ecosystem tools, see Ecosystem tools overview.</p> <p>Besides, NebulaGraph has the ability to be integrated with many cutting-edge technologies, such as Spark, Flink, and HBase, for the purpose of mutual strengthening in a world of increasing challenges and chances.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#opencypher-compatible_query_language","title":"OpenCypher-compatible query language","text":"<p>The native NebulaGraph Query Language, also known as nGQL, is a declarative, openCypher-compatible textual query language. It is easy to understand and easy to use. For more information, see nGQL guide.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#future-oriented_hardware_with_balanced_reading_and_writing","title":"Future-oriented hardware with balanced reading and writing","text":"<p>Solid-state drives have extremely high performance and they are getting cheaper. NebulaGraph is a product based on SSD. Compared with products based on HDD and large memory, it is more suitable for future hardware trends and easier to achieve balanced reading and writing.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#easy_data_modeling_and_high_flexibility","title":"Easy data modeling and high flexibility","text":"<p>You can easily model the connected data into NebulaGraph for your business without forcing them into a structure such as a relational table, and properties can be added, updated, and deleted freely. For more information, see Data modeling.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#high_popularity","title":"High popularity","text":"<p>NebulaGraph is being used by tech leaders such as Tencent, Vivo, Meituan, and JD Digits. For more information, visit the NebulaGraph official website.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#use_cases","title":"Use cases","text":"<p>NebulaGraph can be used to support various graph-based scenarios. To spare the time spent on pushing the kinds of data mentioned in this section into relational databases and on bothering with join queries, use NebulaGraph.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#fraud_detection","title":"Fraud detection","text":"<p>Financial institutions have to traverse countless transactions to piece together potential crimes and understand how combinations of transactions and devices might be related to a single fraud scheme. This kind of scenario can be modeled in graphs, and with the help of NebulaGraph, fraud rings and other sophisticated scams can be easily detected.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#real-time_recommendation","title":"Real-time recommendation","text":"<p>NebulaGraph offers the ability to instantly process the real-time information produced by a visitor and make accurate recommendations on articles, videos, products, and services.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#intelligent_question-answer_system","title":"Intelligent question-answer system","text":"<p>Natural languages can be transformed into knowledge graphs and stored in NebulaGraph. A question organized in a natural language can be resolved by a semantic parser in an intelligent question-answer system and re-organized. Then, possible answers to the question can be retrieved from the knowledge graph and provided to the one who asked the question.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#social_networking","title":"Social networking","text":"<p>Information on people and their relationships is typical graph data. NebulaGraph can easily handle the social networking information of billions of people and trillions of relationships, and provide lightning-fast queries for friend recommendations and job promotions in the case of massive concurrency.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#related_links","title":"Related links","text":"<ul> <li>Official website</li> <li>Docs</li> <li>Blogs</li> <li>Forum</li> <li>GitHub</li> </ul>"},{"location":"1.introduction/2.1.path/","title":"Path types","text":"<p>In graph theory, a path in a graph is a finite or infinite sequence of edges which joins a sequence of vertices. Paths are fundamental concepts of graph theory.</p> <p>Paths can be categorized into 3 types: <code>walk</code>, <code>trail</code>, and <code>path</code>. For more information, see Wikipedia.</p> <p>The following figure is an example for a brief introduction.</p> <p></p>"},{"location":"1.introduction/2.1.path/#walk","title":"Walk","text":"<p>A <code>walk</code> is a finite or infinite sequence of edges. Both vertices and edges can be repeatedly visited in graph traversal.</p> <p>In the above figure C, D, and E form a cycle. So, this figure contains infinite paths, such as <code>A-&gt;B-&gt;C-&gt;D-&gt;E</code>, <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>, and <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;D</code>.</p> <p>Note</p> <p><code>GO</code> statements use <code>walk</code>.</p>"},{"location":"1.introduction/2.1.path/#trail","title":"Trail","text":"<p>A <code>trail</code> is a finite sequence of edges. Only vertices can be repeatedly visited in graph traversal. The Seven Bridges of K\u00f6nigsberg is a typical <code>trail</code>.</p> <p>In the above figure, edges cannot be repeatedly visited. So, this figure contains finite paths. The longest path in this figure consists of 5 edges: <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>.</p> <p>Note</p> <p><code>MATCH</code>, <code>FIND PATH</code>, and <code>GET SUBGRAPH</code> statements use <code>trail</code>.</p> <p>There are two special cases of trail, <code>cycle</code> and <code>circuit</code>. The following figure is an example for a brief introduction.</p> <p></p> <ul> <li> <p>cycle</p> <p>A <code>cycle</code> refers to a closed <code>trail</code>. Only the terminal vertices can be repeatedly visited. The longest path in this figure consists of 3 edges: <code>A-&gt;B-&gt;C-&gt;A</code> or <code>C-&gt;D-&gt;E-&gt;C</code>.</p> </li> </ul> <ul> <li> <p>circuit</p> <p>A <code>circuit</code> refers to a closed <code>trail</code>. Edges cannot be repeatedly visited in graph traversal. Apart from the terminal vertices, other vertices can also be repeatedly visited. The longest path in this figure: <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;A</code>.</p> </li> </ul>"},{"location":"1.introduction/2.1.path/#path","title":"Path","text":"<p>A <code>path</code> is a finite sequence of edges. Neither vertices nor edges can be repeatedly visited in graph traversal.</p> <p>So, the above figure contains finite paths. The longest path in this figure consists of 4 edges: <code>A-&gt;B-&gt;C-&gt;D-&gt;E</code>.</p>"},{"location":"1.introduction/2.data-model/","title":"Data modeling","text":"<p>A data model is a model that organizes data and specifies how they are related to one another. This topic describes the Nebula\u00a0Graph data model and provides suggestions for data modeling with NebulaGraph.</p>"},{"location":"1.introduction/2.data-model/#data_structures","title":"Data structures","text":"<p>NebulaGraph data model uses six data structures to store data. They are graph spaces, vertices, edges, tags, edge types and properties.</p> <ul> <li>Graph spaces: Graph spaces are used to isolate data from different teams or programs. Data stored in different graph spaces are securely isolated. Storage replications, privileges, and partitions can be assigned.</li> </ul> <ul> <li>Vertices: Vertices are used to store entities.</li> </ul> <ul> <li> <p>In NebulaGraph, vertices are identified with vertex identifiers (i.e. <code>VID</code>). The <code>VID</code> must be unique in the same graph space. VID should be int64, or fixed_string(N).</p> <ul> <li>A vertex has zero to multiple tags.</li> </ul> <p>Compatibility</p> <p>In NebulaGraph 2.x a vertex must have at least one tag. And in NebulaGraph 2.0.0, a tag is not required for a vertex.</p> </li> </ul> <ul> <li>Edges: Edges are used to connect vertices. An edge is a connection or behavior between two vertices.<ul> <li>There can be multiple edges between two vertices.</li> <li>Edges are directed. <code>-&gt;</code> identifies the directions of edges. Edges can be traversed in either direction.</li> <li>An edge is identified uniquely with <code>&lt;a source vertex, an edge type, a rank value, and a destination vertex&gt;</code>. Edges have no EID.</li> <li>An edge must have one and only one edge type.</li> <li>The rank value is an immutable user-assigned 64-bit signed integer. It identifies the edges with the same edge type between two vertices. Edges are sorted by their rank values. The edge with the greatest rank value is listed first. The default rank value is zero.</li> </ul> </li> </ul> <ul> <li>Tags: Tags are used to categorize vertices. Vertices that have the same tag share the same definition of properties.</li> </ul> <ul> <li>Edge types: Edge types are used to categorize edges. Edges that have the same edge type share the same definition of properties.</li> </ul> <ul> <li>Properties: Properties are key-value pairs. Both vertices and edges are containers for properties.</li> </ul> <p>Note</p> <p>Tags and Edge types are similar to \"vertex tables\" and \"edge tables\" in the relational databases.</p>"},{"location":"1.introduction/2.data-model/#directed_property_graph","title":"Directed property graph","text":"<p>NebulaGraph stores data in directed property graphs. A directed property graph has a set of vertices connected by directed edges. Both vertices and edges can have properties. A directed property graph is represented as:</p> <p>G = &lt; V, E, P<sub>V</sub>, P<sub>E</sub> &gt;</p> <ul> <li>V is a set of vertices.</li> <li>E is a set of directed edges.</li> <li>P<sub>V</sub> is the property of vertices.</li> <li>P<sub>E</sub> is the property of edges.</li> </ul> <p>The following table is an example of the structure of the basketball player dataset. We have two types of vertices, that is player and team, and two types of edges, that is serve and follow.</p> Element Name Property name (Data type) Description Tag player name (string) age (int) Represents players in the team. Tag team name (string) Represents the teams. Edge type serve start_year (int)  end_year (int) Represents actions taken by players in the team.An action links a player with a team, and the direction is from a player to a team. Edge type follow degree (int) Represents actions taken by players in the team.An action links a player with another player, and the direction is from one player to the other player. <p>Note</p> <p>NebulaGraph supports only directed edges.</p> <p>Compatibility</p> <p>NebulaGraph 2.0.0 allows dangling edges. Therefore, when adding or deleting, you need to ensure the corresponding source vertex and destination vertex of an edge exist. For details, see INSERT VERTEX, DELETE VERTEX, INSERT EDGE, and DELETE EDGE.</p> <p>The MERGE statement in openCypher is not supported.</p>"},{"location":"1.introduction/3.vid/","title":"VID","text":"<p>In a graph space, a vertex is uniquely identified by its ID, which is called a VID or a Vertex ID.</p>"},{"location":"1.introduction/3.vid/#features","title":"Features","text":"<ul> <li>The data types of VIDs are restricted to <code>FIXED_STRING(&lt;N&gt;)</code> or <code>INT64</code>. One graph space can only select one VID type.</li> </ul> <ul> <li>A VID in a graph space is unique. It functions just as a primary key in a relational database. VIDs in different graph spaces are independent.</li> </ul> <ul> <li>The VID generation method must be set by users, because NebulaGraph does not provide auto increasing ID, or UUID.</li> </ul> <ul> <li> <p>Vertices with the same VID will be identified as the same one. For example:</p> <ul> <li>A VID is the unique identifier of an entity, like a person's ID card number. A tag means the type of an entity,  such as driver, and boss. Different tags define two groups of different properties, such as driving license number, driving age, order amount, order taking alt, and job number, payroll, debt ceiling, business phone number.</li> </ul> <ul> <li>When two <code>INSERT</code> statements (neither uses a parameter of <code>IF NOT EXISTS</code>) with the same VID and tag are operated at the same time, the latter <code>INSERT</code> will overwrite the former.</li> </ul> <ul> <li>When two <code>INSERT</code> statements with the same VID but different tags, like <code>TAG A</code> and <code>TAG B</code>, are operated at the same time, the operation of <code>Tag A</code> will not affect <code>Tag B</code>.</li> </ul> </li> </ul> <ul> <li>VIDs will usually be indexed and stored into memory (in the way of LSM-tree). Thus, direct access to VIDs enjoys peak performance.</li> </ul>"},{"location":"1.introduction/3.vid/#vid_operation","title":"VID Operation","text":"<ul> <li>NebulaGraph 1.x only supports <code>INT64</code> while NebulaGraph 2.x supports <code>INT64</code> and <code>FIXED_STRING(&lt;N&gt;)</code>. In <code>CREATE SPACE</code>, VID types can be set via <code>vid_type</code>.</li> </ul> <ul> <li><code>id()</code> function can be used to specify or locate a VID.</li> </ul> <ul> <li><code>LOOKUP</code> or <code>MATCH</code> statements can be used to find a VID via property index.</li> </ul> <ul> <li>Direct access to vertices statements via VIDs enjoys peak performance, such as <code>DELETE xxx WHERE id(xxx) == \"player100\"</code> or <code>GO FROM \"player100\"</code>. Finding VIDs via properties and then operating the graph will cause poor performance, such as <code>LOOKUP | GO FROM $-.ids</code>, which will run both <code>LOOKUP</code> and <code>|</code> one more time.</li> </ul>"},{"location":"1.introduction/3.vid/#vid_generation","title":"VID Generation","text":"<p>VIDs can be generated via applications. Here are some tips:</p> <ul> <li>(Optimal) Directly take a unique primary key or property as a VID. Property access depends on the VID.</li> </ul> <ul> <li>Generate a VID via a unique combination of properties. Property access depends on property index.</li> </ul> <ul> <li>Generate a VID via algorithms like snowflake. Property access depends on property index.</li> </ul> <ul> <li>If short primary keys greatly outnumber long primary keys, do not enlarge the <code>N</code> of <code>FIXED_STRING(&lt;N&gt;)</code> too much. Otherwise, it will occupy a lot of memory and hard disks, and slow down performance. Generate VIDs via BASE64, MD5, hash by encoding and splicing.</li> </ul> <ul> <li>If you generate int64 VID via hash, the probability of collision is about 1/10 when there are 1 billion vertices. The number of edges has no concern with the probability of collision.</li> </ul>"},{"location":"1.introduction/3.vid/#define_and_modify_a_vid_and_its_data_type","title":"Define and modify a VID and its data type","text":"<p>The data type of a VID must be defined when you create the graph space. Once defined, it cannot be modified.</p> <p>A VID is set when you insert a vertex and cannot be modified. </p>"},{"location":"1.introduction/3.vid/#query_start_vid_and_global_scan","title":"Query <code>start vid</code> and global scan","text":"<p>In most cases, the execution plan of query statements in NebulaGraph (<code>MATCH</code>, <code>GO</code>, and <code>LOOKUP</code>) must query the <code>start vid</code> in a certain way.</p> <p>There are only two ways to locate <code>start vid</code>:</p> <ol> <li> <p>For example, <code>GO FROM \"player100\" OVER</code> explicitly indicates in the statement that <code>start vid</code> is \"player100\".</p> </li> <li> <p>For example, <code>LOOKUP ON player WHERE player.name == \"Tony Parker\"</code> or <code>MATCH (v:player {name:\"Tony Parker\"})</code> locates <code>start vid</code> by the index of the property <code>player.name</code>.</p> </li> </ol>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/","title":"Architecture overview","text":"<p>NebulaGraph consists of three services: the Graph Service, the Storage Service, and the Meta Service. It applies the separation of storage and computing architecture.</p> <p>Each service has its executable binaries and processes launched from the binaries. Users can deploy a NebulaGraph cluster on a single machine or multiple machines using these binaries.</p> <p>The following figure shows the architecture of a typical NebulaGraph cluster.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_meta_service","title":"The Meta Service","text":"<p>The Meta Service in the NebulaGraph architecture is run by the nebula-metad processes. It is responsible for metadata management, such as schema operations, cluster administration, and user privilege management.</p> <p>For details on the Meta Service, see Meta Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_graph_service_and_the_storage_service","title":"The Graph Service and the Storage Service","text":"<p>NebulaGraph applies the separation of storage and computing architecture. The Graph Service is responsible for querying. The Storage Service is responsible for storage. They are run by different processes, i.e., nebula-graphd and nebula-storaged. The benefits of the separation of storage and computing architecture are as follows:</p> <ul> <li>Great scalability<p>The separated structure makes both the Graph Service and the Storage Service flexible and easy to scale in or out.</p> </li> </ul> <ul> <li>High availability<p>If part of the Graph Service fails, the data stored by the Storage Service suffers no loss. And if the rest part of the Graph Service is still able to serve the clients, service recovery can be performed quickly, even unfelt by the users.</p> </li> </ul> <ul> <li>Cost-effective<p>The separation of storage and computing architecture provides a higher resource utilization rate, and it enables clients to manage the cost flexibly according to business demands.</p> </li> </ul> <ul> <li>Open to more possibilities<p>With the ability to run separately, the Graph Service may work with multiple types of storage engines, and the Storage Service may also serve more types of computing engines.</p> </li> </ul> <p>For details on the Graph Service and the Storage Service, see Graph Service and Storage Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/","title":"Meta Service","text":"<p>This topic introduces the architecture and functions of the Meta Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#the_architecture_of_the_meta_service","title":"The architecture of the Meta Service","text":"<p>The architecture of the Meta Service is as follows:</p> <p></p> <p>The Meta Service is run by nebula-metad processes. Users can deploy nebula-metad processes according to the scenario:</p> <ul> <li>In a test environment, users can deploy one or three nebula-metad processes on different machines or a single machine.</li> <li>In a production environment, we recommend that users deploy three nebula-metad processes on different machines for high availability.</li> </ul> <p>All the nebula-metad processes form a Raft-based cluster, with one process as the leader and the others as the followers.</p> <p>The leader is elected by the majorities and only the leader can provide service to the clients or other components of NebulaGraph. The followers will be run in a standby way and each has a data replication of the leader. Once the leader fails, one of the followers will be elected as the new leader.</p> <p>Note</p> <p>The data of the leader and the followers will keep consistent through Raft. Thus the breakdown and election of the leader will not cause data inconsistency. For more information on Raft, see Storage service architecture.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#functions_of_the_meta_service","title":"Functions of the Meta Service","text":""},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_user_accounts","title":"Manages user accounts","text":"<p>The Meta Service stores the information of user accounts and the privileges granted to the accounts. When the clients send queries to the Meta Service through an account, the Meta Service checks the account information and whether the account has the right privileges to execute the queries or not.</p> <p>For more information on NebulaGraph access control, see Authentication.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_partitions","title":"Manages partitions","text":"<p>The Meta Service stores and manages the locations of the storage partitions and helps balance the partitions.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_graph_spaces","title":"Manages graph spaces","text":"<p>NebulaGraph supports multiple graph spaces. Data stored in different graph spaces are securely isolated. The Meta Service stores the metadata of all graph spaces and tracks the changes of them, such as adding or dropping a graph space.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_schema_information","title":"Manages schema information","text":"<p>NebulaGraph is a strong-typed graph database. Its schema contains tags (i.e., the vertex types), edge types, tag properties, and edge type properties.</p> <p>The Meta Service stores the schema information. Besides, it performs the addition, modification, and deletion of the schema, and logs the versions of them.</p> <p>For more information on NebulaGraph schema, see Data model.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_ttl_information","title":"Manages TTL information","text":"<p>The Meta Service stores the definition of TTL (Time to Live) options which are used to control data expiration. The Storage Service takes care of the expiring and evicting processes. For more information, see TTL.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_jobs","title":"Manages jobs","text":"<p>The Job Management module in the Meta Service is responsible for the creation, queuing, querying, and deletion of jobs.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/","title":"Graph Service","text":"<p>The Graph Service is used to process the query. It has four submodules: Parser, Validator, Planner, and Executor. This topic will describe the Graph Service accordingly.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#the_architecture_of_the_graph_service","title":"The architecture of the Graph Service","text":"<p>After a query is sent to the Graph Service, it will be processed by the following four submodules:</p> <ol> <li> <p>Parser: Performs lexical analysis and syntax analysis.</p> </li> <li> <p>Validator: Validates the statements.</p> </li> <li> <p>Planner: Generates and optimizes the execution plans.</p> </li> <li> <p>Executor: Executes the plans with operators.</p> </li> </ol>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#parser","title":"Parser","text":"<p>After receiving a request, the statements will be parsed by Parser composed of Flex (lexical analysis tool) and Bison (syntax analysis tool), and its corresponding AST will be generated. Statements will be directly intercepted in this stage because of their invalid syntax.</p> <p>For example, the structure of the AST of <code>GO FROM \"Tim\" OVER like WHERE properties(edge).likeness &gt; 8.0 YIELD dst(edge)</code> is shown in the following figure.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#validator","title":"Validator","text":"<p>Validator performs a series of validations on the AST. It mainly works on these tasks:</p> <ul> <li>Validating metadata<p>Validator will validate whether the metadata is correct or not.</p> <p>When parsing the <code>OVER</code>, <code>WHERE</code>, and <code>YIELD</code> clauses, Validator looks up the Schema and verifies whether the edge type and tag data exist or not. For an <code>INSERT</code> statement, Validator verifies whether the types of the inserted data are the same as the ones defined in the Schema.</p> </li> </ul> <ul> <li>Validating contextual reference<p>Validator will verify whether the cited variable exists or not, or whether the cited property is variable or not.</p> <p>For composite statements, like <code>$var = GO FROM \"Tim\" OVER like YIELD dst(edge) AS ID; GO FROM $var.ID OVER serve YIELD dst(edge)</code>, Validator verifies first to see if <code>var</code> is defined, and then to check if the <code>ID</code> property is attached to the <code>var</code> variable.</p> </li> </ul> <ul> <li>Validating type inference<p>Validator infers what type the result of an expression is and verifies the type against the specified clause.</p> <p>For example, the <code>WHERE</code> clause requires the result to be a <code>bool</code> value, a <code>NULL</code> value, or <code>empty</code>.</p> </li> </ul> <ul> <li>Validating the information of <code>*</code><p>Validator needs to verify all the Schema that involves <code>*</code> when verifying the clause if there is a <code>*</code> in the statement.</p> <p>Take a statement like <code>GO FROM \"Tim\" OVER * YIELD dst(edge), properties(edge).likeness, dst(edge)</code> as an example. When verifying the <code>OVER</code> clause, Validator needs to verify all the edge types. If the edge type includes <code>like</code> and <code>serve</code>, the statement would be <code>GO FROM \"Tim\" OVER like,serve YIELD dst(edge), properties(edge).likeness, dst(edge)</code>.</p> </li> </ul> <ul> <li>Validating input and output<p>Validator will check the consistency of the clauses before and after the <code>|</code>.</p> <p>In the statement <code>GO FROM \"Tim\" OVER like YIELD dst(edge) AS ID | GO FROM $-.ID OVER serve YIELD dst(edge)</code>, Validator will verify whether <code>$-.ID</code> is defined in the clause before the <code>|</code>.</p> </li> </ul> <p>When the validation succeeds, an execution plan will be generated. Its data structure will be stored in the <code>src/planner</code> directory.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#planner","title":"Planner","text":"<p>In the <code>nebula-graphd.conf</code> file, when <code>enable_optimizer</code> is set to be <code>false</code>, Planner will not optimize the execution plans generated by Validator. It will be executed by Executor directly.</p> <p>In the <code>nebula-graphd.conf</code> file, when <code>enable_optimizer</code> is set to be <code>true</code>, Planner will optimize the execution plans generated by Validator. The structure is as follows.</p> <p></p> <ul> <li>Before optimization<p>In the execution plan on the right side of the preceding figure, each node directly depends on other nodes. For example, the root node <code>Project</code> depends on the <code>Filter</code> node, the <code>Filter</code> node depends on the <code>GetNeighbor</code> node, and so on, up to the leaf node <code>Start</code>. Then the execution plan is (not truly) executed.</p> <p>During this stage, every node has its input and output variables, which are stored in a hash table. The execution plan is not truly executed, so the value of each key in the associated hash table is empty (except for the <code>Start</code> node, where the input variables hold the starting data), and the hash table is defined in <code>src/context/ExecutionContext.cpp</code> under the <code>nebula-graph</code> repository.</p> <p>For example, if the hash table is named as <code>ResultMap</code> when creating the <code>Filter</code> node, users can determine that the node takes data from <code>ResultMap[\"GN1\"]</code>, then puts the result into <code>ResultMap[\"Filter2\"]</code>, and so on. All these work as the input and output of each node.</p> </li> </ul> <ul> <li>Process of optimization<p>The optimization rules that Planner has implemented so far are considered RBO (Rule-Based Optimization), namely the pre-defined optimization rules. The CBO (Cost-Based Optimization) feature is under development. The optimized code is in the <code>src/optimizer/</code> directory under the <code>nebula-graph</code> repository.</p> <p>RBO is a \u201cbottom-up\u201d exploration process. For each rule, the root node of the execution plan (in this case, the <code>Project</code> node) is the entry point, and step by step along with the node dependencies, it reaches the node at the bottom to see if it matches the rule.</p> <p>As shown in the preceding figure, when the <code>Filter</code> node is explored, it is found that its children node is <code>GetNeighbors</code>, which matches successfully with the pre-defined rules, so a transformation is initiated to integrate the <code>Filter</code> node into the <code>GetNeighbors</code> node, the <code>Filter</code> node is removed, and then the process continues to the next rule. Therefore, when the <code>GetNeighbor</code> operator calls interfaces of the Storage layer to get the neighboring edges of a vertex during the execution stage, the Storage layer will directly filter out the unqualified edges internally. Such optimization greatly reduces the amount of data transfer, which is commonly known as filter pushdown.</p> </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#executor","title":"Executor","text":"<p>The Executor module consists of Scheduler and Executor. The Scheduler generates the corresponding execution operators against the execution plan, starting from the leaf nodes and ending at the root node. The structure is as follows.</p> <p></p> <p>Each node of the execution plan has one execution operator node, whose input and output have been determined in the execution plan. Each operator only needs to get the values for the input variables, compute them, and finally put the results into the corresponding output variables. Therefore, it is only necessary to execute step by step from <code>Start</code>, and the result of the last operator is returned to the user as the final result.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#source_code_hierarchy","title":"Source code hierarchy","text":"<p>The source code hierarchy under the nebula-graph repository is as follows.</p> <pre><code>|--src\n   |--graph\n      |--context    //contexts for validation and execution\n      |--executor   //execution operators\n      |--gc         //garbage collector\n      |--optimizer  //optimization rules\n      |--planner    //structure of the execution plans\n      |--scheduler  //scheduler\n      |--service    //external service management\n      |--session    //session management\n      |--stats      //monitoring metrics\n      |--util       //basic components\n      |--validator  //validation of the statements\n      |--visitor    //visitor expression\n</code></pre>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/","title":"Storage Service","text":"<p>The persistent data of NebulaGraph have two parts. One is the Meta Service that stores the meta-related data.</p> <p>The other is the Storage Service that stores the data, which is run by the nebula-storaged process. This topic will describe the architecture of the Storage Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#advantages","title":"Advantages","text":"<ul> <li>High performance (Customized built-in KVStore)</li> </ul> <ul> <li>Great scalability (Shared-nothing architecture, not rely on NAS/SAN-like devices)</li> </ul> <ul> <li>Strong consistency (Raft)</li> </ul> <ul> <li>High availability (Raft)</li> </ul> <ul> <li>Supports synchronizing with the third party systems, such as Elasticsearch.</li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#the_architecture_of_the_storage_service","title":"The architecture of the Storage Service","text":"<p>The Storage Service is run by the nebula-storaged process. Users can deploy nebula-storaged processes on different occasions. For example, users can deploy 1 nebula-storaged process in a test environment and deploy 3 nebula-storaged processes in a production environment.</p> <p>All the nebula-storaged processes consist of a Raft-based cluster. There are three layers in the Storage Service:</p> <ul> <li> <p>Storage interface</p> <p>The top layer is the storage interface. It defines a set of APIs that are related to the graph concepts. These API requests will be translated into a set of KV operations targeting the corresponding Partition. For example:</p> <ul> <li><code>getNeighbors</code>: queries the in-edge or out-edge of a set of vertices, returns the edges and the corresponding properties, and supports conditional filtering.</li> </ul> <ul> <li><code>insert vertex/edge</code>: inserts a vertex or edge and its properties.</li> </ul> <ul> <li><code>getProps</code>: gets the properties of a vertex or an edge.</li> </ul> <p>It is this layer that makes the Storage Service a real graph storage. Otherwise, it is just a KV storage.</p> </li> </ul> <ul> <li> <p>Consensus</p> <p>Below the storage interface is the consensus layer that implements Multi Group Raft, which ensures the strong consistency and high availability of the Storage Service.</p> </li> </ul> <ul> <li> <p>Store engine</p> <p>The bottom layer is the local storage engine library, providing operations like <code>get</code>, <code>put</code>, and <code>scan</code> on local disks. The related interfaces are stored in <code>KVStore.h</code> and <code>KVEngine.h</code> files. You can develop your own local store plugins based on your needs.</p> </li> </ul> <p>The following will describe some features of the Storage Service based on the above architecture.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#storage_writing_process","title":"Storage writing process","text":""},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#kvstore","title":"KVStore","text":"<p>NebulaGraph develops and customizes its built-in KVStore for the following reasons.</p> <ul> <li>It is a high-performance KVStore.</li> </ul> <ul> <li>It is provided as a (kv) library and can be easily developed for the filter pushdown purpose. As a strong-typed database, how to provide Schema during pushdown is the key to efficiency for NebulaGraph.</li> </ul> <ul> <li>It has strong data consistency.</li> </ul> <p>Therefore, NebulaGraph develops its own KVStore with RocksDB as the local storage engine. The advantages are as follows.</p> <ul> <li>For multiple local hard disks, NebulaGraph can make full use of its concurrent capacities through deploying multiple data directories.</li> </ul> <ul> <li> <p>The Meta Service manages all the Storage servers. All the partition distribution data and current machine status can be found in the meta service. Accordingly, users can execute a manual load balancing plan in meta service.</p> <p>Note</p> <p>NebulaGraph does not support auto load balancing because auto data transfer will affect online business.</p> </li> </ul> <ul> <li>NebulaGraph provides its own WAL mode so one can customize the WAL. Each partition owns its WAL.</li> </ul> <ul> <li>One NebulaGraph KVStore cluster supports multiple graph spaces, and each graph space has its own partition number and replica copies. Different graph spaces are isolated physically from each other in the same cluster.</li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#data_storage_structure","title":"Data storage structure","text":"<p>Graphs consist of vertices and edges. NebulaGraph uses key-value pairs to store vertices, edges, and their properties. Vertices and edges are stored in keys and their properties are stored in values. Such structure enables efficient property filtering.</p> <ul> <li> <p>The storage structure of vertices</p> <p>Different from NebulaGraph version 2.x, version 3.x added a new key for each vertex. Compared to the old key that still exists, the new key has no <code>TagID</code> field and no value. Vertices in NebulaGraph can now live without tags owing to the new key.</p> <p></p> Field Description <code>Type</code> One byte, used to indicate the key type. <code>PartID</code> Three bytes, used to indicate the sharding partition and to scan the partition data based on the prefix when re-balancing the partition. <code>VertexID</code> The vertex ID. For an integer VertexID, it occupies eight bytes. However, for a string VertexID, it is changed to <code>fixed_string</code> of a fixed length which needs to be specified by users when they create the space. <code>TagID</code> Four bytes, used to indicate the tags that vertex relate with. <code>SerializedValue</code> The serialized value of the key. It stores the property information of the vertex. </li> </ul> <ul> <li>The storage structure of edges<p></p> Field Description <code>Type</code> One byte, used to indicate the key type. <code>PartID</code> Three bytes, used to indicate the partition ID. This field can be used to scan the partition data based on the prefix when re-balancing the partition. <code>VertexID</code> Used to indicate vertex ID. The former VID refers to the source VID in the outgoing edge and the dest VID in the incoming edge, while the latter VID refers to the dest VID in the outgoing edge and the source VID in the incoming edge. <code>Edge Type</code> Four bytes, used to indicate the edge type. Greater than zero indicates out-edge, less than zero means in-edge. <code>Rank</code> Eight bytes, used to indicate multiple edges in one edge type. Users can set the field based on needs and store weight, such as transaction time and transaction number. <code>PlaceHolder</code> One byte. Reserved. <code>SerializedValue</code> The serialized value of the key. It stores the property information of the edge. </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#property_descriptions","title":"Property descriptions","text":"<p>NebulaGraph uses strong-typed Schema.</p> <p>NebulaGraph will store the properties of vertex and edges in order after encoding them. Since the length of fixed-length properties is fixed, queries can be made in no time according to offset. Before decoding, NebulaGraph needs to get (and cache) the schema information in the Meta Service. In addition, when encoding properties, NebulaGraph will add the corresponding schema version to support online schema change.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#data_partitioning","title":"Data partitioning","text":"<p>Since in an ultra-large-scale relational network, vertices can be as many as tens to hundreds of billions, and edges are even more than trillions. Even if only vertices and edges are stored, the storage capacity of both exceeds that of ordinary servers. Therefore, NebulaGraph uses hash to shard the graph elements and store them in different partitions.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#edge_partitioning_and_storage_amplification","title":"Edge partitioning and storage amplification","text":"<p>In NebulaGraph, an edge corresponds to two key-value pairs on the hard disk. When there are lots of edges and each has many properties, storage amplification will be obvious. The storage format of edges is shown in the figure below.</p> <p></p> <p>In this example, SrcVertex connects DstVertex via EdgeA, forming the path of <code>(SrcVertex)-[EdgeA]-&gt;(DstVertex)</code>. SrcVertex, DstVertex, and EdgeA will all be stored in Partition x and Partition y as four key-value pairs in the storage layer. Details are as follows:</p> <ul> <li>The key value of SrcVertex is stored in Partition x. Key fields include Type, PartID(x), VID(Src), and TagID. SerializedValue, namely Value, refers to serialized vertex properties.</li> </ul> <ul> <li>The first key value of EdgeA, namely EdgeA_Out, is stored in the same partition as the SrcVertex. Key fields include Type, PartID(x), VID(Src), EdgeType(+ means out-edge), Rank(0), VID(Dst), and PlaceHolder. SerializedValue, namely Value, refers to serialized edge properties.</li> </ul> <ul> <li>The key value of DstVertex is stored in Partition y. Key fields include Type, PartID(y), VID(Dst), and TagID. SerializedValue, namely Value, refers to serialized vertex properties.</li> </ul> <ul> <li>The second key value of EdgeA, namely EdgeA_In, is stored in the same partition as the DstVertex. Key fields include Type, PartID(y), VID(Dst), EdgeType(- means in-edge), Rank(0), VID(Src), and PlaceHolder. SerializedValue, namely Value, refers to serialized edge properties, which is exactly the same as that in EdgeA_Out.</li> </ul> <p>EdgeA_Out and EdgeA_In are stored in storage layer with opposite directions, constituting EdgeA logically. EdgeA_Out is used for traversal requests starting from SrcVertex, such as <code>(a)-[]-&gt;()</code>; EdgeA_In is used for traversal requests starting from DstVertex, such as <code>()-[]-&gt;(a)</code>.</p> <p>Like EdgeA_Out and EdgeA_In, NebulaGraph redundantly stores the information of each edge, which doubles the actual capacities needed for edge storage. The key corresponding to the edge occupies a small hard disk space, but the space occupied by Value is proportional to the length and amount of the property value. Therefore, it will occupy a relatively large hard disk space if the property value of the edge is large or there are many edge property values.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#partition_algorithm","title":"Partition algorithm","text":"<p>NebulaGraph uses a static Hash strategy to shard data through a modulo operation on vertex ID. All the out-keys, in-keys, and tag data will be placed in the same partition. In this way, query efficiency is increased dramatically.</p> <p>Note</p> <p>The number of partitions needs to be determined when users are creating a graph space since it cannot be changed afterward. Users are supposed to take into consideration the demands of future business when setting it.</p> <p>When inserting into NebulaGraph, vertices and edges are distributed across different partitions. And the partitions are located on different machines. The number of partitions is set in the CREATE SPACE statement and cannot be changed afterward.</p> <p>If certain vertices need to be placed on the same partition (i.e., on the same machine), see Formula/code.</p> <p>The following code will briefly describe the relationship between VID and partition.</p> <pre><code>// If VertexID occupies 8 bytes, it will be stored in int64 to be compatible with the version 1.0.\nuint64_t vid = 0;\nif (id.size() == 8) {\n    memcpy(static_cast&lt;void*&gt;(&amp;vid), id.data(), 8);\n} else {\n    MurmurHash2 hash;\n    vid = hash(id.data());\n}\nPartitionID pId = vid % numParts + 1;\n</code></pre> <p>Roughly speaking, after hashing a fixed string to int64, (the hashing of int64 is the number itself), do modulo, and then plus one, namely:</p> <pre><code>pId = vid % numParts + 1;\n</code></pre> <p>Parameters and descriptions of the preceding formula are as follows:</p> Parameter Description <code>%</code> The modulo operation. <code>numParts</code> The number of partitions for the graph space where the <code>VID</code> is located, namely the value of <code>partition_num</code> in the CREATE SPACE statement. <code>pId</code> The ID for the partition where the <code>VID</code> is located. <p>Suppose there are 100 partitions, the vertices with <code>VID</code> 1, 101, and 1001 will be stored on the same partition. But, the mapping between the partition ID and the machine address is random. Therefore, we cannot assume that any two partitions are located on the same machine.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#raft","title":"Raft","text":""},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#raft_implementation","title":"Raft implementation","text":"<p>In a distributed system, one data usually has multiple replicas so that the system can still run normally even if a few copies fail. It requires certain technical means to ensure consistency between replicas.</p> <p>Basic principle: Raft is designed to ensure consistency between replicas. Raft uses election between replicas, and the (candidate) replica that wins more than half of the votes will become the Leader, providing external services on behalf of all replicas. The rest Followers will play backups. When the Leader fails (due to communication failure, operation and maintenance commands, etc.), the rest Followers will conduct a new round of elections and vote for a new Leader. The Leader and Followers will detect each other's survival through heartbeats and write them to the hard disk in Raft-wal mode. Replicas that do not respond to more than multiple heartbeats will be considered faulty.</p> <p>Note</p> <p>Raft-wal needs to be written into the hard disk periodically. If hard disk bottlenecks to write, Raft will fail to send a heartbeat and conduct a new round of elections. If the hard disk IO is severely blocked, there will be no Leader for a long time.</p> <p>Read and write: For every writing request of the clients, the Leader will initiate a Raft-wal and synchronize it with the Followers. Only after over half replicas have received the Raft-wal will it return to the clients successfully. For every reading request of the clients, it will get to the Leader directly, while Followers will not be involved.</p> <p>Failure: Scenario 1: Take a (space) cluster of a single replica as an example. If the system has only one replica, the Leader will be itself. If failure happens, the system will be completely unavailable. Scenario 2: Take a (space) cluster of three replicas as an example. If the system has three replicas, one of them will be the Leader and the rest will be the Followers. If the Leader fails, the rest two can still vote for a new Leader (and a Follower), and the system is still available. But if any of the two Followers fails again, the system will be completely unavailable due to inadequate voters.</p> <p>Note</p> <p>Raft and HDFS have different modes of duplication. Raft is based on a quorum vote, so the number of replicas cannot be even.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#multi_group_raft","title":"Multi Group Raft","text":"<p>The Storage Service supports a distributed cluster architecture, so NebulaGraph implements Multi Group Raft according to Raft protocol. Each Raft group stores all the replicas of each partition. One replica is the leader, while others are followers. In this way, NebulaGraph achieves strong consistency and high availability. The functions of Raft are as follows.</p> <p>NebulaGraph uses Multi Group Raft to improve performance when there are many partitions because Raft-wal cannot be NULL. When there are too many partitions, costs will increase, such as storing information in Raft group, WAL files, or batch operation in low load.</p> <p>There are two key points to implement the Multi Raft Group:</p> <ul> <li> <p>To share transport layer</p> <p>Each Raft Group sends messages to its corresponding peers. So if the transport layer cannot be shared, the connection costs will be very high.</p> </li> </ul> <ul> <li> <p>To share thread pool</p> <p>Raft Groups share the same thread pool to prevent starting too many threads and a high context switch cost.</p> </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#batch","title":"Batch","text":"<p>For each partition, it is necessary to do a batch to improve throughput when writing the WAL serially. As NebulaGraph uses WAL to implement some special functions, batches need to be grouped, which is a feature of NebulaGraph.</p> <p>For example, lock-free CAS operations will execute after all the previous WALs are committed. So for a batch, if there are several WALs in CAS type, we need to divide this batch into several smaller groups and make sure they are committed serially.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#transfer_leadership","title":"Transfer Leadership","text":"<p>Transfer leadership is extremely important for balance. When moving a partition from one machine to another, NebulaGraph first checks if the source is a leader. If so, it should be moved to another peer. After data migration is completed, it is important to balance leader distribution again.</p> <p>When a transfer leadership command is committed, the leader will abandon its leadership and the followers will start a leader election.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#peer_changes","title":"Peer changes","text":"<p>To avoid split-brain, when members in a Raft Group change, an intermediate state is required. In such a state, the quorum of the old group and new group always have an overlap. Thus it prevents the old or new group from making decisions unilaterally. To make it even simpler, in his doctoral thesis Diego Ongaro suggests adding or removing a peer once to ensure the overlap between the quorum of the new group and the old group. NebulaGraph also uses this approach, except that the way to add or remove a member is different. For details, please refer to addPeer/removePeer in the Raft Part class.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#differences_with_hdfs","title":"Differences with HDFS","text":"<p>The Storage Service is a Raft-based distributed architecture, which has certain differences with that of HDFS. For example:</p> <ul> <li>The Storage Service ensures consistency through Raft. Usually, the number of its replicas is odd to elect a leader. However, DataNode used by HDFS ensures consistency through NameNode, which has no limit on the number of replicas.</li> </ul> <ul> <li>In the Storage Service, only the replicas of the leader can read and write, while in HDFS all the replicas can do so.</li> </ul> <ul> <li>In the Storage Service, the number of replicas needs to be determined when creating a space, since it cannot be changed afterward. But in HDFS, the number of replicas can be changed freely.</li> </ul> <ul> <li>The Storage Service can access the file system directly. While the applications of HDFS (such as HBase) have to access HDFS before the file system, which requires more RPC times.</li> </ul> <p>In a word, the Storage Service is more lightweight with some functions simplified and its architecture is simpler than HDFS, which can effectively improve the read and write performance of a smaller block of data.</p>"},{"location":"2.quick-start/1.quick-start-workflow/","title":"Quickly deploy NebulaGraph using Docker","text":"<p>You can quickly get started with NebulaGraph by deploying NebulaGraph with Docker Desktop or Docker Compose. </p> <p>=== \"Using Docker Desktop\"</p> <pre><code>NebulaGraph is available as a [Docker Extension](https://hub.docker.com/extensions/weygu/nebulagraph-dd-ext) that you can easily install and run on your Docker Desktop. You can quickly deploy NebulaGraph using Docker Desktop with just one click.\n\n1. Install Docker Desktop\n\n  - [Install Docker Desktop on Mac](https://docs.docker.com/docker-for-mac/install/)\n  - [Install Docker Desktop on Windows](https://docs.docker.com/docker-for-windows/install/)\n\n  !!! caution\n      To install Docker Desktop, you need to install [WSL 2](https://docs.docker.com/desktop/install/windows-install/#system-requirements) first.\n\n2. In the left sidebar of Docker Desktop, click **Extensions** or **Add Extensions**.\n3. On the Extensions Marketplace, search for NebulaGraph and click **Install**.\n\n  ![docker](https://docs-cdn.nebula-graph.com.cn/figures/docker.png)\n\n  Click **Update** to update NebulaGraph to the latest version when a new version is available.\n\n  ![docker-update](https://docs-cdn.nebula-graph.com.cn/figures/docker-update.png)\n\n4. Click **Open** to navigate to the NebulaGraph extension page.\n\n5. At the top of the page, click **Studio in Browser** to use NebulaGraph.\n\nFor more information about how to use NebulaGraph with Docker Desktop, see the following video:\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/8zKer-4RXEg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen&gt;&lt;/iframe&gt;\n</code></pre> <p>=== \"Using Docker Compose\"</p> <pre><code>Using Docker Compose can quickly deploy NebulaGraph services based on the prepared configuration file. It is only recommended to use this method when testing the functions of NebulaGraph.\n\n## Prerequisites\n\n* You have installed the following applications on your host.\n\n  | Application    | Recommended version | Official installation reference                                    |\n  | -------------- | ------------------- | ------------------------------------------------------------------ |\n  | Docker         | Latest              | [Install Docker Engine](https://docs.docker.com/engine/install/)   |\n  | Docker Compose | Latest              | [Install Docker Compose](https://docs.docker.com/compose/install/) |\n  | Git            | Latest              | [Download Git](https://git-scm.com/download/)       |\n\n* If you are deploying NebulaGraph as a non-root user, grant the user with Docker-related privileges. For detailed instructions, see [Manage Docker as a non-root user](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user).\n\n* You have started the Docker service on your host.\n\n* If you have already deployed another version of NebulaGraph with Docker Compose on your host, to avoid compatibility issues, you need to delete the `nebula-docker-compose/data` directory.\n\n## Deploy NebulaGraph\n\n\n1. Clone the `2.0.0` branch of the `nebula-docker-compose` repository to your host with Git.\n\n  !!! danger\n\n        The `master` branch contains the untested code for the latest NebulaGraph development release. **DO NOT** use this release in a production environment.\n\n    ```bash\n    $ git clone -b release-2.0 https://github.com/vesoft-inc/nebula-docker-compose.git\n    ```\n\n  !!! Note\n\n        The `x.y` version of Docker Compose aligns to the `x.y` version of NebulaGraph. For the NebulaGraph `z` version, Docker Compose does not publish the corresponding `z` version, but pulls the `z` version of the NebulaGraph image.\n\n2. Go to the `nebula-docker-compose` directory.\n\n    ```bash\n    $ cd nebula-docker-compose/\n    ```\n\n3. Run the following command to start all the NebulaGraph services.\n\n\n  !!! Note\n\n        - Update the [NebulaGraph images](#how_to_upgrade_or_update_the_docker_images_of_nebulagraph_services) and [NebulaGraph Console images](#how_to_update_the_nebulagraph_console_client) first if they are out of date.\n        - The return result after executing the command varies depending on the installation directory.\n\n    ```bash\n    [nebula-docker-compose]$ docker-compose up -d\n    Creating nebula-docker-compose_metad0_1 ... done\n    Creating nebula-docker-compose_metad2_1 ... done\n    Creating nebula-docker-compose_metad1_1 ... done\n    Creating nebula-docker-compose_graphd2_1   ... done\n    Creating nebula-docker-compose_graphd_1    ... done\n    Creating nebula-docker-compose_graphd1_1   ... done\n    Creating nebula-docker-compose_storaged0_1 ... done\n    Creating nebula-docker-compose_storaged2_1 ... done\n    Creating nebula-docker-compose_storaged1_1 ... done\n    ```\n\n  !!! compatibility\n\n        Starting from NebulaGraph version 3.1.0, nebula-docker-compose automatically starts a NebulaGraph Console docker container and adds the storage host to the cluster (i.e. `ADD HOSTS` command).\n\n  !!! note\n\n        For more information of the preceding services, see [NebulaGraph architecture](../1.introduction/3.nebula-graph-architecture/1.architecture-overview.md).\n\n## Connect to NebulaGraph\n\nThere are two ways to connect to NebulaGraph:\n\n- Connected with Nebula Console outside the container. Because the external mapping port for the Graph service is also fixed as `9669` in the container's configuration file, you can connect directly through the default port. For details, see [Connect to NebulaGraph](../2.quick-start/3.connect-to-nebula-graph.md).\n\n- Log into the container installed NebulaGraph Console, then connect to the Graph service. This section describes this approach.\n\n1. Run the following command to view the name of NebulaGraph Console docker container.\n\n  ```bash\n  $ docker-compose ps\n            Name                         Command             State                 Ports\n  --------------------------------------------------------------------------------------------\n  nebula-docker-compose_console_1     sh -c sleep 3 &amp;&amp;          Up\n                                    nebula-co ...\n  ......\n  ```\n\n2. Run the following command to enter the NebulaGraph Console docker container.\n\n  ```bash\n  docker exec -it nebula-docker-compose_console_1 /bin/sh\n  / #\n  ```\n\n3. Connect to NebulaGraph with NebulaGraph Console.\n\n  ```bash\n  / # ./usr/local/bin/nebula-console -u &lt;user_name&gt; -p &lt;password&gt; --address=graphd --port=9669\n  ```\n\n  !!! Note\n\n        By default, the authentication is off, you can only log in with an existing username (the default is `root`) and any password. To turn it on, see [Enable authentication](../7.data-security/1.authentication/1.authentication.md).\n\n4. Run the following commands to view the cluster state.\n\n  ```bash\n  nebula&gt; SHOW HOSTS;\n  +-------------+------+----------+--------------+----------------------+------------------------+---------+\n  | Host        | Port | Status   | Leader count | Leader distribution  | Partition distribution | Version |\n  +-------------+------+----------+--------------+----------------------+------------------------+---------+\n  | \"storaged0\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"2.0.0\" |\n  | \"storaged1\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"2.0.0\" |\n  | \"storaged2\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"2.0.0\" |\n  +-------------+------+----------+--------------+----------------------+------------------------+---------+\n  ```\n\nRun `exit` twice to switch back to your terminal (shell).\n\n## Check the NebulaGraph service status and ports\n\nRun `docker-compose ps` to list all the services of NebulaGraph and their status and ports.\n\n!!! note\n\n    NebulaGraph provides services to the clients through port `9669` by default. To use other ports, modify the `docker-compose.yaml` file in the `nebula-docker-compose` directory and restart the NebulaGraph services.\n\n```bash\n$ docker-compose ps\nnebula-docker-compose_console_1     sh -c sleep 3 &amp;&amp;                 Up\n                                  nebula-co ...\nnebula-docker-compose_graphd1_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49174-&gt;19669/tcp,:::49174-&gt;19669/tcp, 0.0.0.0:49171-&gt;19670/tcp,:::49171-&gt;19670/tcp, 0.0.0.0:49177-&gt;9669/tcp,:::49177-&gt;9669/tcp\nnebula-docker-compose_graphd2_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49175-&gt;19669/tcp,:::49175-&gt;19669/tcp, 0.0.0.0:49172-&gt;19670/tcp,:::49172-&gt;19670/tcp, 0.0.0.0:49178-&gt;9669/tcp,:::49178-&gt;9669/tcp\nnebula-docker-compose_graphd_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49180-&gt;19669/tcp,:::49180-&gt;19669/tcp, 0.0.0.0:49179-&gt;19670/tcp,:::49179-&gt;19670/tcp, 0.0.0.0:9669-&gt;9669/tcp,:::9669-&gt;9669/tcp\nnebula-docker-compose_metad0_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49157-&gt;19559/tcp,:::49157-&gt;19559/tcp, 0.0.0.0:49154-&gt;19560/tcp,:::49154-&gt;19560/tcp, 0.0.0.0:49160-&gt;9559/tcp,:::49160-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad1_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49156-&gt;19559/tcp,:::49156-&gt;19559/tcp, 0.0.0.0:49153-&gt;19560/tcp,:::49153-&gt;19560/tcp, 0.0.0.0:49159-&gt;9559/tcp,:::49159-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad2_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49158-&gt;19559/tcp,:::49158-&gt;19559/tcp, 0.0.0.0:49155-&gt;19560/tcp,:::49155-&gt;19560/tcp, 0.0.0.0:49161-&gt;9559/tcp,:::49161-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_storaged0_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49166-&gt;19779/tcp,:::49166-&gt;19779/tcp, 0.0.0.0:49163-&gt;19780/tcp,:::49163-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49169-&gt;9779/tcp,:::49169-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged1_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49165-&gt;19779/tcp,:::49165-&gt;19779/tcp, 0.0.0.0:49162-&gt;19780/tcp,:::49162-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49168-&gt;9779/tcp,:::49168-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged2_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49167-&gt;19779/tcp,:::49167-&gt;19779/tcp, 0.0.0.0:49164-&gt;19780/tcp,:::49164-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49170-&gt;9779/tcp,:::49170-&gt;9779/tcp, 9780/tcp\n```\n\nIf the service is abnormal, you can first confirm the abnormal container name (such as `nebula-docker-compose_graphd2_1`).\n\nThen you can execute `docker ps` to view the corresponding `CONTAINER ID` (such as `2a6c56c405f5`).\n\n```bash\n[nebula-docker-compose]$ docker ps\nCONTAINER ID   IMAGE                               COMMAND                  CREATED          STATUS                    PORTS                                                                                                  NAMES\n2a6c56c405f5   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:49230-&gt;9669/tcp, 0.0.0.0:49229-&gt;19669/tcp, 0.0.0.0:49228-&gt;19670/tcp                            nebula-docker-compose_graphd2_1\n7042e0a8e83d   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49227-&gt;9779/tcp, 0.0.0.0:49226-&gt;19779/tcp, 0.0.0.0:49225-&gt;19780/tcp   nebula-docker-compose_storaged2_1\n18e3ea63ad65   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49219-&gt;9779/tcp, 0.0.0.0:49218-&gt;19779/tcp, 0.0.0.0:49217-&gt;19780/tcp   nebula-docker-compose_storaged0_1\n4dcabfe8677a   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:49224-&gt;9669/tcp, 0.0.0.0:49223-&gt;19669/tcp, 0.0.0.0:49222-&gt;19670/tcp                            nebula-docker-compose_graphd1_1\na74054c6ae25   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:9669-&gt;9669/tcp, 0.0.0.0:49221-&gt;19669/tcp, 0.0.0.0:49220-&gt;19670/tcp                             nebula-docker-compose_graphd_1\n880025a3858c   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49216-&gt;9779/tcp, 0.0.0.0:49215-&gt;19779/tcp, 0.0.0.0:49214-&gt;19780/tcp   nebula-docker-compose_storaged1_1\n45736a32a23a   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49213-&gt;9559/tcp, 0.0.0.0:49212-&gt;19559/tcp, 0.0.0.0:49211-&gt;19560/tcp                  nebula-docker-compose_metad0_1\n3b2c90eb073e   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49207-&gt;9559/tcp, 0.0.0.0:49206-&gt;19559/tcp, 0.0.0.0:49205-&gt;19560/tcp                  nebula-docker-compose_metad2_1\n7bb31b7a5b3f   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49210-&gt;9559/tcp, 0.0.0.0:49209-&gt;19559/tcp, 0.0.0.0:49208-&gt;19560/tcp                  nebula-docker-compose_metad1_1\n```\n\nUse the `CONTAINER ID` to log in the container and troubleshoot.\n\n```bash\nnebula-docker-compose]$ docker exec -it 2a6c56c405f5 bash\n[root@2a6c56c405f5 nebula]#\n```\n\n## Check the service data and logs\n\nAll the data and logs of NebulaGraph are stored persistently in the `nebula-docker-compose/data` and `nebula-docker-compose/logs` directories.\n\nThe structure of the directories is as follows:\n\n```text\nnebula-docker-compose/\n  |-- docker-compose.yaml\n  \u251c\u2500\u2500 data\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta1\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta2\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage1\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 storage2\n  \u2514\u2500\u2500 logs\n      \u251c\u2500\u2500 graph\n      \u251c\u2500\u2500 graph1\n      \u251c\u2500\u2500 graph2\n      \u251c\u2500\u2500 meta0\n      \u251c\u2500\u2500 meta1\n      \u251c\u2500\u2500 meta2\n      \u251c\u2500\u2500 storage0\n      \u251c\u2500\u2500 storage1\n      \u2514\u2500\u2500 storage2\n```\n\n## Stop the NebulaGraph services\n\nYou can run the following command to stop the NebulaGraph services:\n\n```bash\n$ docker-compose down\n```\n\nThe following information indicates you have successfully stopped the NebulaGraph services:\n\n```bash\nStopping nebula-docker-compose_console_1   ... done\nStopping nebula-docker-compose_graphd1_1   ... done\nStopping nebula-docker-compose_graphd_1    ... done\nStopping nebula-docker-compose_graphd2_1   ... done\nStopping nebula-docker-compose_storaged1_1 ... done\nStopping nebula-docker-compose_storaged0_1 ... done\nStopping nebula-docker-compose_storaged2_1 ... done\nStopping nebula-docker-compose_metad2_1    ... done\nStopping nebula-docker-compose_metad0_1    ... done\nStopping nebula-docker-compose_metad1_1    ... done\nRemoving nebula-docker-compose_console_1   ... done\nRemoving nebula-docker-compose_graphd1_1   ... done\nRemoving nebula-docker-compose_graphd_1    ... done\nRemoving nebula-docker-compose_graphd2_1   ... done\nRemoving nebula-docker-compose_storaged1_1 ... done\nRemoving nebula-docker-compose_storaged0_1 ... done\nRemoving nebula-docker-compose_storaged2_1 ... done\nRemoving nebula-docker-compose_metad2_1    ... done\nRemoving nebula-docker-compose_metad0_1    ... done\nRemoving nebula-docker-compose_metad1_1    ... done\nRemoving network nebula-docker-compose_nebula-net\n```\n\n!!! danger\n\n    The parameter `-v` in the command `docker-compose down -v` will **delete** all your local NebulaGraph storage data. Try this command if you are using the nightly release and having some compatibility issues.\n\n## Modify configurations\n\nThe configuration file of NebulaGraph deployed by Docker Compose is `nebula-docker-compose/docker-compose.yaml`. To make the new configuration take effect, modify the configuration in this file and restart the service.\n\nFor more instructions, see [Configurations](../5.configurations-and-logs/1.configurations/1.configurations.md).\n\n## FAQ\n\n### How to fix the docker mapping to external ports?\n\nTo set the `ports` of corresponding services as fixed mapping, modify the `docker-compose.yaml` in the `nebula-docker-compose` directory. For example:\n\n```bash\ngraphd:\n    image: vesoft/nebula-graphd:release-2.0\n    ...\n    ports:\n      - 9669:9669\n      - 19669\n      - 19670\n```\n\n`9669:9669` indicates the internal port 9669 is uniformly mapped to external ports, while `19669` indicates the internal port 19669 is randomly mapped to external ports.\n\n### How to upgrade or update the docker images of NebulaGraph services\n\n5. In the `nebula-docker-compose/docker-compose.yaml` file, change all the `image` values to the required image version.\n\n6. In the `nebula-docker-compose` directory, run `docker-compose pull` to update the images of the Graph Service, Storage Service, Meta Service, and NebulaGraph Console.\n\n7. Run `docker-compose up -d` to start the NebulaGraph services again.\n\n8. After connecting to NebulaGraph with NebulaGraph Console, run `SHOW HOSTS GRAPH`, `SHOW HOSTS STORAGE`, or `SHOW HOSTS META` to check the version of the responding service respectively.\n\n### `ERROR: toomanyrequests` when `docker-compose pull`\n\nYou may meet the following error.\n\n`ERROR: toomanyrequests: You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: https://www.docker.com/increase-rate-limit`.\n\nYou have met the rate limit of Docker Hub. Learn more on [Understanding Docker Hub Rate Limiting](https://www.docker.com/increase-rate-limit).\n\n### How to update the NebulaGraph Console client\n\nThe command `docker-compose pull` updates both the NebulaGraph services and the NebulaGraph Console.\n</code></pre>"},{"location":"2.quick-start/2.install-nebula-graph/","title":"Step 1: Install NebulaGraph","text":"<p>RPM and DEB are common package formats on Linux systems. This topic shows how to quickly install NebulaGraph with the RPM or DEB package.</p> <p>Note</p> <p>The console is not complied or packaged with NebulaGraph server binaries. You can install nebula-console by yourself.</p>"},{"location":"2.quick-start/2.install-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>The tool <code>wget</code> is installed.</li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#step_1_download_the_package_from_cloud_service","title":"Step 1: Download the package from cloud service","text":"<p>Note</p> <p>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </p> <ul> <li>Download the released version.<p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the release package <code>2.0.0</code> for <code>Centos 7.5</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>Download the release package <code>2.0.0</code> for <code>Ubuntu 1804</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul> <ul> <li> <p>Download the nightly version.</p> <p>Danger</p> <ul> <li>Nightly versions are usually used to test new features. Do not use it in a production environment.</li> <li>Nightly versions may not be built successfully every night. And the names may change from day to day.</li> </ul> <p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the <code>Centos 7.5</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>For example, download the <code>Ubuntu 1804</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#step_2_install_nebulagraph","title":"Step 2: Install NebulaGraph","text":"<ul> <li> <p>Use the following syntax to install with an RPM package.</p> <pre><code>$ sudo rpm -ivh --prefix=&lt;installation_path&gt; &lt;package_name&gt;\n</code></pre> <p>The option <code>--prefix</code> indicates the installation path. The default path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install an RPM package in the default path for the 2.0.0 version, run the following command.</p> <pre><code>sudo rpm -ivh nebula-graph-2.0.0.el7.x86_64.rpm\n</code></pre> </li> </ul> <ul> <li> <p>Use the following syntax to install with a DEB package.</p> <pre><code>$ sudo dpkg -i &lt;package_name&gt;\n</code></pre> <p>Note</p> <p>Customizing the installation path is not supported when installing NebulaGraph with a DEB package. The default installation path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install a DEB package for the 2.0.0 version, run the following command.</p> <pre><code>sudo dpkg -i nebula-graph-2.0.0.ubuntu1804.amd64.deb\n</code></pre> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula/</code>.</p> </li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#next_to_do","title":"Next to do","text":"<ul> <li>Start NebulaGraph </li> </ul> <ul> <li>Connect to NebulaGraph</li> </ul>"},{"location":"2.quick-start/3.1add-storage-hosts/","title":"Register the Storage Service","text":"<p>When connecting to NebulaGraph for the first time, you have to add the Storage hosts, and confirm that all the hosts are online.</p> <p>Compatibility</p> <ul> <li>Starting from NebulaGraph 3.0.0, you have to run <code>ADD HOSTS</code> before reading or writing data into the Storage Service.</li> <li>For NebulaGraph of versions earlier than 3.0.0 and NebulaGraph Cloud clusters, <code>ADD HOSTS</code> is not needed. </li> </ul>"},{"location":"2.quick-start/3.1add-storage-hosts/#prerequisites","title":"Prerequisites","text":"<p>You have connected to NebulaGraph.</p>"},{"location":"2.quick-start/3.1add-storage-hosts/#steps","title":"Steps","text":"<ol> <li> <p>Add the Storage hosts.</p> <p>Run the following command to add hosts:</p> <pre><code>ADD HOSTS &lt;ip&gt;:&lt;port&gt; [,&lt;ip&gt;:&lt;port&gt; ...];\n</code></pre> <p>Example\uff1a</p> <pre><code>nebula&gt; ADD HOSTS 192.168.10.100:9779, 192.168.10.101:9779, 192.168.10.102:9779;\n</code></pre> <p>Caution</p> <p>Make sure that the IP you added is the same as the IP configured for <code>local_ip</code> in the <code>nebula-storaged.conf</code> file. Otherwise, the Storage service will fail to start. For information about configurations, see Configurations.  </p> </li> <li> <p>Check the status of the hosts to make sure that they are all online.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n| Host             | Port | Status   | Leader count | Leader distribution  |   Partition distribution | Version |\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n| \"192.168.10.100\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"2.0.0\" |\n| \"192.168.10.101\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"2.0.0\"|\n| \"192.168.10.102\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"2.0.0\"|\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n</code></pre> <p>The <code>Status</code> column of the result above shows that all Storage hosts are online.</p> </li> </ol>"},{"location":"2.quick-start/3.connect-to-nebula-graph/","title":"Step 3: Connect to NebulaGraph","text":"<p>This topic provides basic instruction on how to use the native CLI client NebulaGraph Console to connect to NebulaGraph.</p> <p>Caution</p> <p>When connecting to NebulaGraph for the first time, you must register the Storage Service before querying data.</p> <p>NebulaGraph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. For more information, see the client list.</p>"},{"location":"2.quick-start/3.connect-to-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have started NebulaGraph services.</li> </ul> <ul> <li>The machine on which you plan to run NebulaGraph Console has network access to the Graph Service of NebulaGraph.</li> </ul> <ul> <li> <p>The NebulaGraph Console version is compatible with the NebulaGraph version.</p> <p>Note</p> <p>NebulaGraph Console and NebulaGraph of the same version number are the most compatible. There may be compatibility issues when connecting to NebulaGraph with a different version of NebulaGraph Console. The error message <code>incompatible version between client and server</code> is displayed when there is such an issue.</p> </li> </ul>"},{"location":"2.quick-start/3.connect-to-nebula-graph/#steps","title":"Steps","text":"<ol> <li> <p>On the NebulaGraph Console releases page, select a NebulaGraph Console version and click Assets.</p> <p>Note</p> <p>It is recommended to select the latest version.</p> </li> <li> <p>In the Assets area, find the correct binary file for the machine where you want to run NebulaGraph Console and download the file to the machine.</p> </li> <li> <p>(Optional) Rename the binary file to <code>nebula-console</code> for convenience.</p> <p>Note</p> <p>For Windows, rename the file to <code>nebula-console.exe</code>.</p> </li> <li> <p>On the machine to run NebulaGraph Console, grant the execute permission of the nebula-console binary file to the user.</p> <p>Note</p> <p>For Windows, skip this step.</p> <pre><code>$ chmod 111 nebula-console\n</code></pre> </li> <li> <p>In the command line interface, change the working directory to the one where the nebula-console binary file is stored.</p> </li> <li> <p>Run the following command to connect to NebulaGraph.</p> <ul> <li>For Linux or macOS:</li> </ul> <pre><code>$ ./nebula-console -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <ul> <li>For Windows:</li> </ul> <pre><code>&gt; nebula-console.exe -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP address of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the storage path of the certification authority file. <code>-ssl_cert_path</code> Sets the storage path of the certificate file. <code>-ssl_private_key_path</code> Sets the storage path of the private key file. <p>For information on more parameters, see the project repository.</p> </li> </ol>"},{"location":"2.quick-start/4.nebula-graph-crud/","title":"Step 4: Use nGQL (CRUD)","text":"<p>This topic will describe the basic CRUD operations in NebulaGraph.</p> <p>For more information, see nGQL guide.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#graph_space_and_nebulagraph_schema","title":"Graph space and NebulaGraph schema","text":"<p>A NebulaGraph instance consists of one or more graph spaces. Graph spaces are physically isolated from each other. You can use different graph spaces in the same instance to store different datasets.</p> <p></p> <p>To insert data into a graph space, define a schema for the graph database. NebulaGraph schema is based on the following components.</p> Schema component Description Vertex Represents an entity in the real world. A vertex can have zero to multiple tags. Tag The type of the same group of vertices. It defines a set of properties that describes the types of vertices. Edge Represents a directed relationship between two vertices. Edge type The type of an edge. It defines a group of properties that describes the types of edges. <p>For more information, see Data modeling.</p> <p>In this topic, we will use the following dataset to demonstrate basic CRUD operations.</p> <p></p>"},{"location":"2.quick-start/4.nebula-graph-crud/#async_implementation_of_create_and_alter","title":"Async implementation of <code>CREATE</code> and <code>ALTER</code>","text":"<p>Caution</p> <p>In NebulaGraph, the following <code>CREATE</code> or <code>ALTER</code> commands are implemented in an async way and take effect in the next heartbeat cycle. Otherwise, an error will be returned. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <ul> <li><code>CREATE SPACE</code></li> <li><code>CREATE TAG</code></li> <li><code>CREATE EDGE</code></li> <li><code>ALTER TAG</code></li> <li><code>ALTER EDGE</code></li> <li><code>CREATE TAG INDEX</code></li> <li><code>CREATE EDGE INDEX</code></li> </ul> <p>Note</p> <p>The default heartbeat interval is 10 seconds. To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#create_and_use_a_graph_space","title":"Create and use a graph space","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax","title":"nGQL syntax","text":"<ul> <li>Create a graph space:<pre><code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; (\n[partition_num = &lt;partition_number&gt;,]\n[replica_factor = &lt;replica_number&gt;,]\nvid_type = {FIXED_STRING(&lt;N&gt;) | INT64}\n)\n[COMMENT = '&lt;comment&gt;'];\n</code></pre> <p>For more information on parameters, see CREATE SPACE.</p> </li> </ul> <ul> <li>List graph spaces and check if the creation is successful:<pre><code>nebula&gt; SHOW SPACES;\n</code></pre> </li> </ul> <ul> <li>Use a graph space:<pre><code>USE &lt;graph_space_name&gt;;\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples","title":"Examples","text":"<ol> <li> <p>Use the following statement to create a graph space named <code>basketballplayer</code>.</p> <pre><code>nebula&gt; CREATE SPACE basketballplayer(partition_num=15, replica_factor=1, vid_type=fixed_string(30));\n</code></pre> <p>Note</p> <p>If the system returns the error <code>[ERROR (-1005)]: Host not enough!</code>, check whether registered the Storage Service.</p> </li> <li> <p>Check the partition distribution with <code>SHOW HOSTS</code> to make sure that the partitions are distributed in a balanced way.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+-------------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n| Host        | Port      | Status    | Leader count | Leader distribution              | Partition distribution | Version |\n+-------------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n| \"storaged0\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"2.0.0\"|\n| \"storaged1\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"2.0.0\"|\n| \"storaged2\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"2.0.0\"|\n+-------------+-----------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n</code></pre> <p>If the Leader distribution is uneven, use <code>BALANCE LEADER</code> to redistribute the partitions. For more information, see BALANCE.</p> </li> <li> <p>Use the <code>basketballplayer</code> graph space.</p> <pre><code>nebula[(none)]&gt; USE basketballplayer;\n</code></pre> <p>You can use <code>SHOW SPACES</code> to check the graph space you created.</p> <pre><code>nebula&gt; SHOW SPACES;\n+--------------------+\n| Name               |\n+--------------------+\n| \"basketballplayer\" |\n+--------------------+\n</code></pre> </li> </ol>"},{"location":"2.quick-start/4.nebula-graph-crud/#create_tags_and_edge_types","title":"Create tags and edge types","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_1","title":"nGQL syntax","text":"<pre><code>CREATE {TAG | EDGE} [IF NOT EXISTS] {&lt;tag_name&gt; | &lt;edge_type_name&gt;}\n    (\n      &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']\n      [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] \n    )\n    [TTL_DURATION = &lt;ttl_duration&gt;]\n    [TTL_COL = &lt;prop_name&gt;]\n    [COMMENT = '&lt;comment&gt;'];\n</code></pre> <p>For more information on parameters, see CREATE TAG and CREATE EDGE.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_1","title":"Examples","text":"<p>Create tags <code>player</code> and <code>team</code>, and edge types <code>follow</code> and <code>serve</code>. Descriptions are as follows.</p> Component name Type Property player Tag name (string), age (int) team Tag name (string) follow Edge type degree (int) serve Edge type start_year (int), end_year (int) <pre><code>nebula&gt; CREATE TAG player(name string, age int);\n\nnebula&gt; CREATE TAG team(name string);\n\nnebula&gt; CREATE EDGE follow(degree int);\n\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre>"},{"location":"2.quick-start/4.nebula-graph-crud/#insert_vertices_and_edges","title":"Insert vertices and edges","text":"<p>You can use the <code>INSERT</code> statement to insert vertices or edges based on existing tags or edge types.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_2","title":"nGQL syntax","text":"<ul> <li>Insert vertices:<pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES &lt;vid&gt;: ([prop_value_list])\n\ntag_props:\n  tag_name ([prop_name_list])\n\nprop_name_list:\n   [prop_name [, prop_name] ...]\n\nprop_value_list:\n   [prop_value [, prop_value] ...]   \n</code></pre> <p><code>vid</code> is short for Vertex ID. A <code>vid</code> must be a unique string value in a graph space. For details, see INSERT VERTEX.</p> </li> </ul> <ul> <li> <p>Insert edges:</p> <pre><code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES \n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; )\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...];\n&lt;prop_name_list&gt; ::=\n[ &lt;prop_name&gt; [, &lt;prop_name&gt; ] ...]\n&lt;prop_value_list&gt; ::=\n[ &lt;prop_value&gt; [, &lt;prop_value&gt; ] ...]\n</code></pre> <p>For more information on parameters, see INSERT EDGE.</p> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_2","title":"Examples","text":"<ul> <li>Insert vertices representing basketball players and teams:<pre><code>nebula&gt; INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\n\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36);\n\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\n\nnebula&gt; INSERT VERTEX team(name) VALUES \"team203\":(\"Trail Blazers\"), \"team204\":(\"Spurs\");\n</code></pre> </li> </ul> <ul> <li>Insert edges representing the relations between basketball players and teams:<pre><code>nebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player100\":(95);\n\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player102\":(90);\n\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player102\" -&gt; \"player100\":(75);\n\nnebula&gt; INSERT EDGE serve(start_year, end_year) VALUES \"player101\" -&gt; \"team204\":(1999, 2018),\"player102\" -&gt; \"team203\":(2006,  2015);\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#read_data","title":"Read data","text":"<ul> <li>The GO statement can traverse the database based on specific conditions. A <code>GO</code> traversal starts from one or more vertices, along one or more edges, and returns information in a form specified in the <code>YIELD</code> clause.</li> </ul> <ul> <li>The FETCH statement is used to get properties from vertices or edges.</li> </ul> <ul> <li>The LOOKUP statement is based on indexes. It is used together with the <code>WHERE</code> clause to search for the data that meet the specific conditions.</li> </ul> <ul> <li>The MATCH statement is the most commonly used statement for graph data querying. It can describe all kinds of graph patterns, but it relies on indexes to match data patterns in NebulaGraph. Therefore, its performance still needs optimization.</li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_3","title":"nGQL syntax","text":"<ul> <li><code>GO</code><pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS} ] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt; ]\nYIELD [DISTINCT] &lt;return_list&gt;\n[{ SAMPLE &lt;sample_list&gt; | &lt;limit_by_list_clause&gt; }]\n[| GROUP BY {&lt;col_name&gt; | expression&gt; | &lt;position&gt;} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;];\n</code></pre> </li> </ul> <ul> <li> <p><code>FETCH</code></p> <ul> <li> <p>Fetch properties on tags:</p> <pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *}\n&lt;vid&gt; [, vid ...]\nYIELD &lt;return_list&gt; [AS &lt;alias&gt;];\n</code></pre> </li> </ul> <ul> <li> <p>Fetch properties on edges:</p> <pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> </li> </ul> </li> </ul> <ul> <li><code>LOOKUP</code><pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;}\n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]]\nYIELD &lt;return_list&gt; [AS &lt;alias&gt;];\n&lt;return_list&gt;\n    &lt;prop_name&gt; [AS &lt;col_alias&gt;] [, &lt;prop_name&gt; [AS &lt;prop_alias&gt;] ...];\n</code></pre> </li> </ul> <ul> <li><code>MATCH</code><pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_of_go_statement","title":"Examples of <code>GO</code> statement","text":"<ul> <li>Search for the players that the player with VID <code>player101</code> follows.<pre><code>nebula&gt; GO FROM \"player101\" OVER follow YIELD id($$);\n+-------------+\n| id($$)      |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n+-------------+\n</code></pre> </li> </ul> <ul> <li>Filter the players that the player with VID <code>player101</code> follows whose age is equal to or greater than 35. Rename the corresponding columns in the results with <code>Teammate</code> and <code>Age</code>.<pre><code>nebula&gt; GO FROM \"player101\" OVER follow WHERE properties($$).age &gt;= 35 \\\n        YIELD properties($$).name AS Teammate, properties($$).age AS Age;\n+-----------------+-----+\n| Teammate        | Age |\n+-----------------+-----+\n| \"Tim Duncan\"    | 42  |\n| \"Manu Ginobili\" | 41  |\n+-----------------+-----+\n</code></pre> <p>| Clause/Sign | Description                                                         |   |-------------+---------------------------------------------------------------------|   | <code>YIELD</code>     | Specifies what values or results you want to return from the query. |   | <code>$$</code>        | Represents the target vertices.                                     |   | <code>\\</code>         | A line-breaker.                                                     |</p> </li> </ul> <ul> <li> <p>Search for the players that the player with VID <code>player101</code> follows. Then retrieve the teams of the players that the player with VID <code>player100</code> follows. To combine the two queries, use a pipe or a temporary variable.</p> <ul> <li> <p>With a pipe:</p> <pre><code>nebula&gt; GO FROM \"player101\" OVER follow YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------------+---------------------+\n| Team            | Player              |\n+-----------------+---------------------+\n| \"Spurs\"         | \"Tim Duncan\"        |\n| \"Trail Blazers\" | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"Manu Ginobili\"     |\n+-----------------+---------------------+\n</code></pre> Clause/Sign Description <code>$^</code> Represents the source vertex of the edge. <code>|</code> A pipe symbol can combine multiple queries. <code>$-</code> Represents the outputs of the query before the pipe symbol. </li> </ul> <ul> <li> <p>With a temporary variable:</p> <p>Note</p> <p>Once a composite statement is submitted to the server as a whole, the life cycle of the temporary variables in the statement ends.</p> <pre><code>nebula&gt; $var = GO FROM \"player101\" OVER follow YIELD dst(edge) AS id; \\\n        GO FROM $var.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------------+---------------------+\n| Team            | Player              |\n+-----------------+---------------------+\n| \"Spurs\"         | \"Tim Duncan\"        |\n| \"Trail Blazers\" | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"Manu Ginobili\"     |\n+-----------------+---------------------+\n</code></pre> </li> </ul> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#example_of_fetch_statement","title":"Example of <code>FETCH</code> statement","text":"<p>Use <code>FETCH</code>: Fetch the properties of the player with VID <code>player100</code>.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+-------------------------------+\n| properties(VERTEX)            |\n+-------------------------------+\n| {age: 42, name: \"Tim Duncan\"} |\n+-------------------------------+\n</code></pre> <p>Note</p> <p>The examples of <code>LOOKUP</code> and <code>MATCH</code> statements are in indexes.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#update_vertices_and_edges","title":"Update vertices and edges","text":"<p>Users can use the <code>UPDATE</code> or the <code>UPSERT</code> statements to update existing data.</p> <p><code>UPSERT</code> is the combination of <code>UPDATE</code> and <code>INSERT</code>. If you update a vertex or an edge with <code>UPSERT</code>, the database will insert a new vertex or edge if it does not exist.</p> <p>Note</p> <p><code>UPSERT</code> operates serially in a partition-based order. Therefore, it is slower than <code>INSERT</code> OR <code>UPDATE</code>. And <code>UPSERT</code> has concurrency only between multiple partitions.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_4","title":"nGQL syntax","text":"<ul> <li><code>UPDATE</code> vertices:<pre><code>UPDATE VERTEX &lt;vid&gt; SET &lt;properties to be updated&gt;\n[WHEN &lt;condition&gt;] [YIELD &lt;columns&gt;];\n</code></pre> </li> </ul> <ul> <li><code>UPDATE</code> edges:<pre><code>UPDATE EDGE ON &lt;edge_type&gt; &lt;source vid&gt; -&gt; &lt;destination vid&gt; [@rank] \nSET &lt;properties to be updated&gt; [WHEN &lt;condition&gt;] [YIELD &lt;columns to be output&gt;];\n</code></pre> </li> </ul> <ul> <li><code>UPSERT</code> vertices or edges:<pre><code>UPSERT {VERTEX &lt;vid&gt; | EDGE &lt;edge_type&gt;} SET &lt;update_columns&gt;\n[WHEN &lt;condition&gt;] [YIELD &lt;columns&gt;];\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_3","title":"Examples","text":"<ul> <li><code>UPDATE</code> the <code>name</code> property of the vertex with VID <code>player100</code> and check the result with the <code>FETCH</code> statement.<pre><code>nebula&gt; UPDATE VERTEX \"player100\" SET player.name = \"Tim\";\n\nnebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+------------------------+\n| properties(VERTEX)     |\n+------------------------+\n| {age: 42, name: \"Tim\"} |\n+------------------------+\n</code></pre> </li> </ul> <ul> <li><code>UPDATE</code> the <code>degree</code> property of an edge and check the result with the <code>FETCH</code> statement.<pre><code>nebula&gt; UPDATE EDGE ON follow \"player101\" -&gt; \"player100\" SET degree = 96;\n\nnebula&gt; FETCH PROP ON follow \"player101\" -&gt; \"player100\" YIELD properties(edge);\n+------------------+\n| properties(EDGE) |\n+------------------+\n| {degree: 96}     |\n+------------------+\n</code></pre> </li> </ul> <ul> <li>Insert a vertex with VID <code>player111</code> and <code>UPSERT</code> it.<pre><code>nebula&gt; INSERT VERTEX player(name,age) VALUES \"player111\":(\"David West\", 38);\n\nnebula&gt; UPSERT VERTEX \"player111\" SET player.name = \"David\", player.age = $^.player.age + 11 \\\n        WHEN $^.player.name == \"David West\" AND $^.player.age &gt; 20 \\\n        YIELD $^.player.name AS Name, $^.player.age AS Age;\n+---------+-----+\n| Name    | Age |\n+---------+-----+\n| \"David\" | 49  |\n+---------+-----+\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#delete_vertices_and_edges","title":"Delete vertices and edges","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_5","title":"nGQL syntax","text":"<ul> <li>Delete vertices:<pre><code>DELETE VERTEX &lt;vid1&gt;[, &lt;vid2&gt;...]\n</code></pre> </li> </ul> <ul> <li>Delete edges:<pre><code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;...]\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_4","title":"Examples","text":"<ul> <li>Delete vertices:<pre><code>nebula&gt; DELETE VERTEX \"player111\", \"team203\";\n</code></pre> </li> </ul> <ul> <li>Delete edges:<pre><code>nebula&gt; DELETE EDGE follow \"player101\" -&gt; \"team204\";\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#about_indexes","title":"About indexes","text":"<p>Users can add indexes to tags and edge types with the CREATE INDEX statement.</p> <p>Must-read for using indexes</p> <p>Both <code>MATCH</code> and <code>LOOKUP</code> statements depend on the indexes. But indexes can dramatically reduce the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.</p> <p>Users MUST rebuild indexes for pre-existing data. Otherwise, the pre-existing data cannot be indexed and therefore cannot be returned in <code>MATCH</code> or <code>LOOKUP</code> statements. For more information, see REBUILD INDEX.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_6","title":"nGQL syntax","text":"<ul> <li>Create an index:<pre><code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt;\nON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT = '&lt;comment&gt;'];\n</code></pre> </li> </ul> <ul> <li>Rebuild an index:<pre><code>REBUILD {TAG | EDGE} INDEX &lt;index_name&gt;;\n</code></pre> </li> </ul> <p>Note</p> <p>Define the index length when creating an index for a variable-length property. In UTF-8 encoding, a non-ascii character occupies 3 bytes. You should set an appropriate index length according to the variable-length property. For example, the index should be 30 bytes for 10 non-ascii characters. For more information, see CREATE INDEX</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_of_lookup_and_match_index-based","title":"Examples of <code>LOOKUP</code> and <code>MATCH</code> (index-based)","text":"<p>Make sure there is an index for <code>LOOKUP</code> or <code>MATCH</code> to use. If there is not, create an index first.</p> <p>Find the information of the vertex with the tag <code>player</code> and its value of the <code>name</code> property is <code>Tony Parker</code>.</p> <p>This example creates the index <code>player_index_1</code> on the <code>name</code> property.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index_1 ON player(name(20));\n</code></pre> <p>This example rebuilds the index to make sure it takes effect on pre-existing data.</p> <pre><code>nebula&gt; REBUILD TAG INDEX player_index_1\n+------------+\n| New Job Id |\n+------------+\n| 31         |\n+------------+\n</code></pre> <p>This example uses the <code>LOOKUP</code> statement to retrieve the vertex property.</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name AS name, properties(vertex).age AS age;\n+---------------+-----+\n| name          | age |\n+---------------+-----+\n| \"Tony Parker\" | 36  |\n+---------------+-----+\n</code></pre> <p>This example uses the <code>MATCH</code> statement to retrieve the vertex property.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tony Parker\"}) RETURN v;\n+-----------------------------------------------------+\n| v                                                   |\n+-----------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"}) |\n+-----------------------------------------------------+\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/","title":"Step 2: Manage NebulaGraph Service","text":"<p>NebulaGraph supports managing services with scripts. </p>"},{"location":"2.quick-start/5.start-stop-service/#manage_services_with_script","title":"Manage services with script","text":"<p>You can use the <code>nebula.service</code> script to start, stop, restart, terminate, and check the NebulaGraph services.</p> <p>Note</p> <p><code>nebula.service</code> is stored in the <code>/usr/local/nebula/scripts</code> directory by default. If you have customized the path, use the actual path in your environment.</p>"},{"location":"2.quick-start/5.start-stop-service/#syntax","title":"Syntax","text":"<pre><code>$ sudo /usr/local/nebula/scripts/nebula.service\n[-v] [-c &lt;config_file_path&gt;]\n&lt;start | stop | restart | kill | status&gt;\n&lt;metad | graphd | storaged | all&gt;\n</code></pre> Parameter Description <code>-v</code> Display detailed debugging information. <code>-c</code> Specify the configuration file path. The default path is <code>/usr/local/nebula/etc/</code>. <code>start</code> Start the target services. <code>stop</code> Stop the target services. <code>restart</code> Restart the target services. <code>kill</code> Terminate the target services. <code>status</code> Check the status of the target services. <code>metad</code> Set the Meta Service as the target service. <code>graphd</code> Set the Graph Service as the target service. <code>storaged</code> Set the Storage Service as the target service. <code>all</code> Set all the NebulaGraph services as the target services."},{"location":"2.quick-start/5.start-stop-service/#start_nebulagraph","title":"Start NebulaGraph","text":"<p>Run the following command to start NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service start all\n[INFO] Starting nebula-metad...\n[INFO] Done\n[INFO] Starting nebula-graphd...\n[INFO] Done\n[INFO] Starting nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/#stop_nebulagraph","title":"Stop NebulaGraph","text":"<p>Danger</p> <p>Do not run <code>kill -9</code> to forcibly terminate the processes. Otherwise, there is a low probability of data loss.</p> <p>Run the following command to stop NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service stop all\n[INFO] Stopping nebula-metad...\n[INFO] Done\n[INFO] Stopping nebula-graphd...\n[INFO] Done\n[INFO] Stopping nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/#check_the_service_status","title":"Check the service status","text":"<p>Run the following command to check the service status of NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service status all\n</code></pre> <ul> <li> <p>NebulaGraph is running normally if the following information is returned.</p> <pre><code>INFO] nebula-metad(33fd35e): Running as 29020, Listening on 9559\n[INFO] nebula-graphd(33fd35e): Running as 29095, Listening on 9669\n[WARN] nebula-storaged after v3.0.0 will not start service until it is added to cluster.\n[WARN] See Manage Storage hosts:ADD HOSTS in https://docs.nebula-graph.io/\n[INFO] nebula-storaged(33fd35e): Running as 29147, Listening on 9779\n</code></pre> <p>Note</p> <p>After starting NebulaGraph, the port of the <code>nebula-storaged</code> process is shown in red. Because the <code>nebula-storaged</code> process waits for the <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p> </li> </ul> <ul> <li>If the returned result is similar to the following one, there is a problem. You may also go to the NebulaGraph community for help.<pre><code>[INFO] nebula-metad: Running as 25600, Listening on 9559\n[INFO] nebula-graphd: Exited\n[INFO] nebula-storaged: Running as 25646, Listening on 9779\n</code></pre> </li> </ul> <p>The NebulaGraph services consist of the Meta Service, Graph Service, and Storage Service. The configuration files for all three services are stored in the <code>/usr/local/nebula/etc/</code> directory by default. You can check the configuration files according to the returned result to troubleshoot problems.</p>"},{"location":"2.quick-start/5.start-stop-service/#next_to_do","title":"Next to do","text":"<p>Connect to NebulaGraph</p>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/","title":"nGQL cheatsheet","text":""},{"location":"2.quick-start/6.cheatsheet-for-ngql/#functions","title":"Functions","text":"<ul> <li> <p>Math functions</p> Function Description double abs(double x) Returns the absolute value of the argument. double floor(double x) Returns the largest integer value smaller than or equal to the argument. (Rounds down) double ceil(double x) Returns the smallest integer greater than or equal to the argument. (Rounds up) double round(double x) Returns the integer value nearest to the argument. Returns a number farther away from 0 if the argument is in the middle. double sqrt(double x) Returns the square root of the argument. double cbrt(double x) Returns the cubic root of the argument. double hypot(double x, double y) Returns the hypotenuse of a right-angled triangle. double pow(double x, double y) Returns the result of x^y^. double exp(double x) Returns the result of e^x^. double exp2(double x) Returns the result of 2^x^. double log(double x) Returns the base-e logarithm of the argument. double log2(double x) Returns the base-2 logarithm of the argument. double log10(double x) Returns the base-10 logarithm of the argument. double sin(double x) Returns the sine of the argument. double asin(double x) Returns the inverse sine of the argument. double cos(double x) Returns the cosine of the argument. double acos(double x) Returns the inverse cosine of the argument. double tan(double x) Returns the tangent of the argument. double atan(double x) Returns the inverse tangent of the argument. double rand() Returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e.[0,1). int rand32(int min, int max) Returns a random 32-bit integer in <code>[min, max)</code>.If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default.If you set no argument, the system returns a random signed 32-bit integer. int rand64(int min, int max) Returns a random 64-bit integer in <code>[min, max)</code>.If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default.If you set no argument, the system returns a random signed 64-bit integer. bit_and() Bitwise AND. bit_or() Bitwise OR. bit_xor() Bitwise XOR. int size() Returns the number of elements in a list or a map or the length of a string. int range(int start, int end, int step) Returns a list of integers from <code>[start,end]</code> in the specified steps. <code>step</code> is 1 by default. int sign(double x) Returns the signum of the given number.If the number is <code>0</code>, the system returns <code>0</code>.If the number is negative, the system returns <code>-1</code>.If the number is positive, the system returns <code>1</code>. double e() Returns the base of the natural logarithm, e (2.718281828459045). double pi() Returns the mathematical constant pi (3.141592653589793). double radians() Converts degrees to radians. <code>radians(180)</code> returns <code>3.141592653589793</code>. </li> </ul> <ul> <li> <p>Aggregating functions</p> Function Description avg() Returns the average value of the argument. count() Syntax: <code>count({expr | *})</code> .<code>count()</code>returns the number of rows (including NULL). <code>count(expr)</code>returns the number of non-NULL values that meet the expression. count() and size() are different. max() Returns the maximum value. min() Returns the minimum value. collect() The collect() function returns a list containing the values returned by an expression. Using this function aggregates data by merging multiple records or values into a single list. std() Returns the population standard deviation. sum() Returns the sum value. </li> </ul> <ul> <li> <p>String functions</p> Function Description int strcasecmp(string a, string b) Compares string a and b without case sensitivity. When a = b, the return string lower(string a) Returns the argument in lowercase. string toLower(string a) The same as <code>lower()</code>. string upper(string a) Returns the argument in uppercase. string toUpper(string a) The same as <code>upper()</code>. int length(a) Returns the length of the given string in bytes or the length of a path in hops. string trim(string a) Removes leading and trailing spaces. string ltrim(string a) Removes leading spaces. string rtrim(string a) Removes trailing spaces. string left(string a, int count) Returns a substring consisting of <code>count</code> characters from the left side of string right(string a, int count) Returns a substring consisting of <code>count</code> characters from the right side of string lpad(string a, int size, string letters) Left-pads string a with string <code>letters</code> and returns a string rpad(string a, int size, string letters) Right-pads string a with string <code>letters</code> and returns a string substr(string a, int pos, int count) Returns a substring extracting <code>count</code> characters starting from string substring(string a, int pos, int count) The same as <code>substr()</code>. string reverse(string) Returns a string in reverse order. string replace(string a, string b, string c) Replaces string b in string a with string c. list split(string a, string b) Splits string a at string b and returns a list of strings. concat() The <code>concat()</code> function requires at least two or more strings. All the parameters are concatenated into one string.Syntax: <code>concat(string1,string2,...)</code> concat_ws() The <code>concat_ws()</code> function connects two or more strings with a predefined separator. extract() <code>extract()</code> uses regular expression matching to retrieve a single substring or all substrings from a string. json_extract() The <code>json_extract()</code> function converts the specified JSON string to map. </li> </ul> <ul> <li> <p>Data and time functions</p> Function Description int now() Returns the current timestamp of the system. timestamp timestamp() Returns the current timestamp of the system. date date() Returns the current UTC date based on the current system. time time() Returns the current UTC time based on the current system. datetime datetime() Returns the current UTC date and time based on the current system. </li> </ul> <ul> <li> <p>Schema-related functions</p> <ul> <li> <p>For nGQL statements</p> Function Description id(vertex) Returns the ID of a vertex. The data type of the result is the same as the vertex ID. map properties(vertex) Returns the properties of a vertex. map properties(edge) Returns the properties of an edge. string type(edge) Returns the edge type of an edge. src(edge) Returns the source vertex ID of an edge. The data type of the result is the same as the vertex ID. dst(edge) Returns the destination vertex ID of an edge. The data type of the result is the same as the vertex ID. int rank(edge) Returns the rank value of an edge. vertex Returns the information of vertices, including VIDs, tags, properties, and values. edge Returns the information of edges, including edge types, source vertices, destination vertices, ranks, properties, and values. vertices Returns the information of vertices in a subgraph. For more information, see GET SUBGRAPH. edges Returns the information of edges in a subgraph. For more information, see GET SUBGRAPH. path Returns the information of a path. For more information, see FIND PATH. </li> </ul> <ul> <li> <p>For statements compatible with openCypher</p> Function Description id(&lt;vertex&gt;) Returns the ID of a vertex. The data type of the result is the same as the vertex ID. list tags(&lt;vertex&gt;) Returns the Tag of a vertex, which serves the same purpose as labels(). list labels(&lt;vertex&gt;) Returns the Tag of a vertex, which serves the same purpose as tags(). This function is used for compatibility with openCypher syntax. map properties(&lt;vertex_or_edge&gt;) Returns the properties of a vertex or an edge. string type(&lt;edge&gt;) Returns the edge type of an edge. src(&lt;edge&gt;) Returns the source vertex ID of an edge. The data type of the result is the same as the vertex ID. dst(&lt;edge&gt;) Returns the destination vertex ID of an edge. The data type of the result is the same as the vertex ID. vertex startNode(&lt;path&gt;) Visits an edge or a path and returns its source vertex ID. string endNode(&lt;path&gt;) Visits an edge or a path and returns its destination vertex ID. int rank(&lt;edge&gt;) Returns the rank value of an edge. </li> </ul> </li> </ul> <ul> <li> <p>List functions</p> Function Description keys(expr) Returns a list containing the string representations for all the property names of vertices, edges, or maps. labels(vertex) Returns the list containing all the tags of a vertex. nodes(path) Returns the list containing all the vertices in a path. range(start, end [, step]) Returns the list containing all the fixed-length steps in <code>[start,end]</code>. <code>step</code> is 1 by default. relationships(path) Returns the list containing all the relationships in a path. reverse(list) Returns the list reversing the order of all elements in the original list. tail(list) Returns all the elements of the original list, excluding the first one. head(list) Returns the first element of a list. last(list) Returns the last element of a list. reduce() The <code>reduce()</code> function applies an expression to each element in a list one by one, chains the result to the next iteration by taking it as the initial value, and returns the final result. </li> </ul> <ul> <li> <p>Type conversion functions</p> Function Description bool toBoolean() Converts a string value to a boolean value. float toFloat() Converts an integer or string value to a floating point number. string toString() Converts non-compound types of data, such as numbers, booleans, and so on, to strings. int toInteger() Converts a floating point or string value to an integer value. set toSet() Converts a list or set value to a set value. int hash() The <code>hash()</code> function returns the hash value of the argument. The argument can be a number, a string, a list, a boolean, null, or an expression that evaluates to a value of the preceding data types. </li> </ul> <ul> <li> <p>Predicate functions</p> <p>Predicate functions return <code>true</code> or <code>false</code>. They are most commonly used in <code>WHERE</code> clauses.</p> <pre><code>&lt;predicate&gt;(&lt;variable&gt; IN &lt;list&gt; WHERE &lt;condition&gt;)\n</code></pre> Function Description exists() Returns <code>true</code> if the specified property exists in the vertex, edge or map. Otherwise, returns <code>false</code>. any() Returns <code>true</code> if the specified predicate holds for at least one element in the given list. Otherwise, returns <code>false</code>. all() Returns <code>true</code> if the specified predicate holds for all elements in the given list. Otherwise, returns <code>false</code>. none() Returns <code>true</code> if the specified predicate holds for no element in the given list. Otherwise, returns <code>false</code>. single() Returns <code>true</code> if the specified predicate holds for exactly one of the elements in the given list. Otherwise, returns <code>false</code>. </li> </ul> <ul> <li> <p>Conditional expressions functions</p> Function Description CASE The <code>CASE</code> expression uses conditions to filter the result of an nGQL query statement. It is usually used in the <code>YIELD</code> and <code>RETURN</code> clauses. The <code>CASE</code> expression will traverse all the conditions. When the first condition is met, the <code>CASE</code> expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the <code>ELSE</code> clause. If there is no <code>ELSE</code> clause and no conditions are met, it returns <code>NULL</code>. coalesce() Returns the first not null value in all expressions. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#general_queries_statements","title":"General queries statements","text":"<ul> <li> <p>MATCH</p> <pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> Pattern Example Description Match vertices <code>(v)</code> You can use a user-defined variable in a pair of parentheses to represent a vertex in a pattern. For example: <code>(v)</code>. Match tags <code>MATCH (v:player) RETURN v</code> You can specify a tag with <code>:&lt;tag_name&gt;</code> after the vertex in a pattern. Match multiple tags <code>MATCH (v:player:team) RETURN v</code> To match vertices with multiple tags, use colons (:). Match vertex properties <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v</code> <code>MATCH (v) WITH v, properties(v) as props, keys(properties(v)) as kk WHERE [i in kk where props[i] == \"Tim Duncan\"] RETURN v</code> You can specify a vertex property with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> after the tag in a pattern; or use a vertex property value to get vertices directly. Match a VID. <code>MATCH (v) WHERE id(v) == 'player101' RETURN v</code> You can use the VID to match a vertex. The <code>id()</code> function can retrieve the VID of a vertex. Match multiple VIDs. <code>MATCH (v:player { name: 'Tim Duncan' })--(v2) WHERE id(v2) IN [\"player101\", \"player102\"] RETURN v2</code> To match multiple VIDs, use <code>WHERE id(v) IN [vid_list]</code>. Match connected vertices <code>MATCH (v:player{name:\"Tim Duncan\"})--(v2) RETURN v2.player.name AS Name</code> You can use the <code>--</code> symbol to represent edges of both directions and match vertices connected by these edges. You can add a <code>&gt;</code> or <code>&lt;</code> to the <code>--</code> symbol to specify the direction of an edge. Match paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) RETURN p</code> Connected vertices and edges form a path. You can use a user-defined variable to name a path as follows. Match edges <code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-(v2) RETURN e</code><code>MATCH ()&lt;-[e]-() RETURN e</code> Besides using <code>--</code>, <code>--&gt;</code>, or <code>&lt;--</code> to indicate a nameless edge, you can use a user-defined variable in a pair of square brackets to represent a named edge. For example: <code>-[e]-</code>. Match an edge type <code>MATCH ()-[e:follow]-() RETURN e</code> Just like vertices, you can specify an edge type with <code>:&lt;edge_type&gt;</code> in a pattern. For example: <code>-[e:follow]-</code>. Match edge type properties <code>MATCH (v:player{name:\"Tim Duncan\"})-[e:follow{degree:95}]-&gt;(v2) RETURN e</code> <code>MATCH ()-[e]-&gt;() WITH e, properties(e) as props, keys(properties(e)) as kk WHERE [i in kk where props[i] == 90] RETURN e</code> You can specify edge type properties with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> in a pattern. For example: <code>[e:follow{likeness:95}]</code>; or use an edge type property value to get edges directly. Match multiple edge types <code>MATCH (v:player{name:\"Tim Duncan\"})-[e:follow | :serve]-&gt;(v2) RETURN e</code> The <code>|</code> symbol can help matching multiple edge types. For example: <code>[e:follow|:serve]</code>. The English colon (:) before the first edge type cannot be omitted, but the English colon before the subsequent edge type can be omitted, such as <code>[e:follow|serve]</code>. Match multiple edges <code>MATCH (v:player{name:\"Tim Duncan\"})-[]-&gt;(v2)&lt;-[e:serve]-(v3) RETURN v2, v3</code> You can extend a pattern to match multiple edges in a path. Match fixed-length paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) RETURN DISTINCT v2 AS Friends</code> You can use the <code>:&lt;edge_type&gt;*&lt;hop&gt;</code> pattern to match a fixed-length path. <code>hop</code> must be a non-negative integer. The data type of <code>e</code> is the list. Match variable-length paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]-&gt;(v2) RETURN v2 AS Friends</code> <code>minHop</code>: Optional. It represents the minimum length of the path. <code>minHop</code>: must be a non-negative integer. The default value is 1.<code>minHop</code> and <code>maxHop</code> are optional and the default value is 1 and infinity respectively. The data type of <code>e</code> is the list. Match variable-length paths with multiple edge types <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow | serve*2]-&gt;(v2) RETURN DISTINCT v2</code> You can specify multiple edge types in a fixed-length or variable-length pattern. In this case, <code>hop</code>, <code>minHop</code>, and <code>maxHop</code> take effect on all edge types. The data type of <code>e</code> is the list. Retrieve vertex or edge information <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v</code><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) RETURN e</code> Use <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}</code> to retrieve all the information of a vertex or an edge. Retrieve VIDs <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN id(v)</code> Use the <code>id()</code> function to retrieve VIDs. Retrieve tags <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN labels(v)</code> Use the <code>labels()</code> function to retrieve the list of tags on a vertex.To retrieve the nth element in the <code>labels(v)</code> list, use <code>labels(v)[n-1]</code>. Retrieve a single property on a vertex or an edge <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v.player.age</code> Use <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}.&lt;property&gt;</code> to retrieve a single property.Use <code>AS</code> to specify an alias for a property. Retrieve all properties on a vertex or an edge <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN properties(v2)</code> Use the <code>properties()</code> function to retrieve all properties on a vertex or an edge. Retrieve edge types <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e]-&gt;() RETURN DISTINCT type(e)</code> Use the <code>type()</code> function to retrieve the matched edge types. Retrieve paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[*3]-&gt;() RETURN p</code> Use <code>RETURN &lt;path_name&gt;</code> to retrieve all the information of the matched paths. Retrieve vertices in a path <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN nodes(p)</code> Use the <code>nodes()</code> function to retrieve all vertices in a path. Retrieve edges in a path <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN relationships(p)</code> Use the <code>relationships()</code> function to retrieve all edges in a path. Retrieve path length <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[*..2]-&gt;(v2) RETURN p AS Paths, length(p) AS Length</code> Use the <code>length()</code> function to retrieve the length of a path. </li> </ul> <ul> <li> <p>OPTIONAL MATCH</p> Pattern Example Description Matches patterns against your graph database, just like <code>MATCH</code> does. <code>MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" OPTIONAL MATCH (n)-[]-&gt;(l) RETURN id(m),id(n),id(l)</code> If no matches are found, <code>OPTIONAL MATCH</code> will use a null for missing parts of the pattern. </li> </ul> <ul> <li> <p>LOOKUP</p> <pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;} \n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]] \nYIELD &lt;return_list&gt; [AS &lt;alias&gt;]\n</code></pre> Pattern Example Description Retrieve vertices <code>LOOKUP ON player WHERE player.name == \"Tony Parker\" YIELD player.name AS name, player.age AS age</code> The following example returns vertices whose <code>name</code> is <code>Tony Parker</code> and the tag is <code>player</code>. Retrieve edges <code>LOOKUP ON follow WHERE follow.degree == 90 YIELD follow.degree</code> Returns edges whose <code>degree</code> is <code>90</code> and the edge type is <code>follow</code>. List vertices with a tag <code>LOOKUP ON player YIELD properties(vertex),id(vertex)</code> Shows how to retrieve the VID of all vertices tagged with <code>player</code>. List edges with an edge types <code>LOOKUP ON follow YIELD edge AS e</code> Shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the <code>follow</code> edge type. Count the numbers of vertices or edges <code>LOOKUP ON player YIELD id(vertex)| YIELD COUNT(*) AS Player_Count</code> Shows how to count the number of vertices tagged with <code>player</code>. Count the numbers of edges <code>LOOKUP ON follow YIELD edge as e| YIELD COUNT(*) AS Like_Count</code> Shows how to count the number of edges of the <code>follow</code> edge type. </li> </ul> <ul> <li> <p>GO</p> <pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS} ] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt; ]\nYIELD [DISTINCT] &lt;return_list&gt;\n[{SAMPLE &lt;sample_list&gt; | LIMIT &lt;limit_list&gt;}]\n[| GROUP BY {col_name | expr | position} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset_value&gt;,] &lt;number_rows&gt;]\n</code></pre> Example Description <code>GO FROM \"player102\" OVER serve YIELD dst(edge)</code> Returns the teams that player 102 serves. <code>GO 2 STEPS FROM \"player102\" OVER follow YIELD dst(edge)</code> Returns the friends of player 102 with 2 hops. <code>GO FROM \"player100\", \"player102\" OVER serve WHERE properties(edge).start_year &gt; 1995 YIELD DISTINCT properties($$).name AS team_name, properties(edge).start_year AS start_year, properties($^).name AS player_name</code> Adds a filter for the traversal. <code>GO FROM \"player100\" OVER follow, serve YIELD properties(edge).degree, properties(edge).start_year</code> The following example traverses along with multiple edge types. If there is no value for a property, the output is <code>NULL</code>. <code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS destination</code> The following example returns the neighbor vertices in the incoming direction of player 100. <code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id | GO FROM $-.id OVER serve WHERE properties($^).age &gt; 20 YIELD properties($^).name AS FriendOf, properties($$).name AS Team</code> The following example retrieves the friends of player 100 and the teams that they serve. <code>GO FROM \"player102\" OVER follow YIELD dst(edge) AS both</code> The following example returns all the neighbor vertices of player 102. <code>GO 2 STEPS FROM \"player100\" OVER follow YIELD src(edge) AS src, dst(edge) AS dst, properties($$).age AS age | GROUP BY $-.dst YIELD $-.dst AS dst, collect_set($-.src) AS src, collect($-.age) AS age</code> The following example the outputs according to age. </li> </ul> <ul> <li> <p>FETCH</p> <ul> <li> <p>Fetch vertex properties</p> <pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *} \n&lt;vid&gt; [, vid ...] \nYIELD &lt;return_list&gt; [AS &lt;alias&gt;]\n</code></pre> Example Description <code>FETCH PROP ON player \"player100\" YIELD properties(vertex)</code> Specify a tag in the <code>FETCH</code> statement to fetch the vertex properties by that tag. <code>FETCH PROP ON player \"player100\" YIELD player.name AS name</code> Use a <code>YIELD</code> clause to specify the properties to be returned. <code>FETCH PROP ON player \"player101\", \"player102\", \"player103\" YIELD properties(vertex)</code> Specify multiple VIDs (vertex IDs) to fetch properties of multiple vertices. Separate the VIDs with commas. <code>FETCH PROP ON player, t1 \"player100\", \"player103\" YIELD properties(vertex)</code> Specify multiple tags in the <code>FETCH</code> statement to fetch the vertex properties by the tags. Separate the tags with commas. <code>FETCH PROP ON * \"player100\", \"player106\", \"team200\" YIELD properties(vertex)</code> Set an asterisk symbol <code>*</code> to fetch properties by all tags in the current graph space. </li> </ul> <ul> <li> <p>Fetch edge properties</p> <pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> Example Description <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD properties(edge)</code> The following statement fetches all the properties of the <code>serve</code> edge that connects vertex <code>\"player100\"</code> and vertex <code>\"team204\"</code>. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD serve.start_year</code> Use a <code>YIELD</code> clause to fetch specific properties of an edge. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\", \"player133\" -&gt; \"team202\" YIELD properties(edge)</code> Specify multiple edge patterns (<code>&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]</code>) to fetch properties of multiple edges. Separate the edge patterns with commas. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\"@1 YIELD properties(edge)</code> To fetch on an edge whose rank is not 0, set its rank in the FETCH statement. <code>GO FROM \"player101\" OVER follow YIELD follow._src AS s, follow._dst AS d | FETCH PROP ON follow $-.s -&gt; $-.d YIELD follow.degree</code> The following statement returns the <code>degree</code> values of the <code>follow</code> edges that start from vertex <code>\"player101\"</code>. <code>$var = GO FROM \"player101\" OVER follow YIELD follow._src AS s, follow._dst AS d; FETCH PROP ON follow $var.s -&gt; $var.d YIELD follow.degree</code> You can use user-defined variables to construct similar queries. </li> </ul> </li> </ul> <ul> <li> <p>SHOW</p> Statement Syntax Example Description SHOW CHARSET <code>SHOW CHARSET</code> <code>SHOW CHARSET</code> Shows the available character sets. SHOW COLLATION <code>SHOW COLLATION</code> <code>SHOW COLLATION</code> Shows the collations supported by NebulaGraph. SHOW CREATE SPACE <code>SHOW CREATE SPACE &lt;space_name&gt;</code> <code>SHOW CREATE SPACE basketballplayer</code> Shows the creating statement of the specified graph space. SHOW CREATE TAG/EDGE <code>SHOW CREATE {TAG &lt;tag_name&gt; | EDGE &lt;edge_name&gt;}</code> <code>SHOW CREATE TAG player</code> Shows the basic information of the specified tag. SHOW HOSTS <code>SHOW HOSTS [GRAPH | STORAGE | META]</code> <code>SHOW HOSTS</code><code>SHOW HOSTS GRAPH</code> Shows the host and version information of Graph Service, Storage Service, and Meta Service. SHOW INDEX STATUS <code>SHOW {TAG | EDGE} INDEX STATUS</code> <code>SHOW TAG INDEX STATUS</code> Shows the status of jobs that rebuild native indexes, which helps check whether a native index is successfully rebuilt or not. SHOW INDEXES <code>SHOW {TAG | EDGE} INDEXES</code> <code>SHOW TAG INDEXES</code> Shows the names of existing native indexes. SHOW PARTS <code>SHOW PARTS [&lt;part_id&gt;]</code> <code>SHOW PARTS</code> Shows the information of a specified partition or all partitions in a graph space. SHOW ROLES <code>SHOW ROLES IN &lt;space_name&gt;</code> <code>SHOW ROLES in basketballplayer</code> Shows the roles that are assigned to a user account. SHOW SNAPSHOTS <code>SHOW SNAPSHOTS</code> <code>SHOW SNAPSHOTS</code> Shows the information of all the snapshots. SHOW SPACES <code>SHOW SPACES</code> <code>SHOW SPACES</code> Shows existing graph spaces in NebulaGraph. SHOW STATS <code>SHOW STATS</code> <code>SHOW STATS</code> Shows the statistics of the graph space collected by the latest <code>STATS</code> job. SHOW TAGS/EDGES <code>SHOW TAGS | EDGES</code> <code>SHOW TAGS</code>,<code>SHOW EDGES</code> Shows all the tags in the current graph space. SHOW USERS <code>SHOW USERS</code> <code>SHOW USERS</code> Shows the user information. SHOW SESSIONS <code>SHOW SESSIONS</code> <code>SHOW SESSIONS</code> Shows the information of all the sessions. SHOW SESSIONS <code>SHOW SESSION &lt;Session_Id&gt;</code> <code>SHOW SESSION 1623304491050858</code> Shows a specified session with its ID. SHOW QUERIES <code>SHOW [ALL] QUERIES</code> <code>SHOW QUERIES</code> Shows the information of working queries in the current session. SHOW META LEADER <code>SHOW META LEADER</code> <code>SHOW META LEADER</code> Shows the information of the leader in the current Meta cluster. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#clauses_and_options","title":"Clauses and options","text":"Clause Syntax Example Description GROUP BY <code>GROUP BY &lt;var&gt; YIELD &lt;var&gt;, &lt;aggregation_function(var)&gt;</code> <code>GO FROM \"player100\" OVER follow BIDIRECT YIELD $$.player.name as Name | GROUP BY $-.Name YIELD $-.Name as Player, count(*) AS Name_Count</code> Finds all the vertices connected directly to vertex <code>\"player100\"</code>, groups the result set by player names, and counts how many times the name shows up in the result set. LIMIT <code>YIELD &lt;var&gt; [| LIMIT [&lt;offset_value&gt;,] &lt;number_rows&gt;]</code> <code>GO FROM \"player100\" OVER follow REVERSELY YIELD $$.player.name AS Friend, $$.player.age AS Age | ORDER BY $-.Age, $-.Friend | LIMIT 1, 3</code> Returns the 3 rows of data starting from the second row of the sorted output. SKIP <code>RETURN &lt;var&gt; [SKIP &lt;offset&gt;] [LIMIT &lt;number_rows&gt;]</code> <code>MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) RETURN v2.player.name AS Name, v2.player.age AS Age ORDER BY Age DESC SKIP 1</code> <code>SKIP</code> can be used alone to set the offset and return the data after the specified position. SAMPLE <code>&lt;go_statement&gt; SAMPLE &lt;sample_list&gt;;</code> <code>GO 3 STEPS FROM \"player100\" OVER * YIELD properties($$).name AS NAME, properties($$).age AS Age SAMPLE [1,2,3];</code> Takes samples evenly in the result set and returns the specified amount of data. ORDER BY <code>&lt;YIELD clause&gt; ORDER BY &lt;expression&gt; [ASC | DESC] [, &lt;expression&gt; [ASC | DESC] ...]</code> <code>FETCH PROP ON player \"player100\", \"player101\", \"player102\", \"player103\" YIELD player.age AS age, player.name AS name | ORDER BY $-.age ASC, $-.name DESC</code> The <code>ORDER BY</code> clause specifies the order of the rows in the output. RETURN <code>RETURN {&lt;vertex_name&gt;|&lt;edge_name&gt;|&lt;vertex_name&gt;.&lt;property&gt;|&lt;edge_name&gt;.&lt;property&gt;|...}</code> <code>MATCH (v:player) RETURN v.player.name, v.player.age LIMIT 3</code> Returns the first three rows with values of the vertex properties <code>name</code> and <code>age</code>. TTL <code>CREATE TAG &lt;tag_name&gt;(&lt;property_name_1&gt; &lt;property_value_1&gt;, &lt;property_name_2&gt; &lt;property_value_2&gt;, ...) ttl_duration= &lt;value_int&gt;, ttl_col = &lt;property_name&gt;</code> <code>CREATE TAG t2(a int, b int, c string) ttl_duration= 100, ttl_col = \"a\"</code> Create a tag and set the TTL options. WHERE <code>WHERE {&lt;vertex|edge_alias&gt;.&lt;property_name&gt; {&gt;|==|&lt;|...} &lt;value&gt;...}</code> <code>MATCH (v:player) WHERE v.player.name == \"Tim Duncan\" XOR (v.player.age &lt; 30 AND v.player.name == \"Yao Ming\") OR NOT (v.player.name == \"Yao Ming\" OR v.player.name == \"Tim Duncan\") RETURN v.player.name, v.player.age</code> The <code>WHERE</code> clause filters the output by conditions. The <code>WHERE</code> clause usually works in Native nGQL <code>GO</code> and <code>LOOKUP</code> statements, and OpenCypher <code>MATCH</code> and <code>WITH</code> statements. YIELD <code>YIELD [DISTINCT] &lt;col&gt; [AS &lt;alias&gt;] [, &lt;col&gt; [AS &lt;alias&gt;] ...] [WHERE &lt;conditions&gt;];</code> <code>GO FROM \"player100\" OVER follow YIELD dst(edge) AS ID | FETCH PROP ON player $-.ID YIELD player.age AS Age | YIELD AVG($-.Age) as Avg_age, count(*)as Num_friends</code> Finds the players that \"player100\" follows and calculates their average age. WITH <code>MATCH $expressions WITH {nodes()|labels()|...}</code> <code>MATCH p=(v:player{name:\"Tim Duncan\"})--() WITH nodes(p) AS n UNWIND n AS n1 RETURN DISTINCT n1</code> The <code>WITH</code> clause can retrieve the output from a query part, process it, and pass it to the next query part as the input. UNWIND <code>UNWIND &lt;list&gt; AS &lt;alias&gt; &lt;RETURN clause&gt;</code> <code>UNWIND [1,2,3] AS n RETURN n</code> Splits a list into rows."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#space_statements","title":"Space statements","text":"Statement Syntax Example Description CREATE SPACE <code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; ( [partition_num = &lt;partition_number&gt;,] [replica_factor = &lt;replica_number&gt;,] vid_type = {FIXED_STRING(&lt;N&gt;) | INT[64]} ) [COMMENT = '&lt;comment&gt;']</code> <code>CREATE SPACE my_space_1 (vid_type=FIXED_STRING(30))</code> Creates a graph space with CREATE SPACE <code>CREATE SPACE &lt;new_graph_space_name&gt; AS &lt;old_graph_space_name&gt;</code> <code>CREATE SPACE my_space_4 as my_space_3</code> Clone a graph. space. USE <code>USE &lt;graph_space_name&gt;</code> <code>USE space1</code> Specifies a graph space as the current working graph space for subsequent queries. SHOW SPACES <code>SHOW SPACES</code> <code>SHOW SPACES</code> Lists all the graph spaces in the NebulaGraph examples. DESCRIBE SPACE <code>DESC[RIBE] SPACE &lt;graph_space_name&gt;</code> <code>DESCRIBE SPACE basketballplayer</code> Returns the information about the specified graph space. CLEAR SPACE <code>CLEAR SPACE [IF EXISTS] &lt;graph_space_name&gt;</code> Deletes the vertices and edges in a graph space, but does not delete the graph space itself and the schema information. DROP SPACE <code>DROP SPACE [IF EXISTS] &lt;graph_space_name&gt;</code> <code>DROP SPACE basketballplayer</code> Deletes everything in the specified graph space."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#tag_statements","title":"TAG statements","text":"Statement Syntax Example Description CREATE TAG <code>CREATE TAG [IF NOT EXISTS] &lt;tag_name&gt; ( &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'] [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL |  NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] ) [TTL_DURATION = &lt;ttl_duration&gt;] [TTL_COL = &lt;prop_name&gt;] [COMMENT = '&lt;comment&gt;']</code> <code>CREATE TAG woman(name string, age int, married bool, salary double, create_time timestamp) TTL_DURATION = 100, TTL_COL = \"create_time\"</code> Creates a tag with the given name in a graph space. DROP TAG <code>DROP TAG [IF EXISTS] &lt;tag_name&gt;</code> <code>DROP TAG test;</code> Drops a tag with the given name in the current working graph space. ALTER TAG <code>ALTER TAG &lt;tag_name&gt;    &lt;alter_definition&gt; [, alter_definition] ...]    [ttl_definition [, ttl_definition] ... ]    [COMMENT = '&lt;comment&gt;']</code> <code>ALTER TAG t1 ADD (p3 int, p4 string)</code> Alters the structure of a tag with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration. SHOW TAGS <code>SHOW TAGS</code> <code>SHOW TAGS</code> Shows the name of all tags in the current graph space. DESCRIBE TAG <code>DESC[RIBE] TAG &lt;tag_name&gt;</code> <code>DESCRIBE TAG player</code> Returns the information about a tag with the given name in a graph space, such as field names, data type, and so on. DELETE TAG <code>DELETE TAG &lt;tag_name_list&gt; FROM &lt;VID&gt;</code> <code>DELETE TAG test1 FROM \"test\"</code> Deletes a tag with the given name on a specified vertex."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#edge_type_statements","title":"Edge type statements","text":"Statement Syntax Example Description CREATE EDGE <code>CREATE EDGE [IF NOT EXISTS] &lt;edge_type_name&gt;    ( &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'] [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] ) [TTL_DURATION = &lt;ttl_duration&gt;] [TTL_COL = &lt;prop_name&gt;] [COMMENT = '&lt;comment&gt;']</code> <code>CREATE EDGE e1(p1 string, p2 int, p3 timestamp) TTL_DURATION = 100, TTL_COL = \"p2\"</code> Creates an edge type with the given name in a graph space. DROP EDGE <code>DROP EDGE [IF EXISTS] &lt;edge_type_name&gt;</code> <code>DROP EDGE e1</code> Drops an edge type with the given name in a graph space. ALTER EDGE <code>ALTER EDGE &lt;edge_type_name&gt;    &lt;alter_definition&gt; [, alter_definition] ...]    [ttl_definition [, ttl_definition] ... ]    [COMMENT = '&lt;comment&gt;']</code> <code>ALTER EDGE e1 ADD (p3 int, p4 string)</code> Alters the structure of an edge type with the given name in a graph space. SHOW EDGES <code>SHOW EDGES</code> <code>SHOW EDGES</code> Shows all edge types in the current graph space. DESCRIBE EDGE <code>DESC[RIBE] EDGE &lt;edge_type_name&gt;</code> <code>DESCRIBE EDGE follow</code> Returns the information about an edge type with the given name in a graph space, such as field names, data type, and so on."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#vertex_statements","title":"Vertex statements","text":"Statement Syntax Example Description INSERT VERTEX <code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...] VALUES &lt;vid&gt;: ([prop_value_list])</code> <code>INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8)</code> Inserts one or more vertices into a graph space in NebulaGraph. DELETE VERTEX <code>DELETE VERTEX &lt;vid&gt; [, &lt;vid&gt; ...]</code> <code>DELETE VERTEX \"team1\"</code> Deletes vertices and the related incoming and outgoing edges of the vertices. UPDATE VERTEX <code>UPDATE VERTEX ON &lt;tag_name&gt; &lt;vid&gt; SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPDATE VERTEX ON player \"player101\" SET age = age + 2</code> Updates properties on tags of a vertex. UPSERT VERTEX <code>UPSERT VERTEX ON &lt;tag&gt; &lt;vid&gt; SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPSERT VERTEX ON player \"player667\" SET age = 31</code> The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT VERTEX</code> to update the properties of a vertex if it exists or insert a new vertex if it does not exist."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#edge_statements","title":"Edge statements","text":"Statement Syntax Example Description INSERT EDGE <code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ) [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...]</code> <code>INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 1)</code> Inserts an edge or multiple edges into a graph space from a source vertex (given by src_vid) to a destination vertex (given by dst_vid) with a specific rank in NebulaGraph. DELETE EDGE <code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] ...]</code> <code>DELETE EDGE serve \"player100\" -&gt; \"team204\"@0</code> Deletes one edge or multiple edges at a time. UPDATE EDGE <code>UPDATE EDGE ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@&lt;rank&gt;] SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPDATE EDGE ON serve \"player100\" -&gt; \"team204\"@0 SET start_year = start_year + 1</code> Updates properties on an edge. UPSERT EDGE <code>UPSERT EDGE ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@rank] SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;properties&gt;]</code> <code>UPSERT EDGE on serve \"player666\" -&gt; \"team200\"@0 SET end_year = 2021</code> The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT EDGE</code> to update the properties of an edge if it exists or insert a new edge if it does not exist."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#index","title":"Index","text":"<ul> <li> <p>Native index</p> <p>You can use native indexes together with <code>LOOKUP</code> and <code>MATCH</code> statements.</p> Statement Syntax Example Description CREATE INDEX <code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT = '&lt;comment&gt;']</code> <code>CREATE TAG INDEX player_index on player()</code> Add native indexes for the existing tags, edge types, or properties. SHOW CREATE INDEX <code>SHOW CREATE {TAG | EDGE} INDEX &lt;index_name&gt;</code> <code>show create tag index index_2</code> Shows the statement used when creating a tag or an edge type. It contains detailed information about the index, such as its associated properties. SHOW INDEXES <code>SHOW {TAG | EDGE} INDEXES</code> <code>SHOW TAG INDEXES</code> Shows the defined tag or edge type indexes names in the current graph space. DESCRIBE INDEX <code>DESCRIBE {TAG | EDGE} INDEX &lt;index_name&gt;</code> <code>DESCRIBE TAG INDEX player_index_0</code> Gets the information about the index with a given name, including the property name (Field) and the property type (Type) of the index. REBUILD INDEX <code>REBUILD {TAG | EDGE} INDEX [&lt;index_name_list&gt;]</code> <code>REBUILD TAG INDEX single_person_index</code> Rebuilds the created tag or edge type index. If data is updated or inserted before the creation of the index, you must rebuild the indexes manually to make sure that the indexes contain the previously added data. SHOW INDEX STATUS <code>SHOW {TAG | EDGE} INDEX STATUS</code> <code>SHOW TAG INDEX STATUS</code> Returns the name of the created tag or edge type index and its status. DROP INDEX <code>DROP {TAG | EDGE} INDEX [IF EXISTS] &lt;index_name&gt;</code> <code>DROP TAG INDEX player_index_0</code> Removes an existing index from the current graph space. </li> </ul> <ul> <li> <p>Full-text index</p> Syntax Example Description <code>SIGN IN TEXT SERVICE [(&lt;elastic_ip:port&gt; [,&lt;username&gt;, &lt;password&gt;]), (&lt;elastic_ip:port&gt;), ...]</code> <code>SIGN IN TEXT SERVICE (127.0.0.1:9200)</code> The full-text indexes is implemented based on Elasticsearch. After deploying an Elasticsearch cluster, you can use the <code>SIGN IN</code> statement to log in to the Elasticsearch client. <code>SHOW TEXT SEARCH CLIENTS</code> <code>SHOW TEXT SEARCH CLIENTS</code> Shows text search clients. <code>SIGN OUT TEXT SERVICE</code> <code>SIGN OUT TEXT SERVICE</code> Signs out to the text search clients. <code>CREATE FULLTEXT {TAG | EDGE} INDEX &lt;index_name&gt; ON {&lt;tag_name&gt; |  &lt;edge_name&gt;} ([&lt;prop_name_list&gt;])</code> <code>CREATE FULLTEXT TAG INDEX nebula_index_1 ON player(name)</code> Creates full-text indexes. <code>SHOW FULLTEXT INDEXES</code> <code>SHOW FULLTEXT INDEXES</code> Show full-text indexes. <code>REBUILD FULLTEXT INDEX</code> <code>REBUILD FULLTEXT INDEX</code> Rebuild full-text indexes. <code>DROP FULLTEXT INDEX &lt;index_name&gt;</code> <code>DROP FULLTEXT INDEX nebula_index_1</code> Drop full-text indexes. <code>LOOKUP ON {&lt;tag&gt; | &lt;edge_type&gt;} WHERE &lt;expression&gt; [YIELD &lt;return_list&gt;]</code> <code>LOOKUP ON player WHERE FUZZY(player.name, \"Tim Dunncan\", AUTO, OR) YIELD player.name</code> Use query options. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#subgraph_and_path_statements","title":"Subgraph and path statements","text":"Type Syntax Example Description GET SUBGRAPH <code>GET SUBGRAPH [WITH PROP] [&lt;step_count&gt; {STEP|STEPS}] FROM {&lt;vid&gt;, &lt;vid&gt;...} [{IN | OUT | BOTH} &lt;edge_type&gt;, &lt;edge_type&gt;...] YIELD [VERTICES AS &lt;vertex_alias&gt;] [,EDGES AS &lt;edge_alias&gt;]</code> <code>GET SUBGRAPH 1 STEPS FROM \"player100\" YIELD VERTICES AS nodes, EDGES AS relationships</code> Retrieves information of vertices and edges reachable from the source vertices of the specified edge types and returns information of the subgraph. FIND PATH <code>FIND { SHORTEST | ALL | NOLOOP } PATH [WITH PROP] FROM &lt;vertex_id_list&gt; TO &lt;vertex_id_list&gt; OVER &lt;edge_type_list&gt; [REVERSELY | BIDIRECT] [&lt;WHERE clause&gt;] [UPTO &lt;N&gt; {STEP|STEPS}] YIELD path as &lt;alias&gt; [| ORDER BY $-.path] [| LIMIT &lt;M&gt;]</code> <code>FIND SHORTEST PATH FROM \"player102\" TO \"team204\" OVER * YIELD path as p</code> Finds the paths between the selected source vertices and destination vertices. A returned path is like <code>(&lt;vertex_id&gt;)-[:&lt;edge_type_name&gt;@&lt;rank&gt;]-&gt;(&lt;vertex_id)</code>."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#query_tuning_statements","title":"Query tuning statements","text":"Type Syntax Example Description EXPLAIN <code>EXPLAIN [format=\"row\" | \"dot\"] &lt;your_nGQL_statement&gt;</code> <code>EXPLAIN format=\"row\" SHOW TAGS</code><code>EXPLAIN format=\"dot\" SHOW TAGS</code> Helps output the execution plan of an nGQL statement without executing the statement. PROFILE <code>PROFILE [format=\"row\" | \"dot\"] &lt;your_nGQL_statement&gt;</code> <code>PROFILE format=\"row\" SHOW TAGS</code><code>EXPLAIN format=\"dot\" SHOW TAGS</code> Executes the statement, then outputs the execution plan as well as the execution profile."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#operation_and_maintenance_statements","title":"Operation and maintenance statements","text":"<ul> <li> <p>SUBMIT JOB BALANCE</p> Syntax Description <code>BALANCE LEADER</code> Starts a job to balance the distribution of all the storage leaders in graph spaces. It returns the job ID. </li> </ul> <ul> <li> <p>Job statements</p> Syntax Description <code>SUBMIT JOB COMPACT</code> Triggers the long-term RocksDB <code>compact</code> operation. <code>SUBMIT JOB FLUSH</code> Writes the RocksDB memfile in the memory to the hard disk. <code>SUBMIT JOB STATS</code> Starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the <code>SHOW STATS</code> statement to list the statistics. <code>SHOW JOB &lt;job_id&gt;</code> Shows the information about a specific job and all its tasks in the current graph space. The Meta Service parses a <code>SUBMIT JOB</code> request into multiple tasks and assigns them to the nebula-storaged processes. <code>SHOW JOBS</code> Lists all the unexpired jobs in the current graph space. <code>STOP JOB</code> Stops jobs that are not finished in the current graph space. <code>RECOVER JOB</code> Re-executes the failed jobs in the current graph space and returns the number of recovered jobs. </li> </ul> <ul> <li> <p>Kill queries</p> Syntax Example Description <code>KILL QUERY (session=&lt;session_id&gt;, plan=&lt;plan_id&gt;)</code> <code>KILL QUERY(SESSION=1625553545984255,PLAN=163)</code> Terminates the query being executed, and is often used to terminate slow queries. </li> </ul>"},{"location":"3.ngql-guide/4.job-statements/","title":"Job manager and the JOB statements","text":"<p>The long-term tasks run by the Storage Service are called jobs, such as <code>COMPACT</code>, <code>FLUSH</code>, and <code>STATS</code>. These jobs can be time-consuming if the data amount in the graph space is large. The job manager helps you run, show, stop, and recover jobs.</p> <p>Note</p> <p>All job management commands can be executed only after selecting a graph space.</p>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_balance_leader","title":"SUBMIT JOB BALANCE LEADER","text":"<p>Starts a job to balance the distribution of all the storage leaders in all graph spaces. It returns the job ID.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB BALANCE LEADER;\n+------------+\n| New Job Id |\n+------------+\n| 33         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_compact","title":"SUBMIT JOB COMPACT","text":"<p>The <code>SUBMIT JOB COMPACT</code> statement triggers the long-term RocksDB <code>compact</code> operation in the current graph space.</p> <p>For more information about <code>compact</code> configuration, see Storage Service configuration.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB COMPACT;\n+------------+\n| New Job Id |\n+------------+\n| 40         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_flush","title":"SUBMIT JOB FLUSH","text":"<p>The <code>SUBMIT JOB FLUSH</code> statement writes the RocksDB memfile in the memory to the hard disk in the current graph space.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB FLUSH;\n+------------+\n| New Job Id |\n+------------+\n| 96         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_stats","title":"SUBMIT JOB STATS","text":"<p>The <code>SUBMIT JOB STATS</code> statement starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the <code>SHOW STATS</code> statement to list the statistics. For more information, see SHOW STATS.</p> <p>Note</p> <p>If the data stored in the graph space changes, in order to get the latest statistics, you have to run <code>SUBMIT JOB STATS</code> again.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 9          |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_downloadingest","title":"SUBMIT JOB DOWNLOAD/INGEST","text":"<p>The <code>SUBMIT JOB DOWNLOAD HDFS</code> and <code>SUBMIT JOB INGEST</code> commands are used to import the SST file into NebulaGraph. For detail, see Import data from SST files.</p> <p>The <code>SUBMIT JOB DOWNLOAD HDFS</code> command will download the SST file on the specified HDFS.</p> <p>The <code>SUBMIT JOB INGEST</code> command will import the downloaded SST file into NebulaGraph.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB DOWNLOAD HDFS \"hdfs://192.168.10.100:9000/sst\";\n+------------+\n| New Job Id |\n+------------+\n| 10         |\n+------------+\nnebula&gt; SUBMIT JOB INGEST;\n+------------+\n| New Job Id |\n+------------+\n| 11         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#show_job","title":"SHOW JOB","text":"<p>The Meta Service parses a <code>SUBMIT JOB</code> request into multiple tasks and assigns them to the nebula-storaged processes. The <code>SHOW JOB &lt;job_id&gt;</code> statement shows the information about a specific job and all its tasks in the current graph space.</p> <p><code>job_id</code> is returned when you run the <code>SUBMIT JOB</code> statement.</p> <p>For example:</p> <pre><code>nebula&gt; SHOW JOB 8;\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n| Job Id(TaskId) | Command(Dest)   | Status     | Start Time                 | Stop Time                  | Error Code  |\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n| 8              | \"STATS\"         | \"FINISHED\" | 2022-10-18T08:14:45.000000 | 2022-10-18T08:14:45.000000 | \"SUCCEEDED\" |\n| 0              | \"192.168.8.129\" | \"FINISHED\" | 2022-10-18T08:14:45.000000 | 2022-10-18T08:15:13.000000 | \"SUCCEEDED\" |\n| \"Total:1\"      | \"Succeeded:1\"   | \"Failed:0\" | \"In Progress:0\"            | \"\"                         | \"\"          |\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n</code></pre> <p>The descriptions are as follows.</p> Parameter Description <code>Job Id(TaskId)</code> The first row shows the job ID and the other rows show the task IDs and the last row shows the total number of job-related tasks. <code>Command(Dest)</code> The first row shows the command executed and the other rows show on which storaged processes the task is running. The last row shows the number of successful tasks related to the job. <code>Status</code> Shows the status of the job or task. The last row shows the number of failed tasks related to the job. For more information, see Job status. <code>Start Time</code> Shows a timestamp indicating the time when the job or task enters the <code>RUNNING</code> phase. The last row shows the number of ongoing tasks related to the job. <code>Stop Time</code> Shows a timestamp indicating the time when the job or task gets <code>FINISHED</code>, <code>FAILED</code>, or <code>STOPPED</code>. <code>Error Code</code> The error code of job."},{"location":"3.ngql-guide/4.job-statements/#job_status","title":"Job status","text":"<p>The descriptions are as follows.</p> Status Description QUEUE The job or task is waiting in a queue. The <code>Start Time</code> is empty in this phase. RUNNING The job or task is running. The <code>Start Time</code> shows the beginning time of this phase. FINISHED The job or task is successfully finished. The <code>Stop Time</code> shows the time when the job or task enters this phase. FAILED The job or task has failed. The <code>Stop Time</code> shows the time when the job or task enters this phase. STOPPED The job or task is stopped without running. The <code>Stop Time</code> shows the time when the job or task enters this phase. REMOVED The job or task is removed. <p>The description of switching the status is described as follows.</p> <pre><code>Queue -- running -- finished -- removed\n     \\          \\                /\n      \\          \\ -- failed -- /\n       \\          \\            /\n        \\ ---------- stopped -/\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#show_jobs","title":"SHOW JOBS","text":"<p>The <code>SHOW JOBS</code> statement lists all the unexpired jobs in the current graph space.</p> <p>The default job expiration interval is one week. You can change it by modifying the <code>job_expired_secs</code> parameter of the Meta Service. For how to modify <code>job_expired_secs</code>, see Meta Service configuration.</p> <p>For example:</p> <pre><code>nebula&gt; SHOW JOBS;\n+--------+---------------------+------------+----------------------------+----------------------------+\n| Job Id | Command             | Status     | Start Time                 | Stop Time                  |\n+--------+---------------------+------------+----------------------------+----------------------------+\n| 34     | \"STATS\"             | \"FINISHED\" | 2021-11-01T03:32:27.000000 | 2021-11-01T03:32:27.000000 |\n| 33     | \"FLUSH\"             | \"FINISHED\" | 2021-11-01T03:32:15.000000 | 2021-11-01T03:32:15.000000 |\n| 32     | \"COMPACT\"           | \"FINISHED\" | 2021-11-01T03:32:06.000000 | 2021-11-01T03:32:06.000000 |\n| 31     | \"REBUILD_TAG_INDEX\" | \"FINISHED\" | 2021-10-29T05:39:16.000000 | 2021-10-29T05:39:17.000000 |\n| 10     | \"COMPACT\"           | \"FINISHED\" | 2021-10-26T02:27:05.000000 | 2021-10-26T02:27:05.000000 |\n+--------+---------------------+------------+----------------------------+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#stop_job","title":"STOP JOB","text":"<p>The <code>STOP JOB &lt;job_id&gt;</code> statement stops jobs that are not finished in the current graph space.</p> <p>For example:</p> <pre><code>nebula&gt; STOP JOB 22;\n+---------------+\n| Result        |\n+---------------+\n| \"Job stopped\" |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#recover_job","title":"RECOVER JOB","text":"<p>The <code>RECOVER JOB [&lt;job_id&gt;]</code> statement re-executes the jobs that status is <code>FAILED</code> or <code>STOPPED</code> in the current graph space and returns the number of recovered jobs. If <code>&lt;job_id&gt;</code> is not specified, re-execution is performed from the earliest job and the number of jobs that have been recovered is returned.</p> <p>For example:</p> <pre><code>nebula&gt; RECOVER JOB;\n+-------------------+\n| Recovered job num |\n+-------------------+\n| 5 job recovered   |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#faq","title":"FAQ","text":""},{"location":"3.ngql-guide/4.job-statements/#how_to_troubleshoot_job_problems","title":"How to troubleshoot job problems?","text":"<p>The <code>SUBMIT JOB</code> operations use the HTTP port. Please check if the HTTP ports on the machines where the Storage Service is running are working well. You can use the following command to debug.</p> <pre><code>curl \"http://{storaged-ip}:19779/admin?space={space_name}&amp;op=compact\"\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/","title":"NebulaGraph Query Language (nGQL)","text":"<p>This topic gives an introduction to the query language of NebulaGraph, nGQL.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_is_ngql","title":"What is nGQL","text":"<p>nGQL is a declarative graph query language for NebulaGraph. It allows expressive and efficient graph patterns. nGQL is designed for both developers and operations professionals. nGQL is an SQL-like query language, so it's easy to learn.</p> <p>nGQL is a project in progress. New features and optimizations are done steadily. There can be differences between syntax and implementation. Submit an issue to inform the NebulaGraph team if you find a new issue of this type. NebulaGraph 3.0 or later releases will support openCypher 9.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_can_ngql_do","title":"What can nGQL do","text":"<ul> <li>Supports graph traversals</li> <li>Supports pattern match</li> <li>Supports aggregation</li> <li>Supports graph mutation</li> <li>Supports access control</li> <li>Supports composite queries</li> <li>Supports index</li> <li>Supports most openCypher 9 graph query syntax (but mutations and controls syntax are not supported)</li> </ul>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#example_data_basketballplayer","title":"Example data Basketballplayer","text":"<p>Users can download the example data Basketballplayer in NebulaGraph. After downloading the example data, you can import it to NebulaGraph by using the <code>-f</code> option in NebulaGraph Console.</p> <p>Note</p> <p>Ensure that you have executed the <code>ADD HOSTS</code> command to add the Storage service to your NebulaGraph cluster before importing the example data. For more information, see Manage Storage hosts.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#placeholder_identifiers_and_values","title":"Placeholder identifiers and values","text":"<p>Refer to the following standards in nGQL:</p> <ul> <li>(Draft) ISO/IEC JTC1 N14279 SC 32 - Database_Languages - GQL</li> </ul> <ul> <li>(Draft) ISO/IEC JTC1 SC32 N3228 - SQL_Property_Graph_Queries - SQLPGQ</li> </ul> <ul> <li>OpenCypher 9</li> </ul> <p>In template code, any token that is not a keyword, a literal value, or punctuation is a placeholder identifier or a placeholder value.</p> <p>For details of the symbols in nGQL syntax, see the following table:</p> Token Meaning &lt; &gt; name of a syntactic element : formula that defines an element [ ] optional elements { } explicitly specified elements | complete alternative elements ... may be repeated any number of times <p>For example, create vertices in nGQL syntax:</p> <pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES &lt;vid&gt;: ([prop_value_list])\ntag_props:\n  tag_name ([prop_name_list])\nprop_name_list:\n   [prop_name [, prop_name] ...]\nprop_value_list:\n   [prop_value [, prop_value] ...]  \n</code></pre> <p>Example statement:</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int);\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#about_opencypher_compatibility","title":"About openCypher compatibility","text":""},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#native_ngql_and_opencypher","title":"Native nGQL and openCypher","text":"<p>Native nGQL is the part of a graph query language designed and implemented by NebulaGraph. OpenCypher is a graph query language maintained by openCypher Implementers Group.</p> <p>The latest release is openCypher 9. The compatible parts of openCypher in nGQL are called openCypher compatible sentences (short as openCypher).</p> <p>Note</p> <p><code>nGQL</code> = <code>native nGQL</code> + <code>openCypher compatible sentences</code></p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#is_ngql_compatible_with_opencypher_9_completely","title":"Is nGQL compatible with openCypher 9 completely?","text":"<p>NO.</p> <p>Compatibility with openCypher</p> <p>nGQL is designed to be compatible with part of DQL (match, optional match, with, etc.).</p> <ul> <li>It is not planned to be compatible with any DDL, DML, or DCL.</li> <li>It is not planned to be compatible with the Bolt Protocol.</li> <li>It is not planned to be compatible with APOC and GDS.</li> </ul> <p>Users can search in this manual with the keyword <code>compatibility</code> to find major compatibility issues.  </p> <p>Multiple known incompatible items are listed in NebulaGraph Issues. Submit an issue with the <code>incompatible</code> tag if you find a new issue of this type. </p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_are_the_major_differences_between_ngql_and_opencypher_9","title":"What are the major differences between nGQL and openCypher 9?","text":"<p>The following are some major differences (by design incompatible) between nGQL and openCypher.</p> Category openCypher 9 nGQL Schema Optional Schema Strong Schema Equality operator <code>=</code> <code>==</code> Math exponentiation <code>^</code> <code>^</code> is not supported. Use pow(x, y) instead. Edge rank No such concept. edge rank (reference by @) Statement - All DMLs (<code>CREATE</code>, <code>MERGE</code>, etc) of openCypher 9. Label and tag A label is used for searching a vertex, namely an index of vertex. A tag defines the type of a vertex and its corresponding properties. It cannot be used as an index. Pre-compiling and parameterized queries Support Parameterized queries are supported, but precompiling is not. <p>Compatibility</p> <p>OpenCypher 9 and Cypher have some differences in grammar and licence. For example,</p> <ol> <li> <p>Cypher requires that All Cypher statements are explicitly run within a transaction. While openCypher has no such requirement. And nGQL does not support transactions.</p> </li> <li> <p>Cypher has a variety of constraints, including Unique node property constraints, Node property existence constraints, Relationship property existence constraints, and Node key constraints. While OpenCypher has no such constraints. As a strong schema system, most of the constraints mentioned above can be solved through schema definitions (including NOT NULL) in nGQL. The only function that cannot be supported is the UNIQUE constraint.</p> </li> <li> <p>Cypher has APoC, while openCypher 9 does not have APoC. Cypher has Blot protocol support requirements, while openCypher 9 does not.</p> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#where_can_i_find_more_ngql_examples","title":"Where can I find more nGQL examples?","text":"<p>Users can find more than 2500 nGQL examples in the features directory on the NebulaGraph GitHub page.</p> <p>The <code>features</code> directory consists of <code>.feature</code> files. Each file records scenarios that you can use as nGQL examples. Here is an example:</p> <pre><code>Feature: Basic match\n\n  Background:\n    Given a graph with space named \"basketballplayer\"\n\n  Scenario: Single node\n    When executing query:\n      \"\"\"\n      MATCH (v:player {name: \"Yao Ming\"}) RETURN v;\n      \"\"\"\n    Then the result should be, in any order, with relax comparison:\n      | v                                                |\n      | (\"player133\" :player{age: 38, name: \"Yao Ming\"}) |\n\n  Scenario: One step\n    When executing query:\n      \"\"\"\n      MATCH (v1:player{name: \"LeBron James\"}) -[r]-&gt; (v2)\n      RETURN type(r) AS Type, v2.player.name AS Name\n      \"\"\"\n    Then the result should be, in any order:\n\n      | Type     | Name        |\n      | \"follow\" | \"Ray Allen\" |\n      | \"serve\"  | \"Lakers\"    |\n      | \"serve\"  | \"Heat\"      |\n      | \"serve\"  | \"Cavaliers\" |\n\nFeature:  Comparison of where clause\n\n  Background:\n    Given a graph with space named \"basketballplayer\"\n\n    Scenario: push edge props filter down\n      When profiling query:\n        \"\"\"\n        GO FROM \"player100\" OVER follow \n        WHERE properties(edge).degree IN [v IN [95,99] WHERE v &gt; 0] \n        YIELD dst(edge), properties(edge).degree\n        \"\"\"\n      Then the result should be, in any order:\n        | follow._dst | follow.degree |\n        | \"player101\" | 95            |\n        | \"player125\" | 95            |\n      And the execution plan should be:\n        | id | name         | dependencies | operator info                                               |\n        | 0  | Project      | 1            |                                                             |\n        | 1  | GetNeighbors | 2            | {\"filter\": \"(properties(edge).degree IN [v IN [95,99] WHERE (v&gt;0)])\"} |\n        | 2  | Start        |              |                                                             |\n</code></pre> <p>The keywords in the preceding example are described as follows.</p> Keyword Description <code>Feature</code> Describes the topic of the current <code>.feature</code> file. <code>Background</code> Describes the background information of the current <code>.feature</code> file. <code>Given</code> Describes the prerequisites of running the test statements in the current <code>.feature</code> file. <code>Scenario</code> Describes the scenarios. If there is the <code>@skip</code> before one <code>Scenario</code>, this scenario may not work and do not use it as a working example in a production environment. <code>When</code> Describes the nGQL statement to be executed. It can be a <code>executing query</code> or <code>profiling query</code>. <code>Then</code> Describes the expected return results of running the statement in the <code>When</code> clause. If the return results in your environment do not match the results described in the <code>.feature</code> file, submit an issue to inform the NebulaGraph team. <code>And</code> Describes the side effects of running the statement in the <code>When</code> clause. <code>@skip</code> This test case will be skipped. Commonly, the to-be-tested code is not ready. <p>Welcome to add more tck case and return automatically to the using statements in CI/CD.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#does_it_support_tinkerpop_gremlin","title":"Does it support TinkerPop Gremlin?","text":"<p>No. And no plan to support that.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#does_nebulagraph_support_w3c_rdf_sparql_or_graphql","title":"Does NebulaGraph support W3C RDF (SPARQL) or GraphQL?","text":"<p>No. And no plan to support that.</p> <p>The data model of NebulaGraph is the property graph. And as a strong schema system, NebulaGraph does not support RDF.</p> <p>NebulaGraph Query Language does not support <code>SPARQL</code> nor <code>GraphQL</code>.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/","title":"Patterns","text":"<p>Patterns and graph pattern matching are the very heart of a graph query language. This topic will describe the patterns in NebulaGraph, some of which have not yet been implemented.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_vertices","title":"Patterns for vertices","text":"<p>A vertex is described using a pair of parentheses and is typically given a name. For example:</p> <pre><code>(a)\n</code></pre> <p>This simple pattern describes a single vertex and names that vertex using the variable <code>a</code>.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_related_vertices","title":"Patterns for related vertices","text":"<p>A more powerful construct is a pattern that describes multiple vertices and edges between them. Patterns describe an edge by employing an arrow between two vertices. For example:</p> <pre><code>(a)-[]-&gt;(b)\n</code></pre> <p>This pattern describes a very simple data structure: two vertices and a single edge from one to the other. In this example, the two vertices are named as <code>a</code> and <code>b</code> respectively and the edge is <code>directed</code>: it goes from <code>a</code> to <code>b</code>.</p> <p>This manner of describing vertices and edges can be extended to cover an arbitrary number of vertices and the edges between them, for example:</p> <pre><code>(a)-[]-&gt;(b)&lt;-[]-(c)\n</code></pre> <p>Such a series of connected vertices and edges is called a <code>path</code>.</p> <p>Note that the naming of the vertices in these patterns is only necessary when one needs to refer to the same vertex again, either later in the pattern or elsewhere in the query. If not, the name may be omitted as follows:</p> <pre><code>(a)-[]-&gt;()&lt;-[]-(c)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_tags","title":"Patterns for tags","text":"<p>Note</p> <p>The concept of <code>tag</code> in nGQL has a few differences from that of <code>label</code> in openCypher. For example, users must create a <code>tag</code> before using it. And a <code>tag</code> also defines the type of properties.</p> <p>In addition to simply describing the vertices in the graphs, patterns can also describe the tags of the vertices. For example:</p> <pre><code>(a:User)-[]-&gt;(b)\n</code></pre> <p>Patterns can also describe a vertex that has multiple tags. For example:</p> <pre><code>(a:User:Admin)-[]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_properties","title":"Patterns for properties","text":"<p>Vertices and edges are the fundamental elements in a graph. In nGQL, properties are added to them for richer models.</p> <p>In the patterns, the properties can be expressed as follows: some key-value pairs are enclosed in curly brackets and separated by commas, and the tag or edge type to which a property belongs must be specified.</p> <p>For example, a vertex with two properties will be like:</p> <pre><code>(a:player{name: \"Tim Duncan\", age: 42})\n</code></pre> <p>One of the edges that connect to this vertex can be like:</p> <pre><code>(a)-[e:follow{degree: 95}]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_edges","title":"Patterns for edges","text":"<p>The simplest way to describe an edge is by using the arrow between two vertices, as in the previous examples.</p> <p>Users can describe an edge and its direction using the following statement. If users do not care about its direction, the arrowhead can be omitted. For example:</p> <pre><code>(a)-[]-(b)\n</code></pre> <p>Like vertices, edges can also be named. A pair of square brackets will be used to separate the arrow and the variable will be placed between them. For example:</p> <pre><code>(a)-[r]-&gt;(b)\n</code></pre> <p>Like the tags on vertices, edges can also have types. To describe an edge with a specific type, use the pattern as follows:</p> <pre><code>(a)-[r:REL_TYPE]-&gt;(b)\n</code></pre> <p>An edge can only have one edge type. But if we'd like to describe some data such that the edge could have a set of types, then they can all be listed in the pattern, separating them with the pipe symbol <code>|</code> like this:</p> <pre><code>(a)-[r:TYPE1|TYPE2]-&gt;(b)\n</code></pre> <p>Like vertices, the name of an edge can be omitted. For example:</p> <pre><code>(a)-[:REL_TYPE]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#variable-length_pattern","title":"Variable-length pattern","text":"<p>Rather than describing a long path using a sequence of many vertex and edge descriptions in a pattern, many edges (and the intermediate vertices) can be described by specifying a length in the edge description of a pattern. For example:</p> <pre><code>(a)-[*2]-&gt;(b)\n</code></pre> <p>The following pattern describes a graph of three vertices and two edges, all in one path (a path of length 2). It is equivalent to:</p> <pre><code>(a)-[]-&gt;()-[]-&gt;(b)\n</code></pre> <p>The range of lengths can also be specified. Such edge patterns are called <code>variable-length edges</code>. For example:</p> <pre><code>(a)-[*3..5]-&gt;(b)\n</code></pre> <p>The preceding example defines a path with a minimum length of 3 and a maximum length of 5.</p> <p>It describes a graph of either 4 vertices and 3 edges, 5 vertices and 4 edges, or 6 vertices and 5 edges, all connected in a single path.</p> <p>The lower bound can be omitted. For example, to describe paths of length 5 or less, use:</p> <pre><code>(a)-[*..5]-&gt;(b)\n</code></pre> <p>Note</p> <p>The upper bound must be specified. The following are NOT accepted.</p> <pre><code>(a)-[*3..]-&gt;(b)\n(a)-[*]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#assigning_to_path_variables","title":"Assigning to path variables","text":"<p>As described above, a series of connected vertices and edges is called a <code>path</code>. nGQL allows paths to be named using variables. For example:</p> <pre><code>p = (a)-[*3..5]-&gt;(b)\n</code></pre> <p>Users can do this in the <code>MATCH</code> statement.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/","title":"Comments","text":"<p>This topic will describe the comments in nGQL.</p> <p>Legacy version compatibility</p> <ul> <li>In NebulaGraph 1.x, there are four comment styles: <code>#</code>, <code>--</code>, <code>//</code>, <code>/* */</code>.</li> <li>Since NebulaGraph 2.x, <code>--</code> cannot be used as comments.</li> </ul>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/#examples","title":"Examples","text":"<pre><code>nebula&gt; # Do nothing in this line\nnebula&gt; RETURN 1+1;     # This comment continues to the end of this line.\nnebula&gt; RETURN 1+1;     // This comment continues to the end of this line.\nnebula&gt; RETURN 1 /* This is an in-line comment. */ + 1 == 2;\nnebula&gt; RETURN 11 +            \\\n/* Multi-line comment.       \\\nUse a backslash as a line break.   \\\n*/ 12;\n</code></pre> <p>In nGQL statement, the backslash <code>\\</code> in a line indicates a line break.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>In nGQL, you must add a <code>\\</code> at the end of every line, even in multi-line comments <code>/* */</code>.</li> <li>In openCypher, there is no need to use a <code>\\</code> as a line break.</li> </ul> <pre><code>/* openCypher style:\nThe following comment\nspans more than\none line */\nMATCH (n:label)\nRETURN n;\n</code></pre> <pre><code>/* nGQL style:  \\\nThe following comment       \\\nspans more than     \\\none line */       \\\nMATCH (n:tag) \\\nRETURN n;\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/","title":"Identifier case sensitivity","text":""},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#identifiers_are_case-sensitive","title":"Identifiers are Case-Sensitive","text":"<p>The following statements will not work because they refer to two different spaces, i.e. <code>my_space</code> and <code>MY_SPACE</code>.</p> <pre><code>nebula&gt; CREATE SPACE IF NOT EXISTS my_space (vid_type=FIXED_STRING(30));\nnebula&gt; use MY_SPACE;\n[ERROR (-1005)]: SpaceNotFound:\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#keywords_and_reserved_words_are_case-insensitive","title":"Keywords and Reserved Words are Case-Insensitive","text":"<p>The following statements are equivalent since <code>show</code> and <code>spaces</code> are keywords.</p> <pre><code>nebula&gt; show spaces;  \nnebula&gt; SHOW SPACES;\nnebula&gt; SHOW spaces;\nnebula&gt; show SPACES;\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#functions_are_case-insensitive","title":"Functions are Case-Insensitive","text":"<p>Functions are case-insensitive. For example, <code>count()</code>, <code>COUNT()</code>, and <code>couNT()</code> are equivalent.</p> <pre><code>nebula&gt; WITH [NULL, 1, 1, 2, 2] As a \\\n        UNWIND a AS b \\\n        RETURN count(b), COUNT(*), couNT(DISTINCT b);\n+----------+----------+-------------------+\n| count(b) | COUNT(*) | couNT(distinct b) |\n+----------+----------+-------------------+\n| 4        | 5        | 2                 |\n+----------+----------+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/","title":"Keywords","text":"<p>Keywords in nGQL are words with particular meanings, such as <code>CREATE</code> and <code>TAG</code> in the <code>CREATE TAG</code> statement. Keywords that require special processing to be used as identifiers are referred to as <code>reserved keywords</code>, while the part of keywords that can be used directly as identifiers are called <code>non-reserved keywords</code>.\"</p> <p>It is not recommend to use keywords in schema. If you must use keywords in schema:</p> <ul> <li>Non-reserved keywords can be used as identifiers without quotes if they are all in lowercase. However, if a non-reserved keyword contains any uppercase letters when used as an identifier, it must be enclosed in backticks (`), for example, `Comment`.</li> </ul> <ul> <li>To use special characters or reserved keywords as identifiers, quote them with backticks such as <code>AND</code>.</li> </ul> <p>Note</p> <p>Keywords are case-insensitive.</p> <pre><code>nebula&gt; CREATE TAG TAG(name string);\n[ERROR (-1004)]: SyntaxError: syntax error near `TAG'\n\nnebula&gt; CREATE TAG `TAG` (name string);\nExecution succeeded\n\nnebula&gt; CREATE TAG SPACE(name string);\nExecution succeeded\n\nnebula&gt; CREATE TAG \u4e2d\u6587(\u7b80\u4f53 string);\nExecution succeeded\n\nnebula&gt; CREATE TAG `\uffe5%special characters&amp;*+-*/` (`q~\uff01\uff08\uff09=  wer` string);\nExecution succeeded\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/#reserved_keywords","title":"Reserved keywords","text":"<pre><code>ACROSS\nADD\nALTER\nAND\nAS\nASC\nASCENDING\nBALANCE\nBOOL\nBY\nCASE\nCHANGE\nCOMPACT\nCREATE\nDATE\nDATETIME\nDELETE\nDESC\nDESCENDING\nDESCRIBE\nDISTINCT\nDOUBLE\nDOWNLOAD\nDROP\nDURATION\nEDGE\nEDGES\nEXISTS\nEXPLAIN\nFETCH\nFIND\nFIXED_STRING\nFLOAT\nFLUSH\nFORMAT\nFROM\nGET\nGO\nGRANT\nIF\nIGNORE_EXISTED_INDEX\nIN\nINDEX\nINDEXES\nINGEST\nINSERT\nINT\nINT16\nINT32\nINT64\nINT8\nINTERSECT\nIS\nLIMIT\nLIST\nLOOKUP\nMAP\nMATCH\nMINUS\nNO\nNOT\nNOT_IN\nNULL\nOF\nOFFSET\nON\nOR\nORDER\nOVER\nOVERWRITE\nPROFILE\nPROP\nREBUILD\nRECOVER\nREMOVE\nRESTART\nRETURN\nREVERSELY\nREVOKE\nSET\nSHOW\nSTEP\nSTEPS\nSTOP\nSTRING\nSUBMIT\nTAG\nTAGS\nTIME\nTIMESTAMP\nTO\nUNION\nUPDATE\nUPSERT\nUPTO\nUSE\nVERTEX\nVERTICES\nWHEN\nWHERE\nWITH\nXOR\nYIELD\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/#non-reserved_keywords","title":"Non-reserved keywords","text":"<pre><code>ACCOUNT\nADMIN\nALL\nANY\nATOMIC_EDGE\nAUTO\nBIDIRECT\nBOTH\nCHARSET\nCLIENTS\nCOLLATE\nCOLLATION\nCOMMENT\nCONFIGS\nCONTAINS\nDATA\nDBA\nDEFAULT\nELASTICSEARCH\nELSE\nEND\nENDS\nENDS_WITH\nFALSE\nFORCE\nFULLTEXT\nFUZZY\nGOD\nGRAPH\nGROUP\nGROUPS\nGUEST\nHDFS\nHOST\nHOSTS\nINTO\nIS_EMPTY\nIS_NOT_EMPTY\nIS_NOT_NULL\nIS_NULL\nJOB\nJOBS\nKILL\nLEADER\nLISTENER\nMETA\nNOLOOP\nNONE\nNOT_CONTAINS\nNOT_ENDS_WITH\nNOT_STARTS_WITH\nOPTIONAL\nOUT\nPART\nPARTITION_NUM\nPARTS\nPASSWORD\nPATH\nPLAN\nPREFIX\nQUERIES\nQUERY\nREDUCE\nREGEXP\nREPLICA_FACTOR\nRESET\nROLE\nROLES\nSAMPLE\nSEARCH\nSERVICE\nSESSION\nSESSIONS\nSHORTEST\nSIGN\nSINGLE\nSKIP\nSNAPSHOT\nSNAPSHOTS\nSPACE\nSPACES\nSTARTS\nSTARTS_WITH\nSTATS\nSTATUS\nSTORAGE\nSUBGRAPH\nTEXT\nTEXT_SEARCH\nTHEN\nTOP\nTRUE\nTTL_COL\nTTL_DURATION\nUNWIND\nUSER\nUSERS\nUUID\nVALUE\nVALUES\nVID_TYPE\nWILDCARD\nZONE\nZONES\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/","title":"nGQL style guide","text":"<p>nGQL does not have strict formatting requirements, but creating nGQL statements according to an appropriate and uniform style can improve readability and avoid ambiguity. Using the same nGQL style in the same organization or project helps reduce maintenance costs and avoid problems caused by format confusion or misunderstanding. This topic will provide a style guide for writing nGQL statements.</p> <p>Compatibility</p> <p>The styles of nGQL and Cypher Style Guide are different.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#newline","title":"Newline","text":"<ol> <li> <p>Start a new line to write a clause.</p> <p>Not recommended:</p> <pre><code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id;\n</code></pre> <p>Recommended:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow REVERSELY \\\nYIELD src(edge) AS id;\n</code></pre> </li> <li> <p>Start a new line to write different statements in a composite statement.</p> <p>Not recommended:</p> <pre><code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id | GO FROM $-.id \\\nOVER serve WHERE properties($^).age &gt; 20 YIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n</code></pre> <p>Recommended:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow REVERSELY \\\nYIELD src(edge) AS id | \\\nGO FROM $-.id OVER serve \\\nWHERE properties($^).age &gt; 20 \\\nYIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n</code></pre> </li> <li> <p>If the clause exceeds 80 characters, start a new line at the appropriate place.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\nWHERE (v2.player.name STARTS WITH \"Y\" AND v2.player.age &gt; 35 AND v2.player.age &lt; v.player.age) OR (v2.player.name STARTS WITH \"T\" AND v2.player.age &lt; 45 AND v2.player.age &gt; v.player.age) \\\nRETURN v2;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\nWHERE (v2.player.name STARTS WITH \"Y\" AND v2.player.age &gt; 35 AND v2.player.age &lt; v.player.age) \\\nOR (v2.player.name STARTS WITH \"T\" AND v2.player.age &lt; 45 AND v2.player.age &gt; v.player.age) \\\nRETURN v2;\n</code></pre> </li> </ol> <p>Note</p> <p>If needed, you can also start a new line for better understanding, even if the clause does not exceed 80 characters. </p>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#identifier_naming","title":"Identifier naming","text":"<p>In nGQL statements, characters other than keywords, punctuation marks, and blanks are all identifiers. Recommended methods to name the identifiers are as follows.</p> <ol> <li> <p>Use singular nouns to name tags, and use the base form of verbs or verb phrases to form Edge types.</p> <p>Not recommended:</p> <pre><code>MATCH p=(v:players)-[e:are_following]-(v2) \\\nRETURN nodes(p);\n</code></pre> <p>Recommended:</p> <pre><code>MATCH p=(v:player)-[e:follow]-(v2) \\\nRETURN nodes(p);\n</code></pre> </li> <li> <p>Use the snake case to name identifiers, and connect words with underscores (_) with all the letters lowercase.</p> <p>Not recommended:</p> <pre><code>MATCH (v:basketballTeam) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:basketball_team) \\\nRETURN v;\n</code></pre> </li> <li> <p>Use uppercase keywords and lowercase variables.</p> <p>Not recommended:</p> <pre><code>match (V:player) return V limit 5;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player) RETURN v LIMIT 5;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#pattern","title":"Pattern","text":"<ol> <li> <p>Start a new line on the right side of the arrow indicating an edge when writing patterns.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player{name: \"Tim Duncan\", age: 42}) \\\n-[e:follow]-&gt;()-[e:serve]-&gt;()&lt;--(v2) \\\nRETURN v, e, v2;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player{name: \"Tim Duncan\", age: 42})-[e:follow]-&gt; \\\n()-[e:serve]-&gt;()&lt;--(v2) \\\nRETURN v, e, v2;\n</code></pre> </li> <li> <p>Anonymize the vertices and edges that do not need to be queried.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player)-[e:follow]-&gt;(v2) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player)-[:follow]-&gt;() \\\nRETURN v;\n</code></pre> </li> <li> <p>Place named vertices in front of anonymous vertices.</p> <p>Not recommended:</p> <pre><code>MATCH ()-[:follow]-&gt;(v) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v)&lt;-[:follow]-() \\\nRETURN v;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#string","title":"String","text":"<p>The strings should be surrounded by double quotes.</p> <p>Not recommended:</p> <pre><code>RETURN 'Hello Nebula!';\n</code></pre> <p>Recommended:</p> <pre><code>RETURN \"Hello Nebula!\\\"123\\\"\";\n</code></pre> <p>Note</p> <p>When single or double quotes need to be nested in a string, use a backslash () to escape. For example:</p> <pre><code>RETURN \"\\\"NebulaGraph is amazing,\\\" the user says.\";\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#statement_termination","title":"Statement termination","text":"<ol> <li> <p>End the nGQL statements with an English semicolon (;).</p> <p>Not recommended:</p> <pre><code>FETCH PROP ON player \"player100\" YIELD properties(vertex)\n</code></pre> <p>Recommended:</p> <pre><code>FETCH PROP ON player \"player100\" YIELD properties(vertex);\n</code></pre> </li> <li> <p>Use a pipe (|) to separate a composite statement, and end the statement with an English semicolon at the end of the last line. Using an English semicolon before a pipe will cause the statement to fail.</p> <p>Not supported:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow \\\nYIELD dst(edge) AS id; | \\\nGO FROM $-.id \\\nOVER serve \\\nYIELD properties($$).name AS Team, properties($^).name AS Player;\n</code></pre> <p>Supported:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow \\\nYIELD dst(edge) AS id | \\\nGO FROM $-.id \\\nOVER serve \\\nYIELD properties($$).name AS Team, properties($^).name AS Player;\n</code></pre> </li> <li> <p>In a composite statement that contains user-defined variables, use an English semicolon to end the statements that define the variables. If you do not follow the rules to add a semicolon or use a pipe to end the composite statement, the execution will fail.</p> <p>Not supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> <p>Not supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id | \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> <p>Supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id; \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/","title":"CREATE TAG","text":"<p><code>CREATE TAG</code> creates a tag with the given name in a graph space.</p>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Tags in nGQL are similar to labels in openCypher. But they are also quite different. For example, the ways to create them are different.</p> <ul> <li>In openCypher, labels are created together with vertices in <code>CREATE</code> statements.</li> <li>In nGQL, tags are created separately using <code>CREATE TAG</code> statements. Tags in nGQL are more like tables in MySQL.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>CREATE TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#syntax","title":"Syntax","text":"<p>To create a tag in a specific graph space, you must specify the current working space with the <code>USE</code> statement.</p> <pre><code>CREATE TAG [IF NOT EXISTS] &lt;tag_name&gt;\n    (\n      &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']\n      [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] \n    )\n    [TTL_DURATION = &lt;ttl_duration&gt;]\n    [TTL_COL = &lt;prop_name&gt;]\n    [COMMENT = '&lt;comment&gt;'];\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the tag that you want to create exists. If it does not exist, a new one will be created. The tag existence detection here only compares the tag names (excluding properties). <code>&lt;tag_name&gt;</code> 1. Each tag name in the graph space must be unique. 2. Tag names cannot be modified after they are set.3. Tag names cannot start with a number; they support 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc., but do not support special characters other than underscores. To use special characters, reserved keywords, or start with a number in a tag name, enclose them in backticks (`), and do not use periods (<code>.</code>) in a tag name. For more information, see Keywords and reserved words. Note: If you name a tag in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). <code>&lt;prop_name&gt;</code> The name of the property. It must be unique for each tag. The rules for permitted property names are the same as those for tag names. <code>&lt;data_type&gt;</code> Shows the data type of each property. For a full description of the property data types, see Data types and Boolean. <code>NULL \\| NOT NULL</code> Specifies if the property supports <code>NULL | NOT NULL</code>. The default value is <code>NULL</code>. <code>DEFAULT</code> Specifies a default value for a property. The default value can be a literal value or an expression supported by NebulaGraph. If no value is specified, the default value is used when inserting a new vertex. <code>COMMENT</code> The remarks of a certain property or the tag itself. The maximum length is 256 bytes. By default, there will be no comments on a tag. <code>TTL_DURATION</code> Specifies the life cycle for the property. The property that exceeds the specified TTL expires. The expiration threshold is the <code>TTL_COL</code> value plus the <code>TTL_DURATION</code>. The default value of <code>TTL_DURATION</code> is <code>0</code>. It means the data never expires. <code>TTL_COL</code> Specifies the property to set a timeout on. The data type of the property must be <code>int</code> or <code>timestamp</code>. A tag can only specify one field as <code>TTL_COL</code>. For more information on TTL, see TTL options."},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int);\n\n# The following example creates a tag with no properties.\nnebula&gt; CREATE TAG IF NOT EXISTS no_property();\u00a0\n\n# The following example creates a tag with a default value.\nnebula&gt; CREATE TAG IF NOT EXISTS player_with_default(name string, age int DEFAULT 20);\n\n# In the following example, the TTL of the create_time field is set to be 100 seconds.\nnebula&gt; CREATE TAG IF NOT EXISTS woman(name string, age int, \\\n        married bool, salary double, create_time timestamp) \\\n        TTL_DURATION = 100, TTL_COL = \"create_time\";\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Trying to use a newly created tag may fail because the creation of the tag is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <p>To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/","title":"DROP TAG","text":"<p><code>DROP TAG</code> drops a tag with the given name in the current working graph space.</p> <p>A vertex can have one or more tags.</p> <ul> <li>If a vertex has only one tag, the vertex CANNOT be accessed after you drop it. The vertex will be dropped in the next compaction. But its edges are available, this operation will result in dangling edges.</li> </ul> <ul> <li>If a vertex has multiple tags, the vertex is still accessible after you drop one of them. But all the properties defined by this dropped tag CANNOT be accessed.</li> </ul> <p>This operation only deletes the Schema data. All the files or directories in the disk will not be deleted directly until the next compaction.</p> <p>Compatibility</p> <p>In NebulaGraph 2.0.0, inserting vertex without tag is not supported by default. If you want to use the vertex without tags, add <code>--graph_use_vertex_key=true</code> to the configuration files (<code>nebula-graphd.conf</code>) of all Graph services in the cluster, and add <code>--use_vertex_key=true</code> to the configuration files (<code>nebula-storaged.conf</code>) of all Storage services in the cluster.</p>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/#prerequisites","title":"Prerequisites","text":"<ul> <li>Running the <code>DROP TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you drop a tag, make sure that the tag does not have any indexes. Otherwise, the conflict error (<code>[ERROR (-1005)]: Conflict!</code>) will be returned when you run the <code>DROP TAG</code> statement. To drop an index, see DROP INDEX.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/#syntax","title":"Syntax","text":"<pre><code>DROP TAG [IF EXISTS] &lt;tag_name&gt;;\n</code></pre> <ul> <li><code>IF NOT EXISTS</code>: Detects if the tag that you want to drop exists. Only when it exists will it be dropped.</li> </ul> <ul> <li><code>tag_name</code>: Specifies the tag name that you want to drop. You can drop only one tag in one statement.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS test(p1 string, p2 int);\nnebula&gt; DROP TAG test;\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/","title":"ALTER TAG","text":"<p><code>ALTER TAG</code> alters the structure of a tag with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration.</p>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#notes","title":"Notes","text":"<ul> <li>Running the <code>ALTER TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you alter properties for a tag, make sure that the properties are not indexed. If the properties contain any indexes, the conflict error <code>[ERROR (-1005)]: Conflict!</code> will occur when you <code>ALTER TAG</code>. For more information on dropping an index, see DROP INDEX.</li> </ul> <ul> <li>The property name must be unique in a tag. If you add a property with the same name as an existing property or a dropped property, the operation fails.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#syntax","title":"Syntax","text":"<pre><code>ALTER TAG &lt;tag_name&gt;\n    &lt;alter_definition&gt; [[, alter_definition] ...]\n    [ttl_definition [, ttl_definition] ... ]\n    [COMMENT '&lt;comment&gt;'];\n\nalter_definition:\n| ADD    (prop_name data_type [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'])\n| DROP   (prop_name)\n| CHANGE (prop_name data_type [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'])\n\nttl_definition:\n    TTL_DURATION = ttl_duration, TTL_COL = prop_name\n</code></pre> <ul> <li><code>tag_name</code>: Specifies the tag name that you want to alter. You can alter only one tag in one statement. Before you alter a tag, make sure that the tag exists in the current working graph space. If the tag does not exist, an error will occur when you alter it.</li> </ul> <ul> <li>Multiple <code>ADD</code>, <code>DROP</code>, and <code>CHANGE</code> clauses are permitted in a single <code>ALTER TAG</code> statement, separated by commas.</li> </ul> <ul> <li>When a property value is set to <code>NOT NULL</code> using <code>ADD</code> or <code>CHANGE</code>, a default value must be specified for the property, that is, the value of <code>DEFAULT</code> must be specified.</li> </ul> <ul> <li> <p>When using <code>CHANGE</code> to modify the data type of a property:</p> <ul> <li>Only the length of a <code>FIXED_STRING</code> or an <code>INT</code> can be increased. The length of a <code>STRING</code> or an <code>INT</code> cannot be decreased.</li> </ul> <ul> <li>Only the data type conversions from FIXED_STRING to STRING and from FLOAT to DOUBLE are allowed.</li> </ul> </li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t1 (p1 string, p2 int);\nnebula&gt; ALTER TAG t1 ADD (p3 int32, fixed_string(10));\nnebula&gt; ALTER TAG t1 TTL_DURATION = 2, TTL_COL = \"p2\";\nnebula&gt; ALTER TAG t1 COMMENT = 'test1';\nnebula&gt; ALTER TAG t1 ADD (p5 double NOT NULL DEFAULT 0.4 COMMENT 'p5') COMMENT='test2';\n// Change the data type of p3 in the TAG t1 from INT32 to INT64, and that of p4 from FIXED_STRING(10) to STRING.\nnebula&gt; ALTER TAG t1 CHANGE (p3 int64, p4 string);\n[ERROR(-1005)]: Unsupported!\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Trying to use a newly altered tag may fail because the alteration of the tag is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <p>To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"3.ngql-guide/10.tag-statements/4.show-tags/","title":"SHOW TAGS","text":"<p>The <code>SHOW TAGS</code> statement shows the name of all tags in the current graph space.</p> <p>You do not need any privileges for the graph space to run the <code>SHOW TAGS</code> statement. But the returned results are different based on role privileges.</p>"},{"location":"3.ngql-guide/10.tag-statements/4.show-tags/#syntax","title":"Syntax","text":"<pre><code>SHOW TAGS;\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/4.show-tags/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAGS;\n+----------+\n| Name     |\n+----------+\n| \"player\" |\n| \"team\"   |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/","title":"DESCRIBE TAG","text":"<p><code>DESCRIBE TAG</code> returns the information about a tag with the given name in a graph space, such as field names, data type, and so on.</p>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/#prerequisite","title":"Prerequisite","text":"<p>Running the <code>DESCRIBE TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/#syntax","title":"Syntax","text":"<pre><code>DESC[RIBE] TAG &lt;tag_name&gt;;\n</code></pre> <p>You can use <code>DESC</code> instead of <code>DESCRIBE</code> for short.</p>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/#example","title":"Example","text":"<pre><code>nebula&gt; DESCRIBE TAG player;\n+--------+----------+-------+---------+---------+\n| Field  | Type     | Null  | Default | Comment |\n+--------+----------+-------+---------+---------+\n| \"name\" | \"string\" | \"YES\" |         |         |\n| \"age\"  | \"int64\"  | \"YES\" |         |         |\n+--------+----------+-------+---------+---------+\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/","title":"DELETE TAG","text":"<p><code>DELETE TAG</code> deletes a tag with the given name on a specified vertex.</p>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>DELETE TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/#syntax","title":"Syntax","text":"<pre><code>DELETE TAG &lt;tag_name_list&gt; FROM &lt;VID_list&gt;;\n</code></pre> <ul> <li><code>tag_name_list</code>: The names of the tags you want to delete. Multiple tags are separated with commas (,). <code>*</code> means all tags.</li> </ul> <ul> <li><code>VID</code>: The VIDs of the vertices from which you want to delete the tags. Multiple VIDs are separated with commas (,). </li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS test1(p1 string, p2 int);\nnebula&gt; CREATE TAG IF NOT EXISTS test2(p3 string, p4 int);\nnebula&gt; INSERT VERTEX test1(p1, p2),test2(p3, p4) VALUES \"test\":(\"123\", 1, \"456\", 2);\nnebula&gt; FETCH PROP ON * \"test\" YIELD vertex AS v;\n+------------------------------------------------------------+\n| v                                                          |\n+------------------------------------------------------------+\n| (\"test\" :test1{p1: \"123\", p2: 1} :test2{p3: \"456\", p4: 2}) |\n+------------------------------------------------------------+\nnebula&gt; DELETE TAG test1 FROM \"test\";\nnebula&gt; FETCH PROP ON * \"test\" YIELD vertex AS v;\n+-----------------------------------+\n| v                                 |\n+-----------------------------------+\n| (\"test\" :test2{p3: \"456\", p4: 2}) |\n+-----------------------------------+\nnebula&gt; DELETE TAG * FROM \"test\";\nnebula&gt; FETCH PROP ON * \"test\" YIELD vertex AS v;\n+---+\n| v |\n+---+\n+---+\n</code></pre> <p>Compatibility</p> <ul> <li>In openCypher, you can use the statement <code>REMOVE v:LABEL</code> to delete the tag <code>LABEL</code> of the vertex <code>v</code>.</li> <li><code>DELETE TAG</code> and <code>DROP TAG</code> have the same semantics but different syntax. In nGQL, use <code>DELETE TAG</code>.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/improve-query-by-tag-index/","title":"Add and delete tags","text":"<p>OpenCypher has the features of <code>SET label</code> and <code>REMOVE label</code> to speed up the process of querying or labeling.</p> <p>NebulaGraph achieves the same operations by creating and inserting tags to an existing vertex, which can quickly query vertices based on the tag name. Users can also run <code>DELETE TAG</code> to delete some vertices that are no longer needed.</p>"},{"location":"3.ngql-guide/10.tag-statements/improve-query-by-tag-index/#examples","title":"Examples","text":"<p>For example, in the <code>basketballplayer</code> data set, some basketball players are also team shareholders. Users can create an index for the shareholder tag <code>shareholder</code> for quick search. If the player is no longer a shareholder, users can delete the shareholder tag of the corresponding player by <code>DELETE TAG</code>.</p> <pre><code>//This example creates the shareholder tag and index.\nnebula&gt; CREATE TAG IF NOT EXISTS shareholder();\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS shareholder_tag on shareholder();\n\n//This example adds a tag on the vertex.\nnebula&gt; INSERT VERTEX shareholder() VALUES \"player100\":();\nnebula&gt; INSERT VERTEX shareholder() VALUES \"player101\":();\n\n//This example queries all the shareholders.\nnebula&gt; MATCH (v:shareholder) RETURN v;\n+--------------------------------------------------------------------+\n| v                                                                  |\n+--------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :shareholder{})  |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"} :shareholder{}) |\n+--------------------------------------------------------------------+\n\nnebula&gt; LOOKUP ON shareholder YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n+-------------+\n\n//In this example, the \"player100\" is no longer a shareholder.\nnebula&gt; DELETE TAG shareholder FROM \"player100\";\nnebula&gt; LOOKUP ON shareholder YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player101\" |\n+-------------+\n</code></pre> <p>Note</p> <p>If the index is created after inserting the test data, use the <code>REBUILD TAG INDEX &lt;index_name_list&gt;;</code> statement to rebuild the index.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/","title":"CREATE EDGE","text":"<p><code>CREATE EDGE</code> creates an edge type with the given name in a graph space.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Edge types in nGQL are similar to relationship types in openCypher. But they are also quite different. For example, the ways to create them are different.</p> <ul> <li>In openCypher, relationship types are created together with vertices in <code>CREATE</code> statements.</li> <li>In nGQL, edge types are created separately using <code>CREATE EDGE</code> statements. Edge types in nGQL are more like tables in MySQL.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>CREATE EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#syntax","title":"Syntax","text":"<p>To create an edge type in a specific graph space, you must specify the current working space with the <code>USE</code> statement.</p> <pre><code>CREATE EDGE [IF NOT EXISTS] &lt;edge_type_name&gt;\n    (\n      &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']\n      [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] \n    )\n    [TTL_DURATION = &lt;ttl_duration&gt;]\n    [TTL_COL = &lt;prop_name&gt;]\n    [COMMENT = '&lt;comment&gt;'];\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the edge type that you want to create exists. If it does not exist, a new one will be created. The edge type existence detection here only compares the edge type names (excluding properties). <code>&lt;edge_type_name&gt;</code> 1. The edge type name must be unique in a graph space. 2. Once the edge type name is set, it can not be altered. 3. Edge type names cannot start with a number; they support 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc., but do not include special characters other than underscores. To use special characters, reserved keywords or starting with a number, quote them with backticks (`) and cannot use periods (<code>.</code>). For more information, see Keywords and reserved words. Note: If you name an edge type in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). <code>&lt;prop_name&gt;</code> The name of the property. It must be unique for each edge type. The rules for permitted property names are the same as those for edge type names. <code>&lt;data_type&gt;</code> Shows the data type of each property. For a full description of the property data types, see Data types and Boolean. <code>NULL \\| NOT NULL</code> Specifies if the property supports <code>NULL | NOT NULL</code>. The default value is <code>NULL</code>. <code>DEFAULT</code> must be specified if <code>NOT NULL</code> is set. <code>DEFAULT</code> Specifies a default value for a property. The default value can be a literal value or an expression supported by NebulaGraph. If no value is specified, the default value is used when inserting a new edge. <code>COMMENT</code> The remarks of a certain property or the edge type itself. The maximum length is 256 bytes. By default, there will be no comments on an edge type. <code>TTL_DURATION</code> Specifies the life cycle for the property. The property that exceeds the specified TTL expires. The expiration threshold is the <code>TTL_COL</code> value plus the <code>TTL_DURATION</code>. The default value of <code>TTL_DURATION</code> is <code>0</code>. It means the data never expires. <code>TTL_COL</code> Specifies the property to set a timeout on. The data type of the property must be <code>int</code> or <code>timestamp</code>. An edge type can only specify one field as <code>TTL_COL</code>. For more information on TTL, see TTL options."},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS follow(degree int);\n\n# The following example creates an edge type with no properties.\nnebula&gt; CREATE EDGE IF NOT EXISTS no_property();\n\n# The following example creates an edge type with a default value.\nnebula&gt; CREATE EDGE IF NOT EXISTS follow_with_default(degree int DEFAULT 20);\n\n# In the following example, the TTL of the p2 field is set to be 100 seconds.\nnebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int, p3 timestamp) \\\n        TTL_DURATION = 100, TTL_COL = \"p2\";\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/","title":"DROP EDGE","text":"<p><code>DROP EDGE</code> drops an edge type with the given name in a graph space.</p> <p>An edge can have only one edge type. After you drop it, the edge CANNOT be accessed. The edge will be deleted in the next compaction.</p> <p>This operation only deletes the Schema data. All the files or directories in the disk will not be deleted directly until the next compaction.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/#prerequisites","title":"Prerequisites","text":"<ul> <li>Running the <code>DROP EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you drop an edge type, make sure that the edge type does not have any indexes. Otherwise, the conflict error (<code>[ERROR (-1005)]: Conflict!</code>) will be returned. To drop an index, see DROP INDEX.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/#syntax","title":"Syntax","text":"<pre><code>DROP EDGE [IF EXISTS] &lt;edge_type_name&gt;\n</code></pre> <ul> <li><code>IF NOT EXISTS</code>: Detects if the edge type that you want to drop exists. Only when it exists will it be dropped.</li> </ul> <ul> <li><code>edge_type_name</code>: Specifies the edge type name that you want to drop. You can drop only one edge type in one statement.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);\nnebula&gt; DROP EDGE e1;\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/","title":"ALTER EDGE","text":"<p><code>ALTER EDGE</code> alters the structure of an edge type with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#notes","title":"Notes","text":"<ul> <li>Running the <code>ALTER EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you alter properties for an edge type, make sure that the properties are not indexed. If the properties contain any indexes, the conflict error <code>[ERROR (-1005)]: Conflict!</code> will occur when you <code>ALTER EDGE</code>. For more information on dropping an index, see DROP INDEX.</li> </ul> <ul> <li>The property name must be unique in an edge type. If you add a property with the same name as an existing property or a dropped property, the operation fails.</li> </ul> <ul> <li>Only the length of a <code>FIXED_STRING</code> or an <code>INT</code> can be increased.</li> </ul> <ul> <li>Only the data type conversions from FIXED_STRING to STRING and from FLOAT to DOUBLE are allowed.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#syntax","title":"Syntax","text":"<pre><code>ALTER EDGE &lt;edge_type_name&gt;\n    &lt;alter_definition&gt; [, alter_definition] ...]\n    [ttl_definition [, ttl_definition] ... ]\n    [COMMENT = '&lt;comment&gt;'];\n\nalter_definition:\n| ADD    (prop_name data_type)\n| DROP   (prop_name)\n| CHANGE (prop_name data_type)\n\nttl_definition:\n    TTL_DURATION = ttl_duration, TTL_COL = prop_name\n</code></pre> <ul> <li><code>edge_type_name</code>: Specifies the edge type name that you want to alter. You can alter only one edge type in one statement. Before you alter an edge type, make sure that the edge type exists in the graph space. If the edge type does not exist, an error occurs when you alter it.</li> </ul> <ul> <li>Multiple <code>ADD</code>, <code>DROP</code>, and <code>CHANGE</code> clauses are permitted in a single <code>ALTER EDGE</code> statement, separated by commas.</li> </ul> <ul> <li>When a property value is set to <code>NOT NULL</code> using <code>ADD</code> or <code>CHANGE</code>, a default value must be specified for the property, that is, the value of <code>DEFAULT</code> must be specified.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);\nnebula&gt; ALTER EDGE e1 ADD (p3 int, p4 string);\nnebula&gt; ALTER EDGE e1 TTL_DURATION = 2, TTL_COL = \"p2\";\nnebula&gt; ALTER EDGE e1 COMMENT = 'edge1';\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Trying to use a newly altered edge type may fail because the alteration of the edge type is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <p>To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/4.show-edges/","title":"SHOW EDGES","text":"<p><code>SHOW EDGES</code> shows all edge types in the current graph space.</p> <p>You do not need any privileges for the graph space to run the <code>SHOW EDGES</code> statement. But the returned results are different based on role privileges.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/4.show-edges/#syntax","title":"Syntax","text":"<pre><code>SHOW EDGES;\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/4.show-edges/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW EDGES;\n+----------+\n| Name     |\n+----------+\n| \"follow\" |\n| \"serve\"  |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/","title":"DESCRIBE EDGE","text":"<p><code>DESCRIBE EDGE</code> returns the information about an edge type with the given name in a graph space, such as field names, data type, and so on.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>DESCRIBE EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/#syntax","title":"Syntax","text":"<pre><code>DESC[RIBE] EDGE &lt;edge_type_name&gt;\n</code></pre> <p>You can use <code>DESC</code> instead of <code>DESCRIBE</code> for short.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/#example","title":"Example","text":"<pre><code>nebula&gt; DESCRIBE EDGE follow;\n+----------+---------+-------+---------+---------+\n| Field    | Type    | Null  | Default | Comment |\n+----------+---------+-------+---------+---------+\n| \"degree\" | \"int64\" | \"YES\" |         |         |\n+----------+---------+-------+---------+---------+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/","title":"INSERT VERTEX","text":"<p>The <code>INSERT VERTEX</code> statement inserts one or more vertices into a graph space in NebulaGraph.</p>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>INSERT VERTEX</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#syntax","title":"Syntax","text":"<pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES VID: ([prop_value_list])\n\ntag_props:\n  tag_name ([prop_name_list])\n\nprop_name_list:\n   [prop_name [, prop_name] ...]\n\nprop_value_list:\n   [prop_value [, prop_value] ...] \n</code></pre> <ul> <li> <p><code>IF NOT EXISTS</code> detects if the VID that you want to insert exists. If it does not exist, a new one will be inserted.</p> <p>Note</p> <ul> <li><code>IF NOT EXISTS</code> only compares the names of the VID and the tag (excluding properties).</li> <li><code>IF NOT EXISTS</code> will read to check whether the data exists, which will have a significant impact on performance.</li> </ul> </li> </ul> <ul> <li> <p><code>tag_name</code> denotes the tag (vertex type), which must be created before <code>INSERT VERTEX</code>. For more information, see CREATE TAG.</p> <p>Caution</p> <p>NebulaGraph 2.0.0 supports inserting vertices without tags.</p> <p>Compatibility</p> <p>In NebulaGraph 2.0.0, inserting vertex without tag is not supported by default. If you want to use the vertex without tags, add <code>--graph_use_vertex_key=true</code> to the configuration files (<code>nebula-graphd.conf</code>) of all Graph services in the cluster, add <code>--use_vertex_key=true</code> to the configuration files (<code>nebula-storaged.conf</code>) of all Storage services in the cluster. An example of a command to insert a vertex without tag is <code>INSERT VERTEX VALUES \"1\":();</code>.</p> </li> </ul> <ul> <li><code>prop_name_list</code> contains the names of the properties on the tag.</li> </ul> <ul> <li><code>VID</code> is the vertex ID. In NebulaGraph 2.0, string and integer VID types are supported. The VID type is set when a graph space is created. For more information, see CREATE SPACE.</li> </ul> <ul> <li><code>prop_value_list</code> must provide the property values according to the <code>prop_name_list</code>. When the <code>NOT NULL</code> constraint is set for a given property, an error is returned if no property is given. When the default value for a property is <code>NULL</code>, you can omit to specify the property value. For details, see CREATE TAG.</li> </ul> <p>Caution</p> <p><code>INSERT VERTEX</code> and <code>CREATE</code> have different semantics.</p> <ul> <li>The semantics of <code>INSERT VERTEX</code> is closer to that of INSERT in NoSQL (key-value), or <code>UPSERT</code> (<code>UPDATE</code> or <code>INSERT</code>) in SQL.</li> <li>When two INSERT statements (neither uses <code>IF NOT EXISTS</code>) with the same <code>VID</code> and <code>TAG</code> are operated at the same time, the latter INSERT will overwrite the former.</li> <li>When two INSERT statements with the same <code>VID</code> but different <code>TAGS</code> are operated at the same time, the operation of different tags will not overwrite each other.</li> </ul> <p>Examples are as follows.</p>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#examples","title":"Examples","text":"<pre><code># Insert a vertex without tag.\nnebula&gt; INSERT VERTEX VALUES \"1\":();\n\n# The following examples create tag t1 with no property and inserts vertex \"10\" with no property.\nnebula&gt; CREATE TAG IF NOT EXISTS t1();                   \nnebula&gt; INSERT VERTEX t1() VALUES \"10\":(); \n</code></pre> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t2 (name string, age int);                \nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n1\", 12);\n\n#  In the following example, the insertion fails because \"a13\" is not int.\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"12\":(\"n1\", \"a13\"); \n\n# The following example inserts two vertices at one time.\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8); \n</code></pre> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t3(p1 int);\nnebula&gt; CREATE TAG IF NOT EXISTS t4(p2 string);\n\n# The following example inserts vertex \"21\" with two tags.\nnebula&gt; INSERT VERTEX t3 (p1), t4(p2) VALUES \"21\": (321, \"hello\");\n</code></pre> <p>A vertex can be inserted/written with new values multiple times. Only the last written values can be read.</p> <pre><code># The following examples insert vertex \"11\" with new values for multiple times.\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n2\", 13);\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n3\", 14);\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n4\", 15);\nnebula&gt; FETCH PROP ON t2 \"11\" YIELD properties(vertex);\n+-----------------------+\n| properties(VERTEX)    |\n+-----------------------+\n| {age: 15, name: \"n4\"} |\n+-----------------------+\n</code></pre> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t5(p1 fixed_string(5) NOT NULL, p2 int, p3 int DEFAULT NULL);\nnebula&gt; INSERT VERTEX t5(p1, p2, p3) VALUES \"001\":(\"Abe\", 2, 3);\n\n# In the following example, the insertion fails because the value of p1 cannot be NULL.\nnebula&gt; INSERT VERTEX t5(p1, p2, p3) VALUES \"002\":(NULL, 4, 5);\n[ERROR (-1009)]: SemanticError: No schema found for `t5'\n\n# In the following example, the value of p3 is the default NULL.\nnebula&gt; INSERT VERTEX t5(p1, p2) VALUES \"003\":(\"cd\", 5);\nnebula&gt; FETCH PROP ON t5 \"003\" YIELD properties(vertex);\n+---------------------------------+\n| properties(VERTEX)              |\n+---------------------------------+\n| {p1: \"cd\", p2: 5, p3: __NULL__} |\n+---------------------------------+\n\n# In the following example, the allowed maximum length of p1 is 5.\nnebula&gt; INSERT VERTEX t5(p1, p2) VALUES \"004\":(\"shalalalala\", 4);\nnebula&gt; FETCH PROP on t5 \"004\" YIELD properties(vertex);\n+------------------------------------+\n| properties(VERTEX)                 |\n+------------------------------------+\n| {p1: \"shala\", p2: 4, p3: __NULL__} |\n+------------------------------------+\n</code></pre> <p>If you insert a vertex that already exists with <code>IF NOT EXISTS</code>, there will be no modification.</p> <pre><code># The following example inserts vertex \"1\".\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"1\":(\"n2\", 13);\n# Modify vertex \"1\" with IF NOT EXISTS. But there will be no modification as vertex \"1\" already exists.\nnebula&gt; INSERT VERTEX IF NOT EXISTS t2 (name, age) VALUES \"1\":(\"n3\", 14);\nnebula&gt; FETCH PROP ON t2 \"1\" YIELD properties(vertex);\n+-----------------------+\n| properties(VERTEX)    |\n+-----------------------+\n| {age: 13, name: \"n2\"} |\n+-----------------------+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/","title":"UPDATE VERTEX","text":"<p>The <code>UPDATE VERTEX</code> statement updates properties on tags of a vertex.</p> <p>In NebulaGraph, <code>UPDATE VERTEX</code> supports compare-and-set (CAS).</p> <p>Note</p> <p>An <code>UPDATE VERTEX</code> statement can only update properties on ONE TAG of a vertex.</p>"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/#syntax","title":"Syntax","text":"<pre><code>UPDATE VERTEX ON &lt;tag_name&gt; &lt;vid&gt;\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;output&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;tag_name&gt;</code> Yes Specifies the tag of the vertex. The properties to be updated must be on this tag. <code>ON player</code> <code>&lt;vid&gt;</code> Yes Specifies the ID of the vertex to be updated. <code>\"player100\"</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET age = age +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. If <code>&lt;condition&gt;</code> evaluates to <code>false</code>, the <code>SET</code> clause will not take effect. <code>WHEN name == \"Tim\"</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD name AS Name</code>"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/#example","title":"Example","text":"<pre><code>// This query checks the properties of vertex \"player101\".\nnebula&gt; FETCH PROP ON player \"player101\" YIELD properties(vertex);\n+--------------------------------+\n| properties(VERTEX)             |\n+--------------------------------+\n| {age: 36, name: \"Tony Parker\"} |\n+--------------------------------+\n\n// This query updates the age property and returns name and the new age.\nnebula&gt; UPDATE VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Tony Parker\" \\\n        YIELD name AS Name, age AS Age;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 38  |\n+---------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/","title":"UPSERT VERTEX","text":"<p>The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT VERTEX</code> to update the properties of a vertex if it exists or insert a new vertex if it does not exist.</p> <p>Note</p> <p>An <code>UPSERT VERTEX</code> statement can only update the properties on ONE TAG of a vertex.</p> <p>The performance of <code>UPSERT</code> is much lower than that of <code>INSERT</code> because <code>UPSERT</code> is a read-modify-write serialization operation at the partition level.</p> <p>Danger</p> <p>Don't use <code>UPSERT</code> for scenarios with highly concurrent writes. You can use <code>UPDATE</code> or <code>INSERT</code> instead.</p>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#syntax","title":"Syntax","text":"<pre><code>UPSERT VERTEX ON &lt;tag&gt; &lt;vid&gt;\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;output&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;tag&gt;</code> Yes Specifies the tag of the vertex. The properties to be updated must be on this tag. <code>ON player</code> <code>&lt;vid&gt;</code> Yes Specifies the ID of the vertex to be updated or inserted. <code>\"player100\"</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET age = age +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. <code>WHEN name == \"Tim\"</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD name AS Name</code>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#insert_a_vertex_if_it_does_not_exist","title":"Insert a vertex if it does not exist","text":"<p>If a vertex does not exist, it is created no matter the conditions in the <code>WHEN</code> clause are met or not, and the <code>SET</code> clause always takes effect. The property values of the new vertex depend on:</p> <ul> <li>How the <code>SET</code> clause is defined.</li> </ul> <ul> <li>Whether the property has a default value.</li> </ul> <p>For example, if:</p> <ul> <li>The vertex to be inserted will have properties <code>name</code> and <code>age</code> based on the tag <code>player</code>.</li> </ul> <ul> <li>The <code>SET</code> clause specifies that <code>age = 30</code>.</li> </ul> <p>Then the property values in different cases are listed as follows:</p> Are <code>WHEN</code> conditions met If properties have default values Value of <code>name</code> Value of <code>age</code> Yes Yes The default value <code>30</code> Yes No <code>NULL</code> <code>30</code> No Yes The default value <code>30</code> No No <code>NULL</code> <code>30</code> <p>Here are some examples:</p> <pre><code>// This query checks if the following three vertices exist. The result \"Empty set\" indicates that the vertices do not exist.\nnebula&gt; FETCH PROP ON * \"player666\", \"player667\", \"player668\" YIELD properties(vertex);\n+--------------------+\n| properties(VERTEX) |\n+--------------------+\n+--------------------+\nEmpty set\n\nnebula&gt; UPSERT VERTEX ON player \"player666\" \\\n        SET age = 30 \\\n        WHEN name == \"Joe\" \\\n        YIELD name AS Name, age AS Age;\n+----------+----------+\n| Name     | Age      |\n+----------+----------+\n| __NULL__ | 30       |\n+----------+----------+\n\nnebula&gt; UPSERT VERTEX ON player \"player666\" \\\n        SET age = 31 \\\n        WHEN name == \"Joe\" \\\n        YIELD name AS Name, age AS Age;\n+----------+-----+\n| Name     | Age |\n+----------+-----+\n| __NULL__ | 30  |\n+----------+-----+\n\nnebula&gt; UPSERT VERTEX ON player \"player667\" \\\n        SET age = 31 \\\n        YIELD name AS Name, age AS Age;\n+----------+-----+\n| Name     | Age |\n+----------+-----+\n| __NULL__ | 31  |\n+----------+-----+\n\nnebula&gt; UPSERT VERTEX ON player \"player668\" \\\n        SET name = \"Amber\", age = age + 1 \\\n        YIELD name AS Name, age AS Age;\n+---------+----------+\n| Name    | Age      |\n+---------+----------+\n| \"Amber\" | __NULL__ |\n+---------+----------+\n</code></pre> <p>In the last query of the preceding examples, since <code>age</code> has no default value, when the vertex is created, <code>age</code> is <code>NULL</code>, and <code>age = age + 1</code> does not take effect. But if <code>age</code> has a default value, <code>age = age + 1</code> will take effect. For example:</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player_with_default(name string, age int DEFAULT 20);\nExecution succeeded\n\nnebula&gt; UPSERT VERTEX ON player_with_default \"player101\" \\\n        SET age = age + 1 \\\n        YIELD name AS Name, age AS Age;\n\n+----------+-----+\n| Name     | Age |\n+----------+-----+\n| __NULL__ | 21  |\n+----------+-----+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#update_a_vertex_if_it_exists","title":"Update a vertex if it exists","text":"<p>If the vertex exists and the <code>WHEN</code> conditions are met, the vertex is updated.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player101\" YIELD properties(vertex);\n+--------------------------------+\n| properties(VERTEX)             |\n+--------------------------------+\n| {age: 36, name: \"Tony Parker\"} |\n+--------------------------------+\n\nnebula&gt; UPSERT VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Tony Parker\" \\\n        YIELD name AS Name, age AS Age;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 38  |\n+---------------+-----+\n</code></pre> <p>If the vertex exists and the <code>WHEN</code> conditions are not met, the update does not take effect.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player101\" YIELD properties(vertex);\n+--------------------------------+\n| properties(VERTEX)             |\n+--------------------------------+\n| {age: 38, name: \"Tony Parker\"} |\n+--------------------------------+\n\nnebula&gt; UPSERT VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Someone else\" \\\n        YIELD name AS Name, age AS Age;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 38  |\n+---------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/","title":"DELETE VERTEX","text":"<p>By default, the <code>DELETE VERTEX</code> statement deletes vertices but the incoming and outgoing edges of the vertices.</p> <p>Compatibility</p> <ul> <li>NebulaGraph 2.x deletes vertices and their incoming and outgoing edges.</li> </ul> <ul> <li>NebulaGraph 2.0.0 only deletes the vertices, and does not delete the related outgoing and incoming edges of the vertices. At this time, there will be dangling edges by default.</li> </ul> <p>The <code>DELETE VERTEX</code> statement deletes one vertex or multiple vertices at a time. You can use <code>DELETE VERTEX</code> together with pipes. For more information about pipe, see Pipe operator.</p> <p>Note</p> <ul> <li><code>DELETE VERTEX</code> deletes vertices directly.</li> </ul> <ul> <li><code>DELETE TAG</code> deletes a tag with the given name on a specified vertex.</li> </ul>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#syntax","title":"Syntax","text":"<pre><code>DELETE VERTEX &lt;vid&gt; [, &lt;vid&gt; ...] [WITH EDGE];\n</code></pre> <ul> <li>WITH EDGE: deletes vertices and the related incoming and outgoing edges of the vertices.</li> </ul>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#examples","title":"Examples","text":"<p>This query deletes the vertex whose ID is \"team1\".</p> <pre><code># Delete the vertex whose VID is `team1` but the related incoming and outgoing edges are not deleted.\nnebula&gt; DELETE VERTEX \"team1\";\n\n# Delete the vertex whose VID is `team1` and the related incoming and outgoing edges.\nnebula&gt; DELETE VERTEX \"team1\" WITH EDGE;\n</code></pre> <p>This query shows that you can use <code>DELETE VERTEX</code> together with pipe to delete vertices.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER serve WHERE properties(edge).start_year == \"2021\" YIELD dst(edge) AS id | DELETE VERTEX $-.id;\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#process_of_deleting_vertices","title":"Process of deleting vertices","text":"<p>Once NebulaGraph deletes the vertices, all edges (incoming and outgoing edges) of the target vertex will become dangling edges. When NebulaGraph deletes the vertices <code>WITH EDGE</code>, NebulaGraph traverses the incoming and outgoing edges related to the vertices and deletes them all. Then NebulaGraph deletes the vertices.</p> <p>Caution</p> <ul> <li>Atomic deletion is not supported during the entire process for now. Please retry when a failure occurs to avoid partial deletion, which will cause pendent edges.</li> <li>Deleting a supernode takes a lot of time. To avoid connection timeout before the deletion is complete, you can modify the parameter <code>--storage_client_timeout_ms</code> in <code>nebula-graphd.conf</code> to extend the timeout period.</li> </ul>"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/","title":"INSERT EDGE","text":"<p>The <code>INSERT EDGE</code> statement inserts an edge or multiple edges into a graph space from a source vertex (given by src_vid) to a destination vertex (given by dst_vid) with a specific rank in NebulaGraph.</p> <p>When inserting an edge that already exists, <code>INSERT EDGE</code> overrides the edge.</p>"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/#syntax","title":"Syntax","text":"<pre><code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES \n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; )\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...];\n\n&lt;prop_name_list&gt; ::=\n  [ &lt;prop_name&gt; [, &lt;prop_name&gt; ] ...]\n\n&lt;prop_value_list&gt; ::=\n  [ &lt;prop_value&gt; [, &lt;prop_value&gt; ] ...]\n</code></pre> <ul> <li> <p><code>IF NOT EXISTS</code> detects if the edge that you want to insert exists. If it does not exist, a new one will be inserted.</p> <p>Note</p> <ul> <li><code>IF NOT EXISTS</code> only detects whether  exist and does not detect whether the property values overlap. <li><code>IF NOT EXISTS</code> will read to check whether the data exists, which will have a significant impact on performance.</li> <ul> <li><code>&lt;edge_type&gt;</code> denotes the edge type, which must be created before <code>INSERT EDGE</code>. Only one edge type can be specified in this statement.</li> </ul> <ul> <li><code>&lt;prop_name_list&gt;</code> is the property name list in the given <code>&lt;edge_type&gt;</code>.</li> </ul> <ul> <li><code>src_vid</code> is the VID of the source vertex. It specifies the start of an edge.</li> </ul> <ul> <li><code>dst_vid</code> is the VID of the destination vertex. It specifies the end of an edge.</li> </ul> <ul> <li> <p><code>rank</code> is optional. It specifies the edge rank of the same edge type. The data type is <code>int</code>. If not specified, the default value is <code>0</code>. You can insert many edges with the same edge type, source vertex, and destination vertex by using different rank values.</p> <p>OpenCypher compatibility</p> <p>OpenCypher has no such concept as rank.</p> </li> </ul> <ul> <li><code>&lt;prop_value_list&gt;</code> must provide the value list according to <code>&lt;prop_name_list&gt;</code>. If the property values do not match the data type in the edge type, an error is returned. When the <code>NOT NULL</code> constraint is set for a given property, an error is returned if no property is given. When the default value for a property is <code>NULL</code>, you can omit to specify the property value. For details, see CREATE EDGE.</li> </ul>"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/#examples","title":"Examples","text":"<pre><code># The following example creates edge type e1 with no property and inserts an edge from vertex \"10\" to vertex \"11\" with no property.\nnebula&gt; CREATE EDGE IF NOT EXISTS e1();                 \nnebula&gt; INSERT EDGE e1 () VALUES \"10\"-&gt;\"11\":();  \n\n# The following example inserts an edge from vertex \"10\" to vertex \"11\" with no property. The edge rank is 1.\nnebula&gt; INSERT EDGE e1 () VALUES \"10\"-&gt;\"11\"@1:(); \n</code></pre> <pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS e2 (name string, age int); \nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 1);\n\n# The following example creates edge type e2 with two properties.\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \\\n        \"12\"-&gt;\"13\":(\"n1\", 1), \"13\"-&gt;\"14\":(\"n2\", 2); \n\n# In the following example, the insertion fails because \"a13\" is not int.\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", \"a13\");\n</code></pre> <p>An edge can be inserted/written with property values multiple times. Only the last written values can be read.</p> <pre><code>The following examples insert edge e2 with the new values for multiple times.\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 12);\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 13);\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 14);\nnebula&gt; FETCH PROP ON e2 \"11\"-&gt;\"13\" YIELD edge AS e;\n+-------------------------------------------+\n| e                                         |\n+-------------------------------------------+\n| [:e2 \"11\"-&gt;\"13\" @0 {age: 14, name: \"n1\"}] |\n+-------------------------------------------+\n</code></pre> <p>If you insert an edge that already exists with <code>IF NOT EXISTS</code>, there will be no modification.</p> <pre><code># The following example inserts edge e2 from vertex \"14\" to vertex \"15\".\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"14\"-&gt;\"15\"@1:(\"n1\", 12);\n# The following example alters the edge with IF NOT EXISTS. But there will be no alteration because edge e2 already exists.\nnebula&gt; INSERT EDGE IF NOT EXISTS e2 (name, age) VALUES \"14\"-&gt;\"15\"@1:(\"n2\", 13);\nnebula&gt; FETCH PROP ON e2 \"14\"-&gt;\"15\"@1 YIELD edge AS e;\n+-------------------------------------------+\n| e                                         |\n+-------------------------------------------+\n| [:e2 \"14\"-&gt;\"15\" @1 {age: 12, name: \"n1\"}] |\n+-------------------------------------------+\n</code></pre> <p>Note</p> <ul> <li>NebulaGraph 2.0.0 allows dangling edges. Therefore, you can write the edge before the source vertex or the destination vertex exists. At this time, you can get the (not written) vertex VID through <code>&lt;edgetype&gt;._src</code> or <code>&lt;edgetype&gt;._dst</code> (which is not recommended).</li> <li>Atomic operation is not guaranteed during the entire process for now. If it fails, please try again. Otherwise, partial writing will occur. At this time, the behavior of reading the data is undefined. For example, if multiple machines are involved in the write operation, only one of the forward and reverse edges of a single edge is written successfully, or only part of the edge is written successfully when multiple edges are inserted. In this case, an error will be returned, so please execute the command again.</li> <li>Concurrently writing the same edge will cause an <code>edge conflict</code> error, so please try again later.</li> <li>The inserting speed of an edge is about half that of a vertex. Because in the storaged process, the insertion of an edge involves two tasks, while the insertion of a vertex involves only one task.</li> </ul>"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/","title":"UPDATE EDGE","text":"<p>The <code>UPDATE EDGE</code> statement updates properties on an edge.</p> <p>In NebulaGraph, <code>UPDATE EDGE</code> supports compare-and-swap (CAS).</p>"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/#syntax","title":"Syntax","text":"<pre><code>UPDATE EDGE ON &lt;edge_type&gt;\n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@&lt;rank&gt;]\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;output&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;edge_type&gt;</code> Yes Specifies the edge type. The properties to be updated must be on this edge type. <code>ON serve</code> <code>&lt;src_vid&gt;</code> Yes Specifies the source vertex ID of the edge. <code>\"player100\"</code> <code>&lt;dst_vid&gt;</code> Yes Specifies the destination vertex ID of the edge. <code>\"team204\"</code> <code>&lt;rank&gt;</code> No Specifies the rank of the edge.  The data type is <code>int</code>. <code>10</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET start_year = start_year +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. If <code>&lt;condition&gt;</code> evaluates to <code>false</code>, the <code>SET</code> clause does not take effect. <code>WHEN end_year &lt; 2010</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD start_year AS Start_Year</code>"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/#example","title":"Example","text":"<p>The following example checks the properties of the edge with the GO statement.</p> <pre><code>nebula&gt; GO FROM \"player100\" \\\n        OVER serve \\\n        YIELD properties(edge).start_year, properties(edge).end_year;\n+-----------------------------+---------------------------+\n| properties(EDGE).start_year | properties(EDGE).end_year |\n+-----------------------------+---------------------------+\n| 1997                        | 2016                      |\n+-----------------------------+---------------------------+\n</code></pre> <p>The following example updates the <code>start_year</code> property and returns the <code>end_year</code> and the new <code>start_year</code>.</p> <pre><code>nebula&gt; UPDATE EDGE on serve \"player100\" -&gt; \"team204\"@0 \\\n        SET start_year = start_year + 1 \\\n        WHEN end_year &gt; 2010 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 1998       | 2016     |\n+------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/","title":"UPSERT EDGE","text":"<p>The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT EDGE</code> to update the properties of an edge if it exists or insert a new edge if it does not exist.</p> <p>The performance of <code>UPSERT</code> is much lower than that of <code>INSERT</code> because <code>UPSERT</code> is a read-modify-write serialization operation at the partition level.</p> <p>Danger</p> <p>Do not use <code>UPSERT</code> for scenarios with highly concurrent writes. You can use <code>UPDATE</code> or <code>INSERT</code> instead.</p>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/#syntax","title":"Syntax","text":"<pre><code>UPSERT EDGE ON &lt;edge_type&gt;\n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@rank]\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;properties&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;edge_type&gt;</code> Yes Specifies the edge type. The properties to be updated must be on this edge type. <code>ON serve</code> <code>&lt;src_vid&gt;</code> Yes Specifies the source vertex ID of the edge. <code>\"player100\"</code> <code>&lt;dst_vid&gt;</code> Yes Specifies the destination vertex ID of the edge. <code>\"team204\"</code> <code>&lt;rank&gt;</code> No Specifies the rank of the edge. <code>10</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET start_year = start_year +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. <code>WHEN end_year &lt; 2010</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD start_year AS Start_Year</code>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/#insert_an_edge_if_it_does_not_exist","title":"Insert an edge if it does not exist","text":"<p>If an edge does not exist, it is created no matter the conditions in the <code>WHEN</code> clause are met or not, and the <code>SET</code> clause takes effect. The property values of the new edge depend on:</p> <ul> <li>How the <code>SET</code> clause is defined.</li> </ul> <ul> <li>Whether the property has a default value.</li> </ul> <p>For example, if:</p> <ul> <li>The edge to be inserted will have properties <code>start_year</code> and <code>end_year</code> based on the edge type <code>serve</code>.</li> </ul> <ul> <li>The <code>SET</code> clause specifies that <code>end_year = 2021</code>.</li> </ul> <p>Then the property values in different cases are listed as follows:</p> Are <code>WHEN</code> conditions met If properties have default values Value of <code>start_year</code> Value of <code>end_year</code> Yes Yes The default value <code>2021</code> Yes No <code>NULL</code> <code>2021</code> No Yes The default value <code>2021</code> No No <code>NULL</code> <code>2021</code> <p>Here are some examples:</p> <pre><code>// This example checks if the following three vertices have any outgoing serve edge. The result \"Empty set\" indicates that such an edge does not exist.\nnebula&gt; GO FROM \"player666\", \"player667\", \"player668\" \\\n        OVER serve \\\n        YIELD properties(edge).start_year, properties(edge).end_year;\n+-----------------------------+---------------------------+\n| properties(EDGE).start_year | properties(EDGE).end_year |\n+-----------------------------+---------------------------+\n+-----------------------------+---------------------------+\nEmpty set\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player666\" -&gt; \"team200\"@0 \\\n        SET end_year = 2021 \\\n        WHEN end_year == 2010 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2021     |\n+------------+----------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player666\" -&gt; \"team200\"@0 \\\n        SET end_year = 2022 \\\n        WHEN end_year == 2010 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2021     |\n+------------+----------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player667\" -&gt; \"team200\"@0 \\\n        SET end_year = 2022 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2022     |\n+------------+----------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player668\" -&gt; \"team200\"@0 \\\n        SET start_year = 2000, end_year = end_year + 1 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 2000       | __NULL__ |\n+------------+----------+\n</code></pre> <p>In the last query of the preceding example, since <code>end_year</code> has no default value, when the edge is created, <code>end_year</code> is <code>NULL</code>, and <code>end_year = end_year + 1</code> does not take effect. But if <code>end_year</code> has a default value, <code>end_year = end_year + 1</code> will take effect. For example:</p> <pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS serve_with_default(start_year int, end_year int DEFAULT 2010);\nExecution succeeded\n\nnebula&gt; UPSERT EDGE on serve_with_default \\\n        \"player668\" -&gt; \"team200\" \\\n        SET end_year = end_year + 1 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2011     |\n+------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/#update_an_edge_if_it_exists","title":"Update an edge if it exists","text":"<p>If the edge exists and the <code>WHEN</code> conditions are met, the edge is updated.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Ben Simmons\"})-[e:serve]-(v2) \\\n        RETURN e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player149\"-&gt;\"team219\" @0 {end_year: 2019, start_year: 2016}] |\n+-----------------------------------------------------------------------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player149\" -&gt; \"team219\" \\\n        SET end_year = end_year + 1 \\\n        WHEN start_year == 2016 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 2016       | 2020     |\n+------------+----------+\n</code></pre> <p>If the edge exists and the <code>WHEN</code> conditions are not met, the update does not take effect.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Ben Simmons\"})-[e:serve]-(v2) \\\n        RETURN e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player149\"-&gt;\"team219\" @0 {end_year: 2020, start_year: 2016}] |\n+-----------------------------------------------------------------------+\n\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player149\" -&gt; \"team219\" \\\n        SET end_year = end_year + 1 \\\n        WHEN start_year != 2016 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 2016       | 2020     |\n+------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/","title":"DELETE EDGE","text":"<p>The <code>DELETE EDGE</code> statement deletes one edge or multiple edges at a time. You can use <code>DELETE EDGE</code> together with pipe operators. For more information, see PIPE OPERATORS.</p> <p>To delete all the outgoing edges for a vertex, please delete the vertex. For more information, see DELETE VERTEX.</p>"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/#syntax","title":"Syntax","text":"<pre><code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] ...]\n</code></pre> <p>Caution</p> <p>If no rank is specified, NebulaGraph only deletes the edge with rank 0. Delete edges with all ranks, as shown in the following example.</p>"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/#examples","title":"Examples","text":"<pre><code>nebula&gt; DELETE EDGE serve \"player100\" -&gt; \"team204\"@0;\n</code></pre> <p>The following example shows that you can use <code>DELETE EDGE</code> together with pipe operators to delete edges that meet the conditions.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        WHERE dst(edge) == \"player101\" \\\n        YIELD src(edge) AS src, dst(edge) AS dst, rank(edge) AS rank \\\n        | DELETE EDGE follow $-.src-&gt;$-.dst @ $-.rank;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/","title":"Index overview","text":"<p>Indexes are built to fast process graph queries. Nebula\u00a0Graph supports two kinds of indexes: native indexes and full-text indexes. This topic introduces the index types and helps choose the right index.</p>"},{"location":"3.ngql-guide/14.native-index-statements/#usage_instructions","title":"Usage Instructions","text":"<ul> <li>Indexes can improve query performance but may reduce write performance.</li> </ul> <ul> <li>An index is a prerequisite for locating data when executing a <code>LOOKUP</code>statement. If there is no index, an error will be reported when executing the <code>LOOKUP</code> statement.</li> </ul> <ul> <li>When using an index, NebulaGraph will automatically select the most optimal index.</li> </ul> <ul> <li>Indexes with high selectivity, that is, when the ratio of the number of records with unique values in the index column to the total number of records is high (for example, the ratio for <code>ID numbers</code> is <code>1</code>), can significantly improve query performance. For indexes with low selectivity (such as <code>country</code>), query performance might not experience a substantial improvement.</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/#native_indexes","title":"Native indexes","text":"<p>Native indexes allow querying data based on a given property. Features are as follows.</p> <ul> <li>There are two kinds of native indexes: tag index and edge type index.</li> </ul> <ul> <li>Native indexes must be updated manually. You can use the <code>REBUILD INDEX</code> statement to update native indexes.</li> </ul> <ul> <li>Native indexes support indexing multiple properties on a tag or an edge type (composite indexes), but do not support indexing across multiple tags or edge types.</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/#operations_on_native_indexes","title":"Operations on native indexes","text":"<ul> <li>CREATE INDEX</li> </ul> <ul> <li>SHOW CREATE INDEX</li> </ul> <ul> <li>SHOW INDEXES</li> </ul> <ul> <li>DESCRIBE INDEX</li> </ul> <ul> <li>REBUILD INDEX</li> </ul> <ul> <li>SHOW INDEX STATUS</li> </ul> <ul> <li>DROP INDEX</li> </ul> <ul> <li>LOOKUP</li> </ul> <ul> <li>MATCH</li> </ul> <ul> <li>Geography index</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/#full-text_indexes","title":"Full-text indexes","text":"<p>Full-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property. Features are as follows.</p> <ul> <li>Full-text indexes allow indexing just one property.</li> </ul> <ul> <li>Full-text indexes do not support logical operations such as <code>AND</code>, <code>OR</code>, and <code>NOT</code>.</li> </ul> <p>Note</p> <p>To do complete string matches, use native indexes.</p>"},{"location":"3.ngql-guide/14.native-index-statements/#null_values","title":"Null values","text":"<p>Indexes do not support indexing null values.</p>"},{"location":"3.ngql-guide/14.native-index-statements/#range_queries","title":"Range queries","text":"<p>In addition to querying single results from native indexes, you can also do range queries. Not all the native indexes support range queries. You can only do range searches for numeric, date, and time type properties.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/","title":"CREATE INDEX","text":""},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#prerequisites","title":"Prerequisites","text":"<p>Before you create an index, make sure that the relative tag or edge type is created. For how to create tags or edge types, see CREATE TAG and CREATE EDGE.</p> <p>For how to create full-text indexes, see Deploy full-text index.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#must-read_for_using_indexes","title":"Must-read for using indexes","text":"<p>The concept and using restrictions of indexes are comparatively complex. Before you use indexes, you must read the following sections carefully.</p> <p>You can use <code>CREATE INDEX</code> to add native indexes for the existing tags, edge types, or properties. They are usually called as tag indexes, edge type indexes, and property indexes.</p> <ul> <li>Tag indexes and edge type indexes apply to queries related to the tag and the edge type, but do not apply to queries that are based on certain properties on the tag. For example, you can use <code>LOOKUP</code> to retrieve all the vertices with the tag <code>player</code>.</li> </ul> <ul> <li>Property indexes apply to property-based queries. For example, you can use the <code>age</code> property to retrieve the VID of all vertices that meet <code>age == 19</code>.</li> </ul> <p>If a property index <code>i_TA</code> is created for the property <code>A</code> of the tag <code>T</code> and <code>i_T</code> for the tag <code>T</code>, the indexes can be replaced as follows (the same for edge type indexes):</p> <ul> <li>The query engine can use <code>i_TA</code> to replace <code>i_T</code>.</li> </ul> <ul> <li> <p>In the <code>MATCH</code> and <code>LOOKUP</code> statements, <code>i_T</code> may replace <code>i_TA</code> for querying properties.</p> <p>Legacy version compatibility</p> <p>In previous releases, the tag or edge type index in the <code>LOOKUP</code> statement cannot replace the property index for property queries.</p> </li> </ul> <p>Although the same results can be obtained by using alternative indexes for queries, the query performance varies according to the selected index.</p> <p>Caution</p> <p>Indexes can dramatically reduce the write performance. The performance can be greatly reduced. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.</p> <p>Long indexes decrease the scan performance of the Storage Service and use more memory. We suggest that you set the indexing length the same as that of the longest string to be indexed. For variable-length string-type properties, the longest index length is 256 bytes; for fixed-length string-type properties, the longest index length is the length of the index itself.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#steps","title":"Steps","text":"<p>If you must use indexes, we suggest that you:</p> <ol> <li> <p>Import the data into NebulaGraph.</p> </li> <li> <p>Create indexes.</p> </li> <li> <p>Rebuild indexes.</p> </li> <li> <p>After the index is created and the data is imported, you can use LOOKUP or MATCH to retrieve the data. You do not need to specify which indexes to use in a query, NebulaGraph figures that out by itself.</p> </li> </ol> <p>Note</p> <p>If you create an index before importing the data, the importing speed will be extremely slow due to the reduction in the write performance.</p> <p>Keep <code>--disable_auto_compaction = false</code> during daily incremental writing.</p> <p>The newly created index will not take effect immediately. Trying to use a newly created index (such as <code>LOOKUP</code> or<code>REBUILD INDEX</code>) may fail and return <code>can't find xxx in the space</code> because the creation is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds. To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> in the configuration files for all services.</p> <p>Danger</p> <p>After creating a new index, or dropping the old index and creating a new one with the same name again, you must <code>REBUILD INDEX</code>. Otherwise, these data cannot be returned in the <code>MATCH</code> and <code>LOOKUP</code> statements.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#syntax","title":"Syntax","text":"<pre><code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT '&lt;comment&gt;'];\n</code></pre> Parameter Description <code>TAG | EDGE</code> Specifies the index type that you want to create. <code>IF NOT EXISTS</code> Detects if the index that you want to create exists. If it does not exist, a new one will be created. <code>&lt;index_name&gt;</code> The name of the index. It must be unique in a graph space. A recommended way of naming is <code>i_tagName_propName</code>. Index names cannot start with a number. They supports 1 to 4 bytes UTF-8 encoded characters, such as English letters (case-sensitive), numbers, and Chinese characters, but does not support special characters except underscores. To use special characters, reserved keywords, or starting with a number, quote them with backticks. For more information, see Keywords and reserved words.Note: If you name an index in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). <code>&lt;tag_name&gt; | &lt;edge_name&gt;</code> Specifies the name of the tag or edge associated with the index. <code>&lt;prop_name_list&gt;</code> To index a variable-length string property, you must use <code>prop_name(length)</code> to specify the index length, and the maximum index length is 256. To index a tag or an edge type, ignore the <code>prop_name_list</code>. <code>COMMENT</code> The remarks of the index. The maximum length is 256 bytes. By default, there will be no comments on an index."},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#create_tagedge_type_indexes","title":"Create tag/edge type indexes","text":"<pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index on player();\n</code></pre> <pre><code>nebula&gt; CREATE EDGE INDEX IF NOT EXISTS follow_index on follow();\n</code></pre> <p>After indexing a tag or an edge type, you can use the <code>LOOKUP</code> statement to retrieve the VID of all vertices <code>with the tag</code>, or <code>the source vertex ID, destination vertex ID, and ranks</code> of <code>all edges with the edge type</code>. For more information, see LOOKUP.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#create_single-property_indexes","title":"Create single-property indexes","text":"<pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index_0 on player(name(10));\n</code></pre> <p>The preceding example creates an index for the <code>name</code> property on all vertices carrying the <code>player</code> tag. This example creates an index using the first 10 characters of the <code>name</code> property.</p> <pre><code># To index a variable-length string property, you need to specify the index length.\nnebula&gt; CREATE TAG IF NOT EXISTS var_string(p1 string);\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS var ON var_string(p1(10));\n\n# To index a fixed-length string property, you do not need to specify the index length.\nnebula&gt; CREATE TAG IF NOT EXISTS fix_string(p1 FIXED_STRING(10));\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS fix ON fix_string(p1);\n</code></pre> <pre><code>nebula&gt; CREATE EDGE INDEX IF NOT EXISTS follow_index_0 on follow(degree);\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#create_composite_property_indexes","title":"Create composite property indexes","text":"<p>An index on multiple properties on a tag (or an edge type) is called a composite property index.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index_1 on player(name(10), age);\n</code></pre> <p>Caution</p> <p>Creating composite property indexes across multiple tags or edge types is not supported.</p> <p>Note</p> <p>NebulaGraph follows the left matching principle to select indexes.</p>"},{"location":"3.ngql-guide/14.native-index-statements/2.1.show-create-index/","title":"SHOW CREATE INDEX","text":"<p><code>SHOW CREATE INDEX</code> shows the statement used when creating a tag or an edge type. It contains detailed information about the index, such as its associated properties.</p>"},{"location":"3.ngql-guide/14.native-index-statements/2.1.show-create-index/#syntax","title":"Syntax","text":"<pre><code>SHOW CREATE {TAG | EDGE} INDEX &lt;index_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/2.1.show-create-index/#examples","title":"Examples","text":"<p>You can run <code>SHOW TAG INDEXES</code> to list all tag indexes, and then use <code>SHOW CREATE TAG INDEX</code> to show the information about the creation of the specified index.</p> <pre><code>nebula&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\n\nnebula&gt; SHOW CREATE TAG INDEX player_index_1;\n+------------------+--------------------------------------------------+\n| Tag Index Name   | Create Tag Index                                 |\n+------------------+--------------------------------------------------+\n| \"player_index_1\" | \"CREATE TAG INDEX `player_index_1` ON `player` ( |\n|                  |  `name`(20)                                      |\n|                  | )\"                                               |\n+------------------+--------------------------------------------------+\n</code></pre> <p>Edge indexes can be queried through a similar approach.</p> <pre><code>nebula&gt; SHOW EDGE INDEXES;\n+----------------+----------+---------+\n| Index Name     | By Edge  | Columns |\n+----------------+----------+---------+\n| \"follow_index\" | \"follow\" | []      |\n+----------------+----------+---------+\n\nnebula&gt; SHOW CREATE EDGE INDEX follow_index;\n+-----------------+-------------------------------------------------+\n| Edge Index Name | Create Edge Index                               |\n+-----------------+-------------------------------------------------+\n| \"follow_index\"  | \"CREATE EDGE INDEX `follow_index` ON `follow` ( |\n|                 | )\"                                              |\n+-----------------+-------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/2.show-native-indexes/","title":"SHOW INDEXES","text":"<p><code>SHOW INDEXES</code> shows the defined tag or edge type indexes names in the current graph space.</p>"},{"location":"3.ngql-guide/14.native-index-statements/2.show-native-indexes/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEXES\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/2.show-native-indexes/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAG INDEXES;\n+------------------+--------------+-----------------+\n| Index Name       | By Tag       | Columns         |\n+------------------+--------------+-----------------+\n| \"fix\"            | \"fix_string\" | [\"p1\"]          |\n| \"player_index_0\" | \"player\"     | [\"name\"]        |\n| \"player_index_1\" | \"player\"     | [\"name\", \"age\"] |\n| \"var\"            | \"var_string\" | [\"p1\"]          |\n+------------------+--------------+-----------------+\n\nnebula&gt; SHOW EDGE INDEXES;\n+----------------+----------+---------+\n| Index Name     | By Edge  | Columns |\n| \"follow_index\" | \"follow\" | []      |\n+----------------+----------+---------+\n</code></pre> <p>Legacy version compatibility</p> <p>In NebulaGraph 2.x, the <code>SHOW TAG/EDGE INDEXES</code> statement only returns <code>Names</code>.</p>"},{"location":"3.ngql-guide/14.native-index-statements/3.describe-native-index/","title":"DESCRIBE INDEX","text":"<p><code>DESCRIBE INDEX</code> can get the information about the index with a given name, including the property name (Field) and the property type (Type) of the index.</p>"},{"location":"3.ngql-guide/14.native-index-statements/3.describe-native-index/#syntax","title":"Syntax","text":"<pre><code>DESCRIBE {TAG | EDGE} INDEX &lt;index_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/3.describe-native-index/#examples","title":"Examples","text":"<pre><code>nebula&gt; DESCRIBE TAG INDEX player_index_0;\n+--------+--------------------+\n| Field  | Type               |\n+--------+--------------------+\n| \"name\" | \"fixed_string(30)\" |\n+--------+--------------------+\n\nnebula&gt; DESCRIBE TAG INDEX player_index_1;\n+--------+--------------------+\n| Field  | Type               |\n+--------+--------------------+\n| \"name\" | \"fixed_string(10)\" |\n| \"age\"  | \"int64\"            |\n+--------+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/4.rebuild-native-index/","title":"REBUILD INDEX","text":"<p>Danger</p> <ul> <li>If data is updated or inserted before the creation of the index, you must rebuild the indexes manually to make sure that the indexes contain the previously added data. Otherwise, you cannot use <code>LOOKUP</code> and <code>MATCH</code> to query the data based on the index. If the index is created before any data insertion, there is no need to rebuild the index.</li> <li>When the rebuild of an index is incomplete, queries that rely on the index can use only part of the index and therefore cannot obtain accurate results.</li> </ul> <p>You can use <code>REBUILD INDEX</code> to rebuild the created tag or edge type index. For details on how to create an index, see CREATE INDEX.</p> <p>Performance</p> <p>The speed of rebuilding indexes can be optimized by modifying the <code>rebuild_index_part_rate_limit</code> and <code>snapshot_batch_size</code> parameters in the configuration file. In addition, greater parameter values may result in higher memory and network usage, see Storage Service configurations for details.</p>"},{"location":"3.ngql-guide/14.native-index-statements/4.rebuild-native-index/#syntax","title":"Syntax","text":"<pre><code>REBUILD {TAG | EDGE} INDEX [&lt;index_name_list&gt;];\n\n&lt;index_name_list&gt;::=\n    [index_name [, index_name] ...]\n</code></pre> <ul> <li>Multiple indexes are permitted in a single <code>REBUILD</code> statement, separated by commas. When the index name is not specified, all tag or edge indexes are rebuilt.</li> </ul> <ul> <li>After the rebuilding is complete, you can use the <code>SHOW {TAG | EDGE} INDEX STATUS</code> command to check if the index is successfully rebuilt. For details on index status, see SHOW INDEX STATUS.</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/4.rebuild-native-index/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS person(name string, age int, gender string, email string);\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS single_person_index ON person(name(10));\n\n# The following example rebuilds an index and returns the job ID.\nnebula&gt; REBUILD TAG INDEX single_person_index;\n+------------+\n| New Job Id |\n+------------+\n| 31         |\n+------------+\n\n# The following example checks the index status.\nnebula&gt; SHOW TAG INDEX STATUS;\n+-----------------------+--------------+\n| Name                  | Index Status |\n+-----------------------+--------------+\n| \"single_person_index\" | \"FINISHED\"   |\n+-----------------------+--------------+\n\n# You can also use \"SHOW JOB &lt;job_id&gt;\" to check if the rebuilding process is complete.\nnebula&gt; SHOW JOB 31;\n+----------------+---------------------+------------+-------------------------+-------------------------+-------------+\n| Job Id(TaskId) | Command(Dest)       | Status     | Start Time              | Stop Time               | Error Code  |\n+----------------+---------------------+------------+-------------------------+-------------------------+-------------+\n| 31             | \"REBUILD_TAG_INDEX\" | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:24.000 | \"SUCCEEDED\" |\n| 0              | \"storaged1\"         | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:28.000 | \"SUCCEEDED\" |\n| 1              | \"storaged2\"         | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:28.000 | \"SUCCEEDED\" |\n| 2              | \"storaged0\"         | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:28.000 | \"SUCCEEDED\" |\n| \"Total:3\"      | \"Succeeded:3\"       | \"Failed:0\" | \"In Progress:0\"         | \"\"                      | \"\"          |\n+----------------+---------------------+------------+-------------------------+-------------------------+-------------+\n</code></pre> <p>NebulaGraph creates a job to rebuild the index. The job ID is displayed in the preceding return message. To check if the rebuilding process is complete, use the <code>SHOW JOB &lt;job_id&gt;</code> statement. For more information, see SHOW JOB.</p>"},{"location":"3.ngql-guide/14.native-index-statements/5.show-native-index-status/","title":"SHOW INDEX STATUS","text":"<p><code>SHOW INDEX STATUS</code> returns the name of the created tag or edge type index and its status of job.</p> <p>The status of rebuilding indexes includes:</p> <ul> <li><code>QUEUE</code>: The job is in a queue.</li> <li><code>RUNNING</code>: The job is running.</li> <li><code>FINISHED</code>: The job is finished.</li> <li><code>FAILED</code>: The job has failed.</li> <li><code>STOPPED</code>: The job has stopped.</li> <li><code>INVALID</code>: The job is invalid.</li> </ul> <p>Note</p> <p>For details on how to create an index, see CREATE INDEX.</p>"},{"location":"3.ngql-guide/14.native-index-statements/5.show-native-index-status/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEX STATUS;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/5.show-native-index-status/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW TAG INDEX STATUS;\n+----------------------+--------------+\n| Name                 | Index Status |\n+----------------------+--------------+\n| \"player_index_0\"     | \"FINISHED\"   |\n| \"player_index_1\"     | \"FINISHED\"   |\n+----------------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/","title":"DROP INDEX","text":"<p><code>DROP INDEX</code> removes an existing index from the current graph space.</p>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/#prerequisite","title":"Prerequisite","text":"<p>Running the <code>DROP INDEX</code> statement requires some privileges of <code>DROP TAG INDEX</code> and <code>DROP EDGE INDEX</code> in the given graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/#syntax","title":"Syntax","text":"<pre><code>DROP {TAG | EDGE} INDEX [IF EXISTS] &lt;index_name&gt;;\n</code></pre> <p><code>IF EXISTS</code>: Detects whether the index that you want to drop exists. If it exists, it will be dropped.</p>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/#example","title":"Example","text":"<pre><code>nebula&gt; DROP TAG INDEX player_index_0;\n</code></pre>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/","title":"Full-text indexes","text":"<p>Full-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property.</p> <p>You can use the <code>WHERE</code> clause to specify the search strings in <code>LOOKUP</code> statements.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#prerequisite","title":"Prerequisite","text":"<p>Before using the full-text index, make sure that you have deployed a Elasticsearch cluster and a Listener cluster. For more information, see Deploy Elasticsearch and Deploy Listener.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#precaution","title":"Precaution","text":"<p>Before using the full-text index, make sure that you know the restrictions.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#full_text_queries","title":"Full Text Queries","text":"<p>Full-text queries enable you to search for parsed text fields, using a parser with strict syntax to return content based on the query string provided. For details, see Query string query.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#syntax","title":"Syntax","text":""},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#create_full-text_indexes","title":"Create full-text indexes","text":"<pre><code>CREATE FULLTEXT {TAG | EDGE} INDEX &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} (&lt;prop_name&gt; [,&lt;prop_name&gt;]...) [ANALYZER=\"&lt;analyzer_name&gt;\"];\n</code></pre> <ul> <li>Composite indexes with multiple properties are supported when creating full-text indexes.</li> <li><code>&lt;analyzer_name&gt;</code> is the name of the analyzer. The default value is <code>standard</code>. To use other analyzers (e.g. IK Analysis), you need to make sure that the corresponding analyzer is installed in Elasticsearch in advance.</li> </ul>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#show_full-text_indexes","title":"Show full-text indexes","text":"<pre><code>SHOW FULLTEXT INDEXES;\n</code></pre>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#rebuild_full-text_indexes","title":"Rebuild full-text indexes","text":"<pre><code>REBUILD FULLTEXT INDEX;\n</code></pre> <p>Caution</p> <p>When there is a large amount of data, rebuilding full-text index is slow, you can modify <code>snapshot_send_files=false</code> in the configuration file of Storage service(<code>nebula-storaged.conf</code>).</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#drop_full-text_indexes","title":"Drop full-text indexes","text":"<pre><code>DROP FULLTEXT INDEX &lt;index_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#use_query_options","title":"Use query options","text":"<pre><code>LOOKUP ON {&lt;tag&gt; | &lt;edge_type&gt;} WHERE ES_QUERY(&lt;index_name&gt;, \"&lt;text&gt;\") YIELD &lt;return_list&gt; [| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;];\n\n&lt;return_list&gt;\n    &lt;prop_name&gt; [AS &lt;prop_alias&gt;] [, &lt;prop_name&gt; [AS &lt;prop_alias&gt;] ...] [, id(vertex)  [AS &lt;prop_alias&gt;]] [, score() AS &lt;score_alias&gt;]\n</code></pre> <ul> <li><code>index_name</code>: The name of the full-text index.</li> </ul> <ul> <li><code>text</code>: Search conditions. The where can only be followed by the ES_QUERY, and all judgment conditions must be written in the text. For supported syntax, see Query string syntax.</li> </ul> <ul> <li><code>score()</code>: The score calculated by doing N degree expansion for the eligible vertices. The default value is <code>1.0</code>. The higher the score, the higher the degree of match. The return value is sorted by default from highest to lowest score. For details, see Search and Scoring in Lucene.</li> </ul>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#examples","title":"Examples","text":"<pre><code>// This example creates the graph space.\nnebula&gt; CREATE SPACE IF NOT EXISTS basketballplayer (partition_num=3,replica_factor=1, vid_type=fixed_string(30));\n\n// This example signs in the text service.\nnebula&gt; SIGN IN TEXT SERVICE (192.168.8.100:9200, HTTP);\n\n// This example checks the text service status.\nnebula&gt; SHOW TEXT SEARCH CLIENTS;\n+-----------------+-----------------+------+\n| Type            | Host            | Port |\n+-----------------+-----------------+------+\n| \"ELASTICSEARCH\" | \"192.168.8.100\" | 9200 |\n+-----------------+-----------------+------+\n\n// This example switches the graph space.\nnebula&gt; USE basketballplayer;\n\n// This example adds the listener to the NebulaGraph cluster.\nnebula&gt; ADD LISTENER ELASTICSEARCH 192.168.8.100:9789;\n\n// This example checks the listener status. When the status is `Online`, the listener is ready.\nnebula&gt; SHOW LISTENER;\n+--------+-----------------+------------------------+-------------+\n| PartId | Type            | Host                   | Host Status |\n+--------+-----------------+------------------------+-------------+\n| 1      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n| 2      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n| 3      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n+--------+-----------------+------------------------+-------------+\n\n// This example creates the tag.\nnebula&gt; CREATE TAG IF NOT EXISTS player(name string, city string);\n\n// This example creates a single-attribute full-text index.\nnebula&gt; CREATE FULLTEXT TAG INDEX fulltext_index_1 ON player(name) ANALYZER=\"standard\";\n\n// This example creates a multi-attribute full-text indexe.\nnebula&gt; CREATE FULLTEXT TAG INDEX fulltext_index_2 ON player(name,city) ANALYZER=\"standard\";\n\n// This example rebuilds the full-text index.\nnebula&gt; REBUILD FULLTEXT INDEX;\n\n// This example shows the full-text index.\nnebula&gt; SHOW FULLTEXT INDEXES;\n+--------------------+-------------+-------------+--------------+------------+\n| Name               | Schema Type | Schema Name | Fields       | Analyzer   |\n+--------------------+-------------+-------------+--------------+------------+\n| \"fulltext_index_1\" | \"Tag\"       | \"player\"    | \"name\"       | \"standard\" |\n| \"fulltext_index_2\" | \"Tag\"       | \"player\"    | \"name, city\" | \"standard\" |\n+--------------------+-------------+-------------+--------------+------------+\n\n// This example inserts the test data.\nnebula&gt; INSERT VERTEX player(name, city) VALUES \\\n    \"Russell Westbrook\": (\"Russell Westbrook\", \"Los Angeles\"), \\\n    \"Chris Paul\": (\"Chris Paul\", \"Houston\"),\\\n    \"Boris Diaw\": (\"Boris Diaw\", \"Houston\"),\\\n    \"David West\": (\"David West\", \"Philadelphia\"),\\\n    \"Danny Green\": (\"Danny Green\", \"Philadelphia\"),\\\n    \"Tim Duncan\": (\"Tim Duncan\", \"New York\"),\\\n    \"James Harden\": (\"James Harden\", \"New York\"),\\\n    \"Tony Parker\": (\"Tony Parker\", \"Chicago\"),\\\n    \"Aron Baynes\": (\"Aron Baynes\", \"Chicago\"),\\\n    \"Ben Simmons\": (\"Ben Simmons\", \"Phoenix\"),\\\n    \"Blake Griffin\": (\"Blake Griffin\", \"Phoenix\");\n\n// These examples run test queries.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Chris\") YIELD id(vertex);\n+--------------+\n| id(VERTEX)   |\n+--------------+\n| \"Chris Paul\" |\n+--------------+\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Harden\") YIELD properties(vertex);\n+----------------------------------------------------------------+\n| properties(VERTEX)                                             |\n+----------------------------------------------------------------+\n| {_vid: \"James Harden\", city: \"New York\", name: \"James Harden\"} |\n+----------------------------------------------------------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Da*\") YIELD properties(vertex);\n+------------------------------------------------------------------+\n| properties(VERTEX)                                               |\n+------------------------------------------------------------------+\n| {_vid: \"David West\", city: \"Philadelphia\", name: \"David West\"}   |\n| {_vid: \"Danny Green\", city: \"Philadelphia\", name: \"Danny Green\"} |\n+------------------------------------------------------------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex);\n+---------------------+\n| id(VERTEX)          |\n+---------------------+\n| \"Russell Westbrook\" |\n| \"Boris Diaw\"        |\n| \"Aron Baynes\"       |\n| \"Ben Simmons\"       |\n| \"Blake Griffin\"     |\n+---------------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex) | LIMIT 2,3;\n+-----------------+\n| id(VERTEX)      |\n+-----------------+\n| \"Aron Baynes\"   |\n| \"Ben Simmons\"   |\n| \"Blake Griffin\" |\n+-----------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex) | YIELD count(*);\n+----------+\n| count(*) |\n+----------+\n| 5        |\n+----------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex), score() AS score;\n+---------------------+-------+\n| id(VERTEX)          | score |\n+---------------------+-------+\n| \"Russell Westbrook\" | 1.0   |\n| \"Boris Diaw\"        | 1.0   |\n| \"Aron Baynes\"       | 1.0   |\n| \"Ben Simmons\"       | 1.0   |\n| \"Blake Griffin\"     | 1.0   |\n+---------------------+-------+\n\n// For documents containing a word `b`, its score will be multiplied by a weighting factor of 4, while for documents containing a word `c`, the default weighting factor of 1 is used.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*^4 OR *c*\") YIELD id(vertex), score() AS score;\n+---------------------+-------+\n| id(VERTEX)          | score |\n+---------------------+-------+\n| \"Russell Westbrook\" | 4.0   |\n| \"Boris Diaw\"        | 4.0   |\n| \"Aron Baynes\"       | 4.0   |\n| \"Ben Simmons\"       | 4.0   |\n| \"Blake Griffin\"     | 4.0   |\n| \"Chris Paul\"        | 1.0   |\n| \"Tim Duncan\"        | 1.0   |\n+---------------------+-------+\n\n// When using a multi-attribute full-text index query, the conditions are matched within all properties of the index.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_2,\"*h*\") YIELD properties(vertex);\n+------------------------------------------------------------------+\n| properties(VERTEX)                                               |\n+------------------------------------------------------------------+\n| {_vid: \"Chris Paul\", city: \"Houston\", name: \"Chris Paul\"}        |\n| {_vid: \"Boris Diaw\", city: \"Houston\", name: \"Boris Diaw\"}        |\n| {_vid: \"David West\", city: \"Philadelphia\", name: \"David West\"}   |\n| {_vid: \"James Harden\", city: \"New York\", name: \"James Harden\"}   |\n| {_vid: \"Tony Parker\", city: \"Chicago\", name: \"Tony Parker\"}      |\n| {_vid: \"Aron Baynes\", city: \"Chicago\", name: \"Aron Baynes\"}      |\n| {_vid: \"Ben Simmons\", city: \"Phoenix\", name: \"Ben Simmons\"}      |\n| {_vid: \"Blake Griffin\", city: \"Phoenix\", name: \"Blake Griffin\"}  |\n| {_vid: \"Danny Green\", city: \"Philadelphia\", name: \"Danny Green\"} |\n+------------------------------------------------------------------+\n\n// When using multi-attribute full-text index queries, you can specify different text for different properties for the query.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_2,\"name:*b* AND city:Houston\") YIELD properties(vertex);\n+-----------------------------------------------------------+\n| properties(VERTEX)                                        |\n+-----------------------------------------------------------+\n| {_vid: \"Boris Diaw\", city: \"Houston\", name: \"Boris Diaw\"} |\n+-----------------------------------------------------------+\n\n// Delete single-attribute full-text index.\nnebula&gt; DROP FULLTEXT INDEX fulltext_index_1;\n</code></pre>"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/","title":"GET SUBGRAPH","text":"<p>The <code>GET SUBGRAPH</code> statement returns a subgraph that is generated by traversing a graph starting from a specified vertex. <code>GET SUBGRAPH</code> statements allow you to specify the number of steps and the type or direction of edges during the traversal.</p>"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#syntax","title":"Syntax","text":"<pre><code>GET SUBGRAPH [WITH PROP] [&lt;step_count&gt; {STEP|STEPS}] FROM {&lt;vid&gt;, &lt;vid&gt;...}\n[{IN | OUT | BOTH} &lt;edge_type&gt;, &lt;edge_type&gt;...]\n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]]\nYIELD {[VERTICES AS &lt;vertex_alias&gt;] [,EDGES AS &lt;edge_alias&gt;]};\n</code></pre> <ul> <li><code>WITH PROP</code> shows the properties. If not specified, the properties will be hidden.</li> </ul> <ul> <li><code>step_count</code> specifies the number of hops from the source vertices and returns the subgraph from 0 to <code>step_count</code> hops. It must be a non-negative integer. Its default value is 1.</li> </ul> <ul> <li><code>vid</code> specifies the vertex IDs. </li> </ul> <ul> <li><code>edge_type</code> specifies the edge type. You can use <code>IN</code>, <code>OUT</code>, and <code>BOTH</code> to specify the traversal direction of the edge type. The default is <code>BOTH</code>.</li> </ul> <ul> <li><code>&lt;WHERE clause&gt;</code> specifies the filter conditions for the traversal, which can be used with the boolean operator <code>AND</code>.</li> </ul> <ul> <li><code>YIELD</code> defines the output that needs to be returned. You can return only vertices or edges. A column alias must be set.</li> </ul> <p>Note</p> <p>The path type of <code>GET SUBGRAPH</code> is <code>trail</code>. Only vertices can be repeatedly visited in graph traversal. For more information, see Path.</p>"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#limitations","title":"Limitations","text":"<p>While using the <code>WHERE</code> clause in a <code>GET SUBGRAPH</code> statement, note the following restrictions:</p> <ul> <li>Only support the <code>AND</code> operator.</li> <li>Only support filter destination vertex, the vertex format must be <code>$$.tagName.propName</code>.</li> <li>Support filter edge, the edge format must be <code>edge_type.propName</code>.</li> <li>Support math functions, aggregate functions, string functions, datetime functions, type conversion functions and general functions in list functions.</li> <li>Not support aggregate functions, schema-related functions, conditional expression, predicate functions, geography function and user-defined functions.</li> </ul>"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#examples","title":"Examples","text":"<p>The following graph is used as the sample.</p> <p></p> <p>Insert the test data:</p> <pre><code>nebula&gt; CREATE SPACE IF NOT EXISTS subgraph(partition_num=15, replica_factor=1, vid_type=fixed_string(30));\nnebula&gt; USE subgraph;\nnebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int);\nnebula&gt; CREATE TAG IF NOT EXISTS team(name string);\nnebula&gt; CREATE EDGE IF NOT EXISTS follow(degree int);\nnebula&gt; CREATE EDGE IF NOT EXISTS serve(start_year int, end_year int);\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36);\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\nnebula&gt; INSERT VERTEX team(name) VALUES \"team203\":(\"Trail Blazers\"), \"team204\":(\"Spurs\");\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player100\":(95);\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player102\":(90);\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player102\" -&gt; \"player100\":(75);\nnebula&gt; INSERT EDGE serve(start_year, end_year) VALUES \"player101\" -&gt; \"team204\":(1999, 2018),\"player102\" -&gt; \"team203\":(2006,  2015);\n</code></pre> <ul> <li>This example goes one step from the vertex <code>player101</code> over all edge types and gets the subgraph.<pre><code>nebula&gt; GET SUBGRAPH 1 STEPS FROM \"player101\" YIELD VERTICES AS nodes, EDGES AS relationships;\n+-------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+\n| nodes                                                                   | relationships                                                                                                               |\n+-------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+\n| [(\"player101\" :player{})]                                               | [[:serve \"player101\"-&gt;\"team204\" @0 {}], [:follow \"player101\"-&gt;\"player100\" @0 {}], [:follow \"player101\"-&gt;\"player102\" @0 {}]] |\n| [(\"team204\" :team{}), (\"player100\" :player{}), (\"player102\" :player{})] | [[:follow \"player102\"-&gt;\"player100\" @0 {}]]                                                                                  |\n+-------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <p>The returned subgraph is as follows.</p> <p></p> </li> </ul> <ul> <li>This example goes one step from the vertex <code>player101</code> over incoming <code>follow</code> edges and gets the subgraph.<pre><code>nebula&gt; GET SUBGRAPH 1 STEPS FROM \"player101\" IN follow YIELD VERTICES AS nodes, EDGES AS relationships;\n+---------------------------+---------------+\n| nodes                     | relationships |\n+---------------------------+---------------+\n| [(\"player101\" :player{})] | []            |\n+---------------------------+---------------+\n</code></pre> <p>There is no incoming <code>follow</code> edge to <code>player101</code>, so only the vertex <code>player101</code> is returned.</p> </li> </ul> <ul> <li>This example goes one step from the vertex <code>player101</code> over outgoing <code>serve</code> edges, gets the subgraph, and shows the property of the edge.<pre><code>nebula&gt; GET SUBGRAPH WITH PROP 1 STEPS FROM \"player101\" OUT serve YIELD VERTICES AS nodes, EDGES AS relationships;\n+-------------------------------------------------------+-------------------------------------------------------------------------+\n| nodes                                                 | relationships                                                           |\n+-------------------------------------------------------+-------------------------------------------------------------------------+\n| [(\"player101\" :player{age: 36, name: \"Tony Parker\"})] | [[:serve \"player101\"-&gt;\"team204\" @0 {end_year: 2018, start_year: 1999}]] |\n| [(\"team204\" :team{name: \"Spurs\"})]                    | []                                                                      |\n+-------------------------------------------------------+-------------------------------------------------------------------------+\n</code></pre> <p>The returned subgraph is as follows.</p> <p></p> </li> </ul> <ul> <li>This example goes two steps from the vertex <code>player101</code> over <code>follow</code> edges, filters by degree &gt; 90 and age &gt; 30, and shows the properties of edges.<pre><code>nebula&gt; GET SUBGRAPH WITH PROP 2 STEPS FROM \"player101\" \\\n    WHERE follow.degree &gt; 90 AND $$.player.age &gt; 30 \\\n    YIELD VERTICES AS nodes, EDGES AS relationships;\n+-------------------------------------------------------+------------------------------------------------------+\n| nodes                                                 | relationships                                        |\n+-------------------------------------------------------+------------------------------------------------------+\n| [(\"player101\" :player{age: 36, name: \"Tony Parker\"})] | [[:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}]] |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"})]  | []                                                   |\n+-------------------------------------------------------+------------------------------------------------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#faq","title":"FAQ","text":""},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#why_is_the_number_of_hops_in_the_returned_result_greater_than_step_count","title":"Why is the number of hops in the returned result greater than <code>step_count</code>?","text":"<p>To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions. The following graph is used as the sample.</p> <p></p> <ul> <li>The returned paths of <code>GET SUBGRAPH 1 STEPS FROM \"A\";</code> are <code>A-&gt;B</code>, <code>B-&gt;A</code>, and <code>A-&gt;C</code>. To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions, namely <code>B-&gt;C</code>.</li> </ul> <ul> <li>The returned path of <code>GET SUBGRAPH 1 STEPS FROM \"A\" IN follow;</code> is <code>B-&gt;A</code>. To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions, namely <code>A-&gt;B</code>.</li> </ul> <p>If you only query paths or vertices that meet the conditions, we suggest you use MATCH or GO. The example is as follows.</p> <pre><code>nebula&gt; MATCH p= (v:player) -- (v2) WHERE id(v)==\"A\" RETURN p;\nnebula&gt; GO 1 STEPS FROM \"A\" OVER follow YIELD src(edge),dst(edge);\n</code></pre>"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#why_is_the_number_of_hops_in_the_returned_result_lower_than_step_count","title":"Why is the number of hops in the returned result lower than <code>step_count</code>?","text":"<p>The query stops when there is not enough subgraph data and will not return the null value.</p> <pre><code>nebula&gt; GET SUBGRAPH 100 STEPS FROM \"player101\" OUT follow YIELD VERTICES AS nodes, EDGES AS relationships;\n+----------------------------------------------------+--------------------------------------------------------------------------------------+\n| nodes                                              | relationships                                                                        |\n+----------------------------------------------------+--------------------------------------------------------------------------------------+\n| [(\"player101\" :player{})]                          | [[:follow \"player101\"-&gt;\"player100\" @0 {}], [:follow \"player101\"-&gt;\"player102\" @0 {}]] |\n| [(\"player100\" :player{}), (\"player102\" :player{})] | [[:follow \"player102\"-&gt;\"player100\" @0 {}]]                                           |\n+----------------------------------------------------+--------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/16.subgraph-and-path/2.find-path/","title":"FIND PATH","text":"<p>The <code>FIND PATH</code> statement finds the paths between the selected source vertices and destination vertices.</p> <p>Note</p> <p>To improve the query performance with the <code>FIND PATH</code> statement, you can add the <code>num_operator_threads</code> parameter in the <code>nebula-graphd.conf</code> configuration file. The value range of the <code>num_operator_threads</code> parameter is [2, 10] and make sure that the value is not greater than the number of CPU cores of the machine where the <code>graphd</code> service is deployed. It is recommended to set the value to the number of CPU cores of the machine where the <code>graphd</code> service is deployed. For more information about the <code>nebula-graphd.conf</code> configuration file, see nebula-graphd.conf.</p>"},{"location":"3.ngql-guide/16.subgraph-and-path/2.find-path/#syntax","title":"Syntax","text":"<pre><code>FIND { SHORTEST | SINGLE SHORTEST | ALL | NOLOOP } PATH [WITH PROP] FROM &lt;vertex_id_list&gt; TO &lt;vertex_id_list&gt;\nOVER &lt;edge_type_list&gt; [REVERSELY | BIDIRECT] \n[&lt;WHERE clause&gt;] [UPTO &lt;N&gt; {STEP|STEPS}] \nYIELD path as &lt;alias&gt;\n[| ORDER BY $-.path] [| LIMIT &lt;M&gt;];\n\n&lt;vertex_id_list&gt; ::=\n    [vertex_id [, vertex_id] ...]\n</code></pre> <ul> <li><code>SHORTEST</code> finds all the shortest path.</li> </ul> <ul> <li><code>ALL</code> finds all the paths.</li> </ul> <ul> <li><code>NOLOOP</code> finds the paths without circles.</li> </ul> <ul> <li><code>WITH PROP</code> shows properties of vertices and edges. If not specified, properties will be hidden.</li> </ul> <ul> <li><code>&lt;vertex_id_list&gt;</code> is a list of vertex IDs separated with commas (,). It supports <code>$-</code> and <code>$var</code>.</li> </ul> <ul> <li><code>&lt;edge_type_list&gt;</code> is a list of edge types separated with commas (,). <code>*</code> is all edge types.</li> </ul> <ul> <li><code>REVERSELY | BIDIRECT</code> specifies the direction. <code>REVERSELY</code> is reverse graph traversal while <code>BIDIRECT</code> is bidirectional graph traversal.</li> </ul> <ul> <li><code>&lt;WHERE clause&gt;</code> filters properties of edges.</li> </ul> <ul> <li><code>UPTO &lt;N&gt; {STEP|STEPS}</code> is the maximum hop number of the path. The default value is <code>5</code>.</li> </ul> <ul> <li><code>ORDER BY $-.path</code> specifies the order of the returned paths. For information about the order rules, see Path.</li> </ul> <ul> <li><code>LIMIT &lt;M&gt;</code> specifies the maximum number of rows to return.</li> </ul> <p>Note</p> <p>The path type of <code>FIND PATH</code> is <code>trail</code>. Only vertices can be repeatedly visited in graph traversal. For more information, see Path.</p>"},{"location":"3.ngql-guide/16.subgraph-and-path/2.find-path/#limitations","title":"Limitations","text":"<ul> <li>When a list of source and/or destination vertex IDs are specified, the paths between any source vertices and the destination vertices will be returned.</li> </ul> <ul> <li>There can be cycles when searching all paths.</li> </ul> <ul> <li><code>FIND PATH</code> only supports filtering properties of edges with <code>WHERE</code> clauses. Filtering properties of vertices and functions are not supported for now.</li> </ul> <ul> <li><code>FIND PATH</code> is a single-thread procedure, so it uses much memory.</li> </ul>"},{"location":"3.ngql-guide/16.subgraph-and-path/2.find-path/#examples","title":"Examples","text":"<p>A returned path is like <code>(&lt;vertex_id&gt;)-[:&lt;edge_type_name&gt;@&lt;rank&gt;]-&gt;(&lt;vertex_id)</code>.</p> <pre><code>nebula&gt; FIND SHORTEST PATH FROM \"player102\" TO \"team204\" OVER * YIELD path AS p;\n+--------------------------------------------+\n| p                                          |\n+--------------------------------------------+\n| &lt;(\"player102\")-[:serve@0 {}]-&gt;(\"team204\")&gt; |\n+--------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND SHORTEST PATH WITH PROP FROM \"team204\" TO \"player100\" OVER * REVERSELY YIELD path AS p;\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                    |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"team204\" :team{name: \"Spurs\"})&lt;-[:serve@0 {end_year: 2016, start_year: 1997}]-(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&gt; |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND SHORTEST PATH FROM \"player100\", \"player130\" TO \"player132\", \"player133\" OVER * BIDIRECT UPTO 18 STEPS YIELD path as p;\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                                                                              |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\")&lt;-[:follow@0 {}]-(\"player144\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                                                                                                                    |\n| &lt;(\"player100\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt;                                                                |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player112\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player114\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                                  |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player109\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player114\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                                  |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player104\")-[:serve@20182019 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player114\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                           |\n| ...                                                                                                                                                                                            |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player112\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt;        |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player109\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt;        |\n| ...                                                                                                                                                                                            |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND ALL PATH FROM \"player100\" TO \"team204\" OVER * WHERE follow.degree is EMPTY or follow.degree &gt;=0 YIELD path AS p;\n+------------------------------------------------------------------------------+\n| p                                                                            |\n+------------------------------------------------------------------------------+\n| &lt;(\"player100\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                                   |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")-[:serve@0 {}]-&gt;(\"team204\")&gt;     |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:serve@0 {}]-&gt;(\"team204\")&gt;     |\n|...                                                                           |\n+------------------------------------------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND NOLOOP PATH FROM \"player100\" TO \"team204\" OVER * YIELD path AS p;\n+--------------------------------------------------------------------------------------------------------+\n| p                                                                                                      |\n+--------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                                                             |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                               |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                               |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")-[:serve@0 {}]-&gt;(\"team204\")&gt; |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")-[:serve@0 {}]-&gt;(\"team204\")&gt; |\n+--------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/16.subgraph-and-path/2.find-path/#faq","title":"FAQ","text":""},{"location":"3.ngql-guide/16.subgraph-and-path/2.find-path/#does_it_support_the_where_clause_to_achieve_conditional_filtering_during_graph_traversal","title":"Does it support the WHERE clause to achieve conditional filtering during graph traversal?","text":"<p><code>FIND PATH</code> only supports filtering properties of edges with <code>WHERE</code> clauses, such as <code>WHERE follow.degree is EMPTY or follow.degree &gt;=0</code>.</p> <p>Filtering properties of vertices is not supported for now.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/","title":"EXPLAIN and PROFILE","text":"<p><code>EXPLAIN</code> helps output the execution plan of an nGQL statement without executing the statement.</p> <p><code>PROFILE</code> executes the statement, then outputs the execution plan as well as the execution profile. You can optimize the queries for better performance according to the execution plan and profile.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#execution_plan","title":"Execution Plan","text":"<p>The execution plan is determined by the execution planner in the NebulaGraph query engine.</p> <p>The execution planner processes the parsed nGQL statements into <code>actions</code>. An <code>action</code> is the smallest unit that can be executed. A typical <code>action</code> fetches all neighbors of a given vertex, gets the properties of an edge, and filters vertices or edges based on the given conditions. Each <code>action</code> is assigned to an <code>operator</code> that performs the action.</p> <p>For example, a <code>SHOW TAGS</code> statement is processed into two <code>actions</code> and assigned to a <code>Start operator</code> and a <code>ShowTags operator</code>, while a more complex <code>GO</code> statement may be processed into more than 10 <code>actions</code> and assigned to 10 operators.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#syntax","title":"Syntax","text":"<ul> <li><code>EXPLAIN</code><pre><code>EXPLAIN [format= {\"row\" | \"dot\" | \"tck\"}] &lt;your_nGQL_statement&gt;;\n</code></pre> </li> </ul> <ul> <li><code>PROFILE</code><pre><code>PROFILE [format= {\"row\" | \"dot\" | \"tck\"}] &lt;your_nGQL_statement&gt;;\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#output_formats","title":"Output formats","text":"<p>The output of an <code>EXPLAIN</code> or a <code>PROFILE</code> statement has three formats, the default <code>row</code> format, the <code>dot</code> format, and the <code>tck</code> format. You can use the <code>format</code> option to modify the output format. Omitting the <code>format</code> option indicates using the default <code>row</code> format.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#the_row_format","title":"The <code>row</code> format","text":"<p>The <code>row</code> format outputs the return message in a table as follows.</p> <ul> <li><code>EXPLAIN</code><pre><code>nebula&gt; EXPLAIN format=\"row\" SHOW TAGS;\nExecution succeeded (time spent 327/892 us)\n\nExecution Plan\n\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n| id | name     | dependencies | profiling data | operator info                                                       |\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n|  1 | ShowTags | 0            |                | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_1\",\"type\":\"DATASET\"}] |\n|    |          |              |                | inputVar:                                                           |\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n|  0 | Start    |              |                | outputVar: [{\"colNames\":[],\"name\":\"__Start_0\",\"type\":\"DATASET\"}]    |\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n</code></pre> </li> </ul> <ul> <li><code>PROFILE</code><pre><code>nebula&gt; PROFILE format=\"row\" SHOW TAGS;\n+--------+\n| Name   |\n+--------+\n| player |\n+--------+\n| team   |\n+--------+\nGot 2 rows (time spent 2038/2728 us)\n\nExecution Plan\n\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n| id | name     | dependencies | profiling data                                     | operator info                                                       |\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n|  1 | ShowTags | 0            | ver: 0, rows: 1, execTime: 42us, totalTime: 1177us | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_1\",\"type\":\"DATASET\"}] |\n|    |          |              |                                                    | inputVar:                                                           |\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n|  0 | Start    |              | ver: 0, rows: 0, execTime: 1us, totalTime: 57us    | outputVar: [{\"colNames\":[],\"name\":\"__Start_0\",\"type\":\"DATASET\"}]    |\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n</code></pre> </li> </ul> <p>The descriptions are as follows.</p> Parameter Description <code>id</code> The ID of the <code>operator</code>. <code>name</code> The name of the <code>operator</code>. <code>dependencies</code> The ID of the <code>operator</code> that the current <code>operator</code> depends on. <code>profiling data</code> The content of the execution profile. <code>ver</code> is the version of the <code>operator</code>. <code>rows</code> shows the number of rows to be output by the <code>operator</code>. <code>execTime</code> shows the execution time of <code>action</code>. <code>totalTime</code> is the sum of the execution time, the system scheduling time, and the queueing time. <code>operator info</code> The detailed information of the <code>operator</code>."},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#the_dot_format","title":"The <code>dot</code> format","text":"<p>You can use the <code>format=\"dot\"</code> option to output the return message in the <code>dot</code> language, and then use Graphviz to generate a graph of the plan.</p> <p>Note</p> <p>Graphviz is open source graph visualization software. Graphviz provides an online tool for previewing DOT language files and exporting them to other formats such as SVG or JSON. For more information, see Graphviz Online.</p> <pre><code>nebula&gt; EXPLAIN format=\"dot\" SHOW TAGS;\nExecution succeeded (time spent 161/665 us)\nExecution Plan\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n  plan\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n  digraph exec_plan {\n      rankdir=LR;\n      \"ShowTags_0\"[label=\"ShowTags_0|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__ShowTags_0\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar:\\l\",   shape=Mrecord];\n      \"Start_2\"-&gt;\"ShowTags_0\";\n      \"Start_2\"[label=\"Start_2|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__Start_2\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar: \\l\",   shape=Mrecord];\n  }\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n</code></pre> <p>The Graphviz graph transformed from the above DOT statement is as follows.</p> <p></p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#the_tck_format","title":"The <code>tck</code> format","text":"<p>The tck format is similar to a table, but without borders and dividing lines between rows. You can use the results as test cases for unit testing.  For information on tck format test cases, see TCK cases.</p> <ul> <li><code>EXPLAIN</code><pre><code>nebula&gt; EXPLAIN format=\"tck\" FETCH PROP ON player \"player_1\",\"player_2\",\"player_3\" YIELD properties(vertex).name as name, properties(vertex).age as age;\nExecution succeeded (time spent 261\u00b5s/613.718\u00b5s)\nExecution Plan (optimize time 28 us)\n| id | name        | dependencies | profiling data | operator info |\n|  2 | Project     | 1            |                |               |\n|  1 | GetVertices | 0            |                |               |\n|  0 | Start       |              |                |               |\n\nWed, 22 Mar 2023 23:15:52 CST\n</code></pre> </li> </ul> <ul> <li><code>PROFILE</code><pre><code>nebula&gt; PROFILE format=\"tck\" FETCH PROP ON player \"player_1\",\"player_2\",\"player_3\" YIELD properties(vertex).name as name, properties(vertex).age as age;\n| name         | age |\n| \"Piter Park\" | 24  |\n| \"aaa\"        | 24  |\n| \"ccc\"        | 24  |\nGot 3 rows (time spent 1.474ms/2.19677ms)\nExecution Plan (optimize time 41 us)\n| id | name        | dependencies | profiling data                                                                                                      | operator info |\n|  2 | Project     | 1            | {\"rows\":3,\"version\":0}                                                                                              |               |\n|  1 | GetVertices | 0            | {\"resp[0]\":{\"exec\":\"232(us)\",\"host\":\"127.0.0.1:9779\",\"total\":\"758(us)\"},\"rows\":3,\"total_rpc\":\"875(us)\",\"version\":0} |               |\n|  0 | Start       |              | {\"rows\":0,\"version\":0}                                                                                              |               |\nWed, 22 Mar 2023 23:16:13 CST\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/2.kill-session/","title":"Kill sessions","text":"<p>The <code>KILL SESSION</code> command is to terminate running sessions.</p> <p>Note</p> <ul> <li>Only the NebulaGraph <code>root</code> user can terminate sessions.</li> <li>After executing the <code>KILL SESSION</code> command, all Graph services synchronize the latest session information after <code>2* session_reclaim_interval_secs</code> seconds (<code>120</code> seconds by default).</li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/2.kill-session/#syntax","title":"Syntax","text":"<p>You can run the <code>KILL SESSION</code> command to terminate one or multiple sessions. The syntax is as follows:</p> <ul> <li> <p>To terminate one session</p> <pre><code>KILL {SESSION|SESSIONS} &lt;SessionId&gt;\n</code></pre> <ul> <li><code>{SESSION|SESSIONS}</code>: <code>SESSION</code> or <code>SESSIONS</code>, both are supported. </li> <li><code>&lt;SessionId&gt;</code>: Specifies the ID of one session. You can run the SHOW SESSIONS command to view the IDs of sessions.</li> </ul> </li> </ul> <ul> <li> <p>To terminate multiple sessions</p> <pre><code>SHOW SESSIONS \n| YIELD $-.SessionId AS sid [WHERE &lt;filter_clause&gt;]\n| KILL {SESSION|SESSIONS} $-.sid\n</code></pre> <p>Note</p> <p>The <code>KILL SESSION</code> command supports the pipeline operation, combining the <code>SHOW SESSIONS</code> command with the <code>KILL SESSION</code> command to terminate multiple sessions.</p> <ul> <li><code>[WHERE &lt;filter_clause&gt;]</code>\uff1a<ul> <li>Optional, the <code>WHERE</code> clause is used to filter sessions. <code>&lt;filter_expression&gt;</code> specifies a session filtering expression, for example, <code>WHERE $-.CreateTime &lt; datetime(\"2022-12-14T18:00:00\")</code>. If the <code>WHERE</code> clause is not specified, all sessions are terminated.</li> <li>Filtering conditions in a <code>WHERE</code> clause include: <code>SessionId</code>, <code>UserName</code>, <code>SpaceName</code>, <code>CreateTime</code>, <code>UpdateTime</code>, <code>GraphAddr</code>, <code>Timezone</code>, and <code>ClientIp</code>. You can run the SHOW SESSIONS command to view descriptions of these conditions.</li> </ul> </li> </ul> <ul> <li><code>{SESSION|SESSIONS}</code>: <code>SESSION</code> or <code>SESSIONS</code>, both are supported.</li> </ul> <p>Caution</p> <p>Please use filtering conditions with caution to avoid deleting sessions by mistake.</p> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/2.kill-session/#examples","title":"Examples","text":"<ul> <li> <p>To terminate one session</p> <pre><code>nebula&gt; KILL SESSION 1672887983842984 \n</code></pre> </li> </ul> <ul> <li> <p>To terminate multiple sessions</p> <ul> <li> <p>Terminate all sessions whose creation time is less than <code>2023-01-05T18:00:00</code>.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId AS sid WHERE $-.CreateTime &lt; datetime(\"2023-01-05T18:00:00\") | KILL SESSIONS $-.sid\n</code></pre> </li> </ul> <ul> <li> <p>Terminates the two sessions with the earliest creation times.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId AS sid, $-.CreateTime as CreateTime | ORDER BY $-.CreateTime ASC | LIMIT 2 | KILL SESSIONS $-.sid\n</code></pre> </li> </ul> <ul> <li> <p>Terminates all sessions created by the username <code>session_user1</code>.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId as sid WHERE $-.UserName == \"session_user1\" | KILL SESSIONS $-.sid\n</code></pre> </li> </ul> <ul> <li> <p>Terminate all sessions.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId as sid | KILL SESSION $-.sid\n\n// Or\nnebula&gt; SHOW SESSIONS | KILL SESSIONS $-.SessionId\n</code></pre> <p>Caution</p> <p>When you terminate all sessions, the current session is terminated. Please use it with caution.</p> </li> </ul> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/6.kill-query/","title":"Kill queries","text":"<p><code>KILL QUERY</code> can terminate the query being executed, and is often used to terminate slow queries.</p> <p>Note</p> <p>Users with the God role can kill any query. Other roles can only kill their own queries.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/6.kill-query/#syntax","title":"Syntax","text":"<pre><code>KILL QUERY (session=&lt;session_id&gt;, plan=&lt;plan_id&gt;);\n</code></pre> <ul> <li><code>session_id</code>: The ID of the session.</li> <li><code>plan_id</code>: The ID of the execution plan.</li> </ul> <p>The ID of the session and the ID of the execution plan can uniquely determine a query. Both can be obtained through the SHOW QUERIES statement.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/6.kill-query/#examples","title":"Examples","text":"<p>This example executes <code>KILL QUERY</code> in one session to terminate the query in another session.</p> <pre><code>nebula&gt; KILL QUERY(SESSION=1625553545984255,PLAN=163);\n</code></pre> <p>The query will be terminated and the following information will be returned.</p> <pre><code>[ERROR (-1005)]: ExecutionPlanId[1001] does not exist in current Session.\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/1.numeric/","title":"Numeric types","text":"<p>nGQL supports both integer and floating-point number.</p>"},{"location":"3.ngql-guide/3.data-types/1.numeric/#integer","title":"Integer","text":"<p>Signed 64-bit integer (INT64), 32-bit integer (INT32), 16-bit integer (INT16), and 8-bit integer (INT8) are supported.</p> Type Declared keywords Range INT64 <code>INT64</code> or<code>INT</code> -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 INT32 <code>INT32</code> -2,147,483,648 ~ 2,147,483,647 INT16 <code>INT16</code> -32,768 ~ 32,767 INT8 <code>INT8</code> -128 ~ 127"},{"location":"3.ngql-guide/3.data-types/1.numeric/#floating-point_number","title":"Floating-point number","text":"<p>Both single-precision floating-point format (FLOAT) and double-precision floating-point format (DOUBLE) are supported.</p> Type Declared keywords Range Precision FLOAT <code>FLOAT</code> 3.4E +/- 38 6~7 bits DOUBLE <code>DOUBLE</code> 1.7E +/- 308 15~16 bits <p>Scientific notation is also supported, such as <code>1e2</code>, <code>1.1e2</code>, <code>.3e4</code>, <code>1.e4</code>, and <code>-1234E-10</code>.</p> <p>Note</p> <p>The data type of DECIMAL in MySQL is not supported.</p>"},{"location":"3.ngql-guide/3.data-types/1.numeric/#reading_and_writing_of_data_values","title":"Reading and writing of data values","text":"<p>When writing and reading different types of data, nGQL complies with the following rules:</p> Data type Set as VID Set as property Resulted data type INT64 Supported Supported INT64 INT32 Not supported Supported INT64 INT16 Not supported Supported INT64 INT8 Not supported Supported INT64 FLOAT Not supported Supported DOUBLE DOUBLE Not supported Supported DOUBLE <p>For example, nGQL does not support setting VID as INT8, but supports setting a certain property type of TAG or Edge type as INT8. When using the nGQL statement to read the property of INT8, the resulted type is INT64.</p> <ul> <li> <p>Multiple formats are supported:</p> <ul> <li>Decimal, such as <code>123456</code>.</li> <li>Hexadecimal, such as <code>0x1e240</code>.</li> <li>Octal, such as <code>0361100</code>.</li> </ul> <p>However, NebulaGraph will parse the written non-decimal value into a decimal value and save it. The value read is decimal.</p> <p>For example, the type of the property <code>score</code> is <code>INT</code>. The value of <code>0xb</code> is assigned to it through the INSERT statement. If querying the property value with statements such as FETCH, you will get the result <code>11</code>, which is the decimal result of the hexadecimal <code>0xb</code>.</p> </li> </ul> <ul> <li>Round a FLOAT/DOUBLE value when inserting it to an INT column.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/10.geography/","title":"Geography","text":"<p>Geography is a data type composed of latitude and longitude that represents geospatial information. NebulaGraph currently supports Point, LineString, and Polygon in Simple Features and some functions in SQL-MM 3, such as part of the core geo parsing, construction, formatting, conversion, predicates, and dimensions.</p>"},{"location":"3.ngql-guide/3.data-types/10.geography/#type_description","title":"Type description","text":"<p>A point is the basic data type of geography, which is determined by a latitude and a longitude. For example, <code>\"POINT(3 8)\"</code> means that the longitude is <code>3\u00b0</code> and the latitude is <code>8\u00b0</code>. Multiple points can form a linestring or a polygon.</p> <p>Note</p> <p>You cannot directly insert geographic data of the following types, such as <code>INSERT VERTEX any_shape(geo) VALUES \"1\":(\"POINT(1 1)\")</code>. Instead, you need to use a geography function to specify the data type before inserting, such as <code>INSERT VERTEX any_shape(geo) VALUES \"1\":(ST_GeogFromText(\"POINT(1 1)\"));</code>.</p> Shape Example Description Point <code>\"POINT(3 8)\"</code> Specifies the data type as a point. LineString <code>\"LINESTRING(3 8, 4.7 73.23)\"</code> Specifies the data type as a linestring. Polygon <code>\"POLYGON((0 1, 1 2, 2 3, 0 1))\"</code> Specifies the data type as a polygon."},{"location":"3.ngql-guide/3.data-types/10.geography/#examples","title":"Examples","text":"<pre><code>//Create a Tag to allow storing any geography data type.\nnebula&gt; CREATE TAG IF NOT EXISTS any_shape(geo geography);\n\n//Create a Tag to allow storing a point only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_point(geo geography(point));\n\n//Create a Tag to allow storing a linestring only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_linestring(geo geography(linestring));\n\n//Create a Tag to allow storing a polygon only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_polygon(geo geography(polygon));\n\n//Create an Edge type to allow storing any geography data type.\nnebula&gt; CREATE EDGE IF NOT EXISTS any_shape_edge(geo geography);\n\n//Create a vertex to store the geography of a polygon.\nnebula&gt; INSERT VERTEX any_shape(geo) VALUES \"103\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n\n//Create an edge to store the geography of a polygon.\nnebula&gt; INSERT EDGE any_shape_edge(geo) VALUES \"201\"-&gt;\"302\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n\n//Query the geography of Vertex 103.\nnebula&gt; FETCH PROP ON any_shape \"103\" YIELD ST_ASText(any_shape.geo);\n+---------------------------------+\n| ST_ASText(any_shape.geo)        |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n\n//Query the geography of the edge which traverses from Vertex 201 to Vertex 302.\nnebula&gt; FETCH PROP ON any_shape_edge \"201\"-&gt;\"302\" YIELD ST_ASText(any_shape_edge.geo);\n+---------------------------------+\n| ST_ASText(any_shape_edge.geo)   |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n\n//Create an index for the geography of the Tag any_shape and run LOOKUP.\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo);\nnebula&gt; REBUILD TAG INDEX any_shape_geo_index;\nnebula&gt; LOOKUP ON any_shape YIELD ST_ASText(any_shape.geo);\n+---------------------------------+\n| ST_ASText(any_shape.geo)        |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n</code></pre> <p>When creating an index for geography properties, you can specify the parameters for the index.</p> Parameter Default value Description <code>s2_max_level</code> <code>30</code> The maximum level of S2 cell used in the covering. Allowed values: <code>1</code>~<code>30</code>. Setting it to less than the default means that NebulaGraph will be forced to generate coverings using larger cells. <code>s2_max_cells</code> <code>8</code> The maximum number of S2 cells used in the covering. Provides a limit on how much work is done exploring the possible coverings. Allowed values: <code>1</code>~<code>30</code>. You may want to use higher values for odd-shaped regions such as skinny rectangles. <p>Note</p> <p>Specifying the above two parameters does not affect the Point type of property. The <code>s2_max_level</code> value of the Point type is forced to be <code>30</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo) with (s2_max_level=30, s2_max_cells=8);\n</code></pre> <p>For more index information, see Index overview.</p>"},{"location":"3.ngql-guide/3.data-types/2.boolean/","title":"Boolean","text":"<p>A boolean data type is declared with the <code>bool</code> keyword and can only take the values <code>true</code> or <code>false</code>.</p> <p>nGQL supports using boolean in the following ways:</p> <ul> <li>Define the data type of the property value as a boolean.</li> <li>Use boolean as judgment conditions in the <code>WHERE</code> clause.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/","title":"String","text":"<p>Fixed-length strings and variable-length strings are supported.</p>"},{"location":"3.ngql-guide/3.data-types/3.string/#declaration_and_literal_representation","title":"Declaration and literal representation","text":"<p>The string type is declared with the keywords of:</p> <ul> <li><code>STRING</code>: Variable-length strings.</li> <li><code>FIXED_STRING(&lt;length&gt;)</code>: Fixed-length strings. <code>&lt;length&gt;</code> is the length of the string, such as <code>FIXED_STRING(32)</code>.</li> </ul> <p>A string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example, <code>\"Hello, Cooper\"</code> or <code>'Hello, Cooper'</code>.</p>"},{"location":"3.ngql-guide/3.data-types/3.string/#string_reading_and_writing","title":"String reading and writing","text":"<p>Nebula\u00a0Graph supports using string types in the following ways:</p> <ul> <li>Define the data type of VID as a fixed-length string.</li> <li>Set the variable-length string as the Schema name, including the names of the graph space, tag, edge type, and property.</li> <li>Define the data type of the property as a fixed-length or variable-length string.</li> </ul> <p>For example:</p> <ul> <li>Define the data type of the property as a fixed-length string<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t1 (p1 FIXED_STRING(10)); \n</code></pre> </li> </ul> <ul> <li>Define the data type of the property as a variable-length string<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t2 (p2 STRING); \n</code></pre> </li> </ul> <p>When the fixed-length string you try to write exceeds the length limit:</p> <ul> <li>If the fixed-length string is a property, the writing will succeed, and NebulaGraph will truncate the string and only store the part that meets the length limit.</li> <li>If the fixed-length string is a VID, the writing will fail and NebulaGraph will return an error.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/#escape_characters","title":"Escape characters","text":"<p>Line breaks are not allowed in a string. Escape characters are supported within strings, for example:</p> <ul> <li><code>\"\\n\\t\\r\\b\\f\"</code></li> </ul> <ul> <li><code>\"\\110ello world\"</code></li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>There are some tiny differences between openCypher and Cypher, as well as nGQL. The following is what openCypher requires. Single quotes cannot be converted to double quotes.</p> <pre><code># File: Literals.feature\nFeature: Literals\n\nBackground:\n    Given any graph\n Scenario: Return a single-quoted string\n    When executing query:\n      \"\"\"\n      RETURN '' AS literal\n      \"\"\"\n    Then the result should be, in any order:\n      | literal |\n      | ''      |    # Note: it should return single-quotes as openCypher required.\n    And no side effects\n</code></pre> <p>While Cypher accepts both single quotes and double quotes as the return results. nGQL follows the Cypher way.</p> <pre><code>nebula &gt; YIELD '' AS quote1, \"\" AS quote2, \"'\" AS quote3, '\"' AS quote4\n+--------+--------+--------+--------+\n| quote1 | quote2 | quote3 | quote4 |\n+--------+--------+--------+--------+\n| \"\"     | \"\"     | \"'\"    | \"\"\"    |\n+--------+--------+--------+--------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/","title":"Date and time types","text":"<p>This topic will describe the <code>DATE</code>, <code>TIME</code>, <code>DATETIME</code>, <code>TIMESTAMP</code>, and <code>DURATION</code> types.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#precautions","title":"Precautions","text":"<ul> <li> <p>While inserting time-type property values with <code>DATE</code>, <code>TIME</code>, and <code>DATETIME</code>, NebulaGraph transforms them to a UTC time according to the timezone specified with the <code>timezone_name</code> parameter in the configuration files. </p> <p>Note</p> <p>To change the timezone, modify the <code>timezone_name</code> value in the configuration files of all NebulaGraph services.</p> </li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, and <code>datetime()</code> can convert a time-type property with a specified timezone. For example, <code>datetime(\"2017-03-04 22:30:40.003000+08:00\")</code> or <code>datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\")</code>.</li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, <code>datetime()</code>, and <code>timestamp()</code> all accept empty parameters to return the current date, time, and datetime.</li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, and <code>datetime()</code> all accept the property name to return a specific property value of itself. For example, <code>date().month</code> returns the current month, while <code>time(\"02:59:40\").minute</code> returns the minutes of the importing time.</li> </ul> <ul> <li>For time operations it is recommended to use <code>duration()</code> to calculate the offset of the moment. Addition and subtraction of <code>date()</code> and <code>date()</code>, <code>timestamp()</code> and <code>timestamp()</code> are also supported.</li> </ul> <ul> <li>When setting the year of the time as a negative number, you need to use Map type data.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>In nGQL:</p> <ul> <li>Year, month, day, hour, minute, second, millisecond, and microsecond are supported, while the nanosecond is not supported.</li> </ul> <ul> <li><code>localdatetime()</code> is not supported.</li> </ul> <ul> <li>Most string time formats are not supported. The exceptions are <code>YYYY-MM-DDThh:mm:ss</code> and <code>YYYY-MM-DD hh:mm:ss</code>.</li> </ul> <ul> <li>The single-digit string time format is supported. For example, <code>time(\"1:1:1\")</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#date","title":"DATE","text":"<p>The <code>DATE</code> type is used for values with a date part but no time part. Nebula\u00a0Graph retrieves and displays <code>DATE</code> values in the <code>YYYY-MM-DD</code> format. The supported range is <code>-32768-01-01</code> to <code>32767-12-31</code>.</p> <p>The properties of <code>date()</code> include <code>year</code>, <code>month</code>, and <code>day</code>. <code>date()</code> supports the input of <code>YYYYY</code>, <code>YYYYY-MM</code> or <code>YYYYY-MM-DD</code>, and defaults to <code>01</code> for an untyped month or day.</p> <pre><code>nebula&gt; RETURN DATE({year:-123, month:12, day:3});\n+------------------------------------+\n| date({year:-(123),month:12,day:3}) |\n+------------------------------------+\n| -123-12-03                         |\n+------------------------------------+\n\nnebula&gt; RETURN DATE(\"23333\");\n+---------------+\n| date(\"23333\") |\n+---------------+\n| 23333-01-01   |\n+---------------+\n\nnebula&gt; RETURN DATE(\"2023-12-12\") - DATE(\"2023-12-11\");\n+-----------------------------------------+\n| (date(\"2023-12-12\")-date(\"2023-12-11\")) |\n+-----------------------------------------+\n| 1                                       |\n+-----------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#time","title":"TIME","text":"<p>The <code>TIME</code> type is used for values with a time part but no date part. Nebula\u00a0Graph retrieves and displays <code>TIME</code> values in <code>hh:mm:ss.msmsmsususus</code> format. The supported range is <code>00:00:00.000000</code> to <code>23:59:59.999999</code>.</p> <p>The properties of <code>time()</code> include <code>hour</code>, <code>minute</code>, and <code>second</code>.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#datetime","title":"DATETIME","text":"<p>The <code>DATETIME</code> type is used for values that contain both date and time parts. Nebula\u00a0Graph retrieves and displays <code>DATETIME</code> values in <code>YYYY-MM-DDThh:mm:ss.msmsmsususus</code> format. The supported range is <code>-32768-01-01T00:00:00.000000</code> to <code>32767-12-31T23:59:59.999999</code>.</p> <ul> <li>The properties of <code>datetime()</code> include <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, and <code>second</code>.</li> </ul> <ul> <li><code>datetime()</code> can convert <code>TIMESTAMP</code> to <code>DATETIME</code>. The value range of <code>TIMESTAMP</code> is <code>0~9223372036</code>.</li> </ul> <ul> <li><code>datetime()</code> supports an <code>int</code> argument. The <code>int</code> argument specifies a timestamp.</li> </ul> <pre><code># To get the current date and time.\nnebula&gt; RETURN datetime();\n+----------------------------+\n| datetime()                 |\n+----------------------------+\n| 2022-08-29T06:37:08.933000 |\n+----------------------------+\n\n# To get the current hour.\nnebula&gt; RETURN datetime().hour;\n+-----------------+\n| datetime().hour |\n+-----------------+\n| 6               |\n+-----------------+\n\n# To get date time from a given timestamp.\nnebula&gt; RETURN datetime(timestamp(1625469277));\n+---------------------------------+\n| datetime(timestamp(1625469277)) |\n+---------------------------------+\n| 2021-07-05T07:14:37.000000      |\n+---------------------------------+\n\nnebula&gt; RETURN datetime(1625469277);\n+----------------------------+\n| datetime(1625469277)       |\n+----------------------------+\n| 2021-07-05T07:14:37.000000 |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#timestamp","title":"TIMESTAMP","text":"<p>The <code>TIMESTAMP</code> data type is used for values that contain both date and time parts. It has a range of <code>1970-01-01T00:00:01</code> UTC to <code>2262-04-11T23:47:16</code> UTC.</p> <p><code>TIMESTAMP</code> has the following features:</p> <ul> <li>Stored and displayed in the form of a timestamp, such as <code>1615974839</code>, which means <code>2021-03-17T17:53:59</code>.</li> </ul> <ul> <li>Supported <code>TIMESTAMP</code> querying methods: timestamp and <code>timestamp()</code> function.</li> </ul> <ul> <li>Supported <code>TIMESTAMP</code> inserting methods: timestamp, <code>timestamp()</code> function, and <code>now()</code> function.</li> </ul> <ul> <li><code>timestamp()</code> function accepts empty arguments to get the current timestamp. It can pass an integer arguments to identify the integer as a timestamp and the range of passed integer is: <code>0~9223372036</code>\u3002</li> </ul> <ul> <li><code>timestamp()</code> function can convert <code>DATETIME</code> to <code>TIMESTAMP</code>, and the data type of <code>DATETIME</code> should be a <code>string</code>. </li> </ul> <ul> <li>The underlying storage data type is int64.</li> </ul> <pre><code># To get the current timestamp.\nnebula&gt; RETURN timestamp();\n+-------------+\n| timestamp() |\n+-------------+\n| 1625469277  |\n+-------------+\n\n# To get a timestamp from given date and time.\nnebula&gt; RETURN timestamp(\"2022-01-05T06:18:43\");\n+----------------------------------+\n| timestamp(\"2022-01-05T06:18:43\") |\n+----------------------------------+\n| 1641363523                       |\n+----------------------------------+\n\n# To get a timestamp using datetime().\nnebula&gt; RETURN timestamp(datetime(\"2022-08-29T07:53:10.939000\"));\n+---------------------------------------------------+\n| timestamp(datetime(\"2022-08-29T07:53:10.939000\")) |\n+---------------------------------------------------+\n| 1661759590                                        |\n+---------------------------------------------------+    \n</code></pre> <p>Note</p> <p>The date and time format string passed into <code>timestamp()</code> cannot include any millisecond and microsecond, but the date and time format string passed into <code>timestamp(datetime())</code> can include a millisecond and a microsecond.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#duration","title":"DURATION","text":"<p>The <code>DURATION</code> data type is used to indicate a period of time. Map data that are freely combined by <code>years</code>, <code>months</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, and <code>seconds</code> indicates the <code>DURATION</code>.</p> <p><code>DURATION</code> has the following features:</p> <ul> <li>Creating indexes for <code>DURATION</code> is not supported.</li> </ul> <ul> <li><code>DURATION</code> can be used to calculate the specified time.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#examples","title":"Examples","text":"<ol> <li> <p>Create a tag named <code>date1</code> with three properties: <code>DATE</code>, <code>TIME</code>, and <code>DATETIME</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS date1(p1 date, p2 time, p3 datetime);\n</code></pre> </li> <li> <p>Insert a vertex named <code>test1</code>.</p> <pre><code>nebula&gt; INSERT VERTEX date1(p1, p2, p3) VALUES \"test1\":(date(\"2021-03-17\"), time(\"17:53:59\"), datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\"));\n</code></pre> </li> <li> <p>Query whether the value of property <code>p1</code> on the <code>test1</code> tag is <code>2021-03-17</code>.</p> <pre><code>nebula&gt; MATCH (v:date1)  RETURN v.date1.p1 == date(\"2021-03-17\");\n+----------------------------------+\n| (v.date1.p1==date(\"2021-03-17\")) |\n+----------------------------------+\n| true                             |\n+----------------------------------+\n</code></pre> </li> <li> <p>Return the content of the property <code>p1</code> on <code>test1</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS date1_index ON date1(p1);\nnebula&gt; REBUILD TAG INDEX date1_index;\nnebula&gt; MATCH (v:date1) RETURN v.date1.p1;\n+------------------+\n| v.date1.p1.month |\n+------------------+\n| 3                |\n+------------------+\n</code></pre> </li> <li> <p>Search for vertices with <code>p3</code> property values less than <code>2023-01-01T00:00:00.000000</code>, and return the <code>p3</code> values.</p> <pre><code>nebula&gt; MATCH (v:date1)  \\\nWHERE v.date1.p3 &lt; datetime(\"2023-01-01T00:00:00.000000\") \\\nRETURN v.date1.p3;\n+----------------------------+\n| v.date1.p3                 |\n+----------------------------+\n| 2017-03-04T14:30:40.003000 |\n+----------------------------+\n</code></pre> </li> <li> <p>Create a tag named <code>school</code> with the property of <code>TIMESTAMP</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS school(name string , found_time timestamp);\n</code></pre> </li> <li> <p>Insert a vertex named <code>DUT</code> with a found-time timestamp of <code>\"1988-03-01T08:00:00\"</code>.</p> <pre><code># Insert as a timestamp. The corresponding timestamp of 1988-03-01T08:00:00 is 573177600, or 573206400 UTC.\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", 573206400);\n\n# Insert in the form of date and time.\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", timestamp(\"1988-03-01T08:00:00\"));\n</code></pre> </li> <li> <p>Insert a vertex named <code>dut</code> and store time with <code>now()</code> or <code>timestamp()</code> functions.</p> <pre><code># Use now() function to store time\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", now());\n\n# Use timestamp() function to store time\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", timestamp());\n</code></pre> </li> </ol> <p>You can also use <code>WITH</code> statement to set a specific date and time, or to perform calculations. For example:</p> <pre><code>nebula&gt; WITH time({hour: 12, minute: 31, second: 14, millisecond:111, microsecond: 222}) AS d RETURN d;\n+-----------------+\n| d               |\n+-----------------+\n| 12:31:14.111222 |\n+-----------------+\n\nnebula&gt; WITH date({year: 1984, month: 10, day: 11}) AS x RETURN x + 1;\n+------------+\n| (x+1)      |\n+------------+\n| 1984-10-12 |\n+------------+\n\nnebula&gt; WITH date('1984-10-11') as x, duration({years: 12, days: 14, hours: 99, minutes: 12}) as d \\\n        RETURN x + d AS sum, x - d AS diff;\n+------------+------------+\n| sum        | diff       |\n+------------+------------+\n| 1996-10-29 | 1972-09-23 |\n+------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/5.null/","title":"NULL","text":"<p>You can set the properties for vertices or edges to <code>NULL</code>. Also, you can set the <code>NOT NULL</code> constraint to make sure that the property values are <code>NOT NULL</code>. If not specified, the property is set to <code>NULL</code> by default.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#logical_operations_with_null","title":"Logical operations with NULL","text":"<p>Here is the truth table for <code>AND</code>, <code>OR</code>, <code>XOR</code>, and <code>NOT</code>.</p> a b a AND b a OR b a XOR b NOT a false false false false false true false null false null null true false true false true true true true false false true true false true null null true null false true true true true false false null false false null null null null null null null null null null true null true null null"},{"location":"3.ngql-guide/3.data-types/5.null/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>The comparisons and operations about NULL are different from openCypher. There may be changes later.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#comparisons_with_null","title":"Comparisons with NULL","text":"<p>The comparison operations with NULL are incompatible with openCypher.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#operations_and_return_with_null","title":"Operations and RETURN with NULL","text":"<p>The NULL operations and RETURN with NULL are incompatible with openCypher.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/3.data-types/5.null/#use_not_null","title":"Use NOT NULL","text":"<p>Create a tag named <code>player</code>. Specify the property <code>name</code> as <code>NOT NULL</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string NOT NULL, age int);\n</code></pre> <p>Use <code>SHOW</code> to create tag statements. The property <code>name</code> is <code>NOT NULL</code>. The property <code>age</code> is <code>NULL</code> by default.</p> <pre><code>nebula&gt; SHOW CREATE TAG player;\n+-----------+-----------------------------------+\n| Tag       | Create Tag                        |\n+-----------+-----------------------------------+\n| \"student\" | \"CREATE TAG `player` (            |\n|           |  `name` string NOT NULL,          |\n|           |  `age` int64 NULL                 |\n|           | ) ttl_duration = 0, ttl_col = \"\"\" |\n+-----------+-----------------------------------+\n</code></pre> <p>Insert the vertex <code>Kobe</code>. The property <code>age</code> can be <code>NULL</code>.</p> <pre><code>nebula&gt; INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null);\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/5.null/#use_not_null_and_set_the_default","title":"Use NOT NULL and set the default","text":"<p>Create a tag named <code>player</code>. Specify the property <code>age</code> as <code>NOT NULL</code>. The default value is <code>18</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int NOT NULL DEFAULT 18);\n</code></pre> <p>Insert the vertex <code>Kobe</code>. Specify the property <code>name</code> only.</p> <pre><code>nebula&gt; INSERT VERTEX player(name) VALUES \"Kobe\":(\"Kobe\");\n</code></pre> <p>Query the vertex <code>Kobe</code>. The property <code>age</code> is <code>18</code> by default.</p> <pre><code>nebula&gt; FETCH PROP ON player \"Kobe\" YIELD properties(vertex);\n+--------------------------+\n| properties(VERTEX)       |\n+--------------------------+\n| {age: 18, name: \"Kobe\"}  |\n+--------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/6.list/","title":"Lists","text":"<p>The list is a composite data type. A list is a sequence of values. Individual elements in a list can be accessed by their positions.</p> <p>A list starts with a left square bracket <code>[</code> and ends with a right square bracket <code>]</code>. A list contains zero, one, or more expressions. List elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the list, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#list_operations","title":"List operations","text":"<p>You can use the preset list function to operate the list, or use the index to filter the elements in the list.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#index_syntax","title":"Index syntax","text":"<pre><code>[M]\n[M..N]\n[M..]\n[..N]\n</code></pre> <p>The index of nGQL supports queries from front to back, starting from 0. 0 means the first element, 1 means the second element, and so on. It also supports queries from back to front, starting from -1. -1 means the last element, -2 means the penultimate element, and so on.</p> <ul> <li>[M]: represents the element whose index is M.</li> <li>[M..N]: represents the elements whose indexes are <code>greater or equal to M but smaller than N</code>. Return empty when <code>N</code> is 0.</li> <li>[M..]: represents the elements whose indexes are <code>greater or equal to M</code>.</li> <li>[..N]: represents the elements whose indexes are <code>smaller than N</code>. Return empty when <code>N</code> is 0.</li> </ul> <p>Note</p> <ul> <li>Return empty if the index is out of bounds, while return normally if the index is within the bound.</li> <li>Return empty if <code>M</code>\u2265<code>N</code>.</li> <li>When querying a single element, if <code>M</code> is null, return <code>BAD_TYPE</code>. When conducting a range query, if <code>M</code> or <code>N</code> is null, return <code>null</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/6.list/#examples","title":"Examples","text":"<pre><code># The following query returns the list [1,2,3].\nnebula&gt; RETURN list[1, 2, 3] AS a;\n+-----------+\n| a         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns the element whose index is 3 in the list [1,2,3,4,5]. In a list, the index starts from 0, and thus the return element is 4.\nnebula&gt; RETURN range(1,5)[3];\n+---------------+\n| range(1,5)[3] |\n+---------------+\n| 4             |\n+---------------+\n\n# The following query returns the element whose index is -2 in the list [1,2,3,4,5]. The index of the last element in a list is -1, and thus the return element is 4.\nnebula&gt; RETURN range(1,5)[-2];\n+------------------+\n| range(1,5)[-(2)] |\n+------------------+\n| 4                |\n+------------------+\n\n# The following query returns the elements whose indexes are from 0 to 3 (not including 3) in the list [1,2,3,4,5].\nnebula&gt; RETURN range(1,5)[0..3];\n+------------------+\n| range(1,5)[0..3] |\n+------------------+\n| [1, 2, 3]        |\n+------------------+\n\n# The following query returns the elements whose indexes are greater than 2 in the list [1,2,3,4,5].\nnebula&gt; RETURN range(1,5)[3..] AS a;\n+--------+\n| a      |\n+--------+\n| [4, 5] |\n+--------+\n\n# The following query returns the elements whose indexes are smaller than 3.\nnebula&gt; WITH list[1, 2, 3, 4, 5] AS a \\\n        RETURN a[..3] AS r;\n+-----------+\n| r         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query filters the elements whose indexes are greater than 2 in the list [1,2,3,4,5], calculate them respectively, and returns them.\nnebula&gt; RETURN [n IN range(1,5) WHERE n &gt; 2 | n + 10] AS a;\n+--------------+\n| a            |\n+--------------+\n| [13, 14, 15] |\n+--------------+\n\n# The following query returns the elements from the first to the penultimate (inclusive) in the list [1, 2, 3].\nnebula&gt; YIELD list[1, 2, 3][0..-1] AS a;\n+--------+\n| a      |\n+--------+\n| [1, 2] |\n+--------+\n\n# The following query returns the elements from the first (exclusive) to the third backward in the list [1, 2, 3, 4, 5].\nnebula&gt; YIELD list[1, 2, 3, 4, 5][-3..-1] AS a;\n+--------+\n| a      |\n+--------+\n| [3, 4] |\n+--------+\n\n# The following query sets the variables and returns the elements whose indexes are 1 and 2.\nnebula&gt; $var = YIELD 1 AS f, 3 AS t; \\\n        YIELD list[1, 2, 3][$var.f..$var.t] AS a;\n+--------+\n| a      |\n+--------+\n| [2, 3] |\n+--------+\n\n# The following query returns empty because the index is out of bound. It will return normally when the index is within the bound.\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [0..10] AS a;\n+-----------------+\n| a               |\n+-----------------+\n| [1, 2, 3, 4, 5] |\n+-----------------+\n\nnebula&gt; RETURN list[1, 2, 3] [-5..5] AS a;\n+-----------+\n| a         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns empty because there is a [0..0].\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [0..0] AS a;\n+----+\n| a  |\n+----+\n| [] |\n+----+\n\n# The following query returns empty because of M \u2265 N.\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [3..1] AS a;\n+----+\n| a  |\n+----+\n| [] |\n+----+\n\n# When conduct a range query, if `M` or `N` is null, return `null`.\nnebula&gt; WITH list[1,2,3] AS a \\\n        RETURN a[0..null] as r;\n+----------+\n| r        |\n+----------+\n| __NULL__ |\n+----------+\n\n# The following query calculates the elements in the list [1,2,3,4,5] respectively and returns them without the list head.\nnebula&gt; RETURN tail([n IN range(1, 5) | 2 * n - 10]) AS a;\n+-----------------+\n| a               |\n+-----------------+\n| [-6, -4, -2, 0] |\n+-----------------+\n\n# The following query takes the elements in the list [1,2,3] as true and return.\nnebula&gt; RETURN [n IN range(1, 3) WHERE true | n] AS r;\n+-----------+\n| r         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns the length of the list [1,2,3].\nnebula&gt; RETURN size(list[1,2,3]);\n+-------------------+\n| size(list[1,2,3]) |\n+-------------------+\n| 3                 |\n+-------------------+\n\n# The following query calculates the elements in the list [92,90] and runs a conditional judgment in a where clause.\nnebula&gt; GO FROM \"player100\" OVER follow WHERE properties(edge).degree NOT IN [x IN [92, 90] | x + $$.player.age] \\\n        YIELD dst(edge) AS id, properties(edge).degree AS degree;\n+-------------+--------+\n| id          | degree |\n+-------------+--------+\n| \"player101\" | 95     |\n| \"player102\" | 90     |\n+-------------+--------+\n\n# The following query takes the query result of the MATCH statement as the elements in a list. Then it calculates and returns them.\nnebula&gt; MATCH p = (n:player{name:\"Tim Duncan\"})-[:follow]-&gt;(m) \\\n        RETURN [n IN nodes(p) | n.player.age + 100] AS r;\n+------------+\n| r          |\n+------------+\n| [142, 136] |\n| [142, 141] |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/6.list/#opencypher_compatibility_1","title":"OpenCypher compatibility","text":"<ul> <li>In openCypher, return <code>null</code> when querying a single out-of-bound element. However, in nGQL, return <code>OUT_OF_RANGE</code> when querying a single out-of-bound element.<pre><code>nebula&gt; RETURN range(0,5)[-12];\n+-------------------+\n| range(0,5)[-(12)] |\n+-------------------+\n| OUT_OF_RANGE      |\n+-------------------+\n</code></pre> </li> </ul> <ul> <li> <p>A composite data type (i.e., set, map, and list) CAN NOT be stored as properties for vertices or edges.</p> <p>It is recommended to modify the graph modeling method. The composite data type should be modeled as an adjacent edge of a vertex, rather than its property. Each adjacent edge can be dynamically added or deleted. The rank values of the adjacent edges can be used for sequencing.</p> </li> </ul> <ul> <li>Patterns are not supported in the list. For example, <code>[(src)-[]-&gt;(m) | m.name]</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/7.set/","title":"Sets","text":"<p>The set is a composite data type. A set is a set of values. Unlike a List, values in a set are unordered and each value must be unique.</p> <p>A set starts with a left curly bracket <code>{</code> and ends with a right curly bracket <code>}</code>. A set contains zero, one, or more expressions. Set elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the set, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/7.set/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</li> </ul> <ul> <li>A set is not a data type in openCypher, but in nGQL, users can use the set.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/7.set/#examples","title":"Examples","text":"<pre><code># The following query returns the set {1,2,3}.\nnebula&gt; RETURN set{1, 2, 3} AS a;\n+-----------+\n| a         |\n+-----------+\n| {3, 2, 1} |\n+-----------+\n\n# The following query returns the set {1,2}, Because the set does not allow repeating elements, and the order is unordered.\nnebula&gt; RETURN set{1, 2, 1} AS a;\n+--------+\n| a      |\n+--------+\n| {2, 1} |\n+--------+\n\n# The following query checks whether the set has the specified element 1.\nnebula&gt; RETURN 1 IN set{1, 2} AS a;\n+------+\n| a    |\n+------+\n| true |\n+------+\n\n# The following query counts the number of elements in the set.\nnebula&gt; YIELD size(set{1, 2, 1}) AS a;\n+---+\n| a |\n+---+\n| 2 |\n+---+\n\n# The following query returns a set of target vertex property values.\nnebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD set{properties($$).name,properties($$).age} as a;\n+-----------------------+\n| a                     |\n+-----------------------+\n| {36, \"Tony Parker\"}   |\n| {41, \"Manu Ginobili\"} |\n+-----------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/8.map/","title":"Maps","text":"<p>The map is a composite data type. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using <code>map['key']</code>.</p> <p>A map starts with a left curly bracket <code>{</code> and ends with a right curly bracket <code>}</code>. A map contains zero, one, or more key-value pairs. Map elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the map, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/8.map/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</li> </ul> <ul> <li>Map projection is not supported.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/8.map/#examples","title":"Examples","text":"<pre><code># The following query returns the simple map.\nnebula&gt; YIELD map{key1: 'Value1', Key2: 'Value2'} as a;\n+----------------------------------+\n| a                                |\n+----------------------------------+\n| {Key2: \"Value2\", key1: \"Value1\"} |\n+----------------------------------+\n\n# The following query returns the list type map.\nnebula&gt; YIELD map{listKey: [{inner: 'Map1'}, {inner: 'Map2'}]} as a;\n+-----------------------------------------------+\n| a                                             |\n+-----------------------------------------------+\n| {listKey: [{inner: \"Map1\"}, {inner: \"Map2\"}]} |\n+-----------------------------------------------+\n\n# The following query returns the hybrid type map.\nnebula&gt; RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"} as a;\n+----------------------------------+\n| a                                |\n+----------------------------------+\n| {a: [1, 2], b: {2, 1}, c: \"hee\"} |\n+----------------------------------+\n\n# The following query returns the specified element in a map.\nnebula&gt; RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"}[\"b\"] AS b;\n+--------+\n| b      |\n+--------+\n| {2, 1} |\n+--------+\n\n# The following query checks whether the map has the specified key, not support checks whether the map has the specified value yet.\nnebula&gt; RETURN \"a\" IN MAP{a:1, b:2} AS a;\n+------+\n| a    |\n+------+\n| true |\n+------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/","title":"Type Conversion/Type coercions","text":"<p>Converting an expression of a given type to another type is known as type conversion.</p> <p>NebulaGraph supports converting expressions explicit to other types. For details, see Type conversion functions.</p>"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/#examples","title":"Examples","text":"<pre><code>nebula&gt; UNWIND [true, false, 'true', 'false', NULL] AS b \\\n        RETURN toBoolean(b) AS b;\n+----------+\n| b        |\n+----------+\n| true     |\n| false    |\n| true     |\n| false    |\n| __NULL__ |\n+----------+\n\nnebula&gt; RETURN toFloat(1), toFloat('1.3'), toFloat('1e3'), toFloat('not a number');\n+------------+----------------+----------------+-------------------------+\n| toFloat(1) | toFloat(\"1.3\") | toFloat(\"1e3\") | toFloat(\"not a number\") |\n+------------+----------------+----------------+-------------------------+\n| 1.0        | 1.3            | 1000.0         | __NULL__                |\n+------------+----------------+----------------+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/","title":"Composite queries (clause structure)","text":"<p>Composite queries put data from different queries together. They then use filters, group-bys, or sorting before returning the combined return results.</p> <p>Nebula\u00a0Graph supports three methods to run composite queries (or sub-queries):</p> <ul> <li>(openCypher) Clauses are chained together, and they feed intermediate result sets between each other.</li> </ul> <ul> <li>(Native nGQL) More than one query can be batched together, separated by semicolons (;). The result of the last query is returned as the result of the batch.</li> </ul> <ul> <li>(Native nGQL) Queries can be piped together by using the pipe (<code>|</code>). The result of the previous query can be used as the input of the next query.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>In a composite query, do not put together openCypher and native nGQL clauses in one statement. For example, this statement is undefined: <code>MATCH ... | GO ... | YIELD ...</code>.</p> <ul> <li>If you are in the openCypher way (<code>MATCH</code>, <code>RETURN</code>, <code>WITH</code>, etc), do not introduce any pipe or semicolons to combine the sub-clauses.</li> </ul> <ul> <li>If you are in the native nGQL way (<code>FETCH</code>, <code>GO</code>, <code>LOOKUP</code>, etc), you must use pipe or semicolons to combine the sub-clauses.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/#composite_queries_are_not_transactional_queries_as_in_sqlcypher","title":"Composite queries are not <code>transactional</code> queries (as in SQL/Cypher)","text":"<p>For example, a query is composed of three sub-queries: <code>A B C</code>, <code>A | B | C</code> or <code>A; B; C</code>. In that A is a read operation, B is a computation operation, and C is a write operation. If any part fails in the execution, the whole result will be undefined. There is no rollback. What is written depends on the query executor.</p> <p>Note</p> <p>OpenCypher has no requirement of <code>transaction</code>.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/#examples","title":"Examples","text":"<ul> <li>OpenCypher compatibility statement<pre><code># Connect multiple queries with clauses.\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--() \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS n1 \\\n        RETURN DISTINCT n1;\n</code></pre> </li> </ul> <ul> <li>Native nGQL (Semicolon queries)<pre><code># Only return edges.\nnebula&gt; SHOW TAGS; SHOW EDGES;\n\n# Insert multiple vertices.\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42); \\\n        INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36); \\\n        INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\n</code></pre> </li> </ul> <ul> <li>Native nGQL (Pipe queries)<pre><code># Connect multiple queries with pipes.\nnebula&gt; GO FROM \"player100\" OVER follow YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------+-----------------+\n| Team      | Player          |\n+-----------+-----------------+\n| \"Spurs\"   | \"Tony Parker\"   |\n| \"Hornets\" | \"Tony Parker\"   |\n| \"Spurs\"   | \"Manu Ginobili\" |\n+-----------+-----------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/","title":"User-defined variables","text":"<p>User-defined variables allow passing the result of one statement to another.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>In openCypher, when you refer to the vertex, edge, or path of a variable, you need to name it first. For example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{name: \"Tim Duncan\", age: 42}) |\n+----------------------------------------------------+\n</code></pre> <p>The user-defined variable in the preceding query is <code>v</code>.</p> <p>Caution</p> <p>In a pattern of a MATCH statement, you cannot use the same edge variable repeatedly. For example, <code>e</code> cannot be written in the pattern <code>p=(v1)-[e*2..2]-&gt;(v2)-[e*2..2]-&gt;(v3)</code>.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#native_ngql","title":"Native nGQL","text":"<p>User-defined variables are written as <code>$var_name</code>. The <code>var_name</code> consists of letters, numbers, or underline characters. Any other characters are not permitted.</p> <p>The user-defined variables are valid only at the current execution (namely, in this composite query). When the execution ends, the user-defined variables will be automatically expired. The user-defined variables in one statement CANNOT be used in any other clients, executions, or sessions.</p> <p>You can use user-defined variables in composite queries. Details about composite queries, see Composite queries.</p> <p>Note</p> <ul> <li>User-defined variables are case-sensitive.</li> <li>To define a user-defined variable in a compound statement, end the statement with a semicolon (;). For details, please refer to the nGQL Style Guide.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#example","title":"Example","text":"<pre><code>nebula&gt; $var = GO FROM \"player100\" OVER follow YIELD dst(edge) AS id; \\\n        GO FROM $var.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------+-----------------+\n| Team      | Player          |\n+-----------+-----------------+\n| \"Spurs\"   | \"Tony Parker\"   |\n| \"Hornets\" | \"Tony Parker\"   |\n| \"Spurs\"   | \"Manu Ginobili\" |\n+-----------+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#set_operations_and_scope_of_user-defined_variables","title":"Set operations and scope of user-defined variables","text":"<p>When assigning variables within a compound statement involving set operations, it is important to enclose the scope of the variable assignment in parentheses. In the example below, the source of the <code>$var</code> assignment is the results of the output of two <code>INTERSECT</code> statements. </p> <pre><code>$var = ( \\\n    GO FROM \"player100\" OVER follow \\\n      YIELD dst(edge) AS id \\\n    INTERSECT \\\n    GO FROM \"player100\" OVER follow \\\n      YIELD dst(edge) AS id \\\n       ); \\\n    GO FROM $var.id OVER follow YIELD follow.degree AS degree\n</code></pre>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/","title":"Property reference","text":"<p>You can refer to the properties of a vertex or an edge in <code>WHERE</code> and <code>YIELD</code> syntax.</p> <p>Note</p> <p>This function applies to native nGQL only.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#property_reference_for_vertex","title":"Property reference for vertex","text":""},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#for_source_vertex","title":"For source vertex","text":"<pre><code>$^.&lt;tag_name&gt;.&lt;prop_name&gt;\n</code></pre> Parameter Description <code>$^</code> is used to get the property of the source vertex. <code>tag_name</code> is the tag name of the vertex. <code>prop_name</code> specifies the property name."},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#for_destination_vertex","title":"For destination vertex","text":"<pre><code>$$.&lt;tag_name&gt;.&lt;prop_name&gt;\n</code></pre> Parameter Description <code>$$</code> is used to get the property of the destination vertex. <code>tag_name</code> is the tag name of the vertex. <code>prop_name</code> specifies the property name."},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#property_reference_for_edge","title":"Property reference for edge","text":""},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#for_user-defined_edge_property","title":"For user-defined edge property","text":"<pre><code>&lt;edge_type&gt;.&lt;prop_name&gt;\n</code></pre> Parameter Description <code>edge_type</code> is the edge type of the edge. <code>prop_name</code> specifies the property name of the edge type."},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#for_built-in_properties","title":"For built-in properties","text":"<p>Apart from the user-defined edge property, there are four built-in properties in each edge:</p> Parameter Description <code>_src</code> source vertex ID of the edge <code>_dst</code> destination vertex ID of the edge <code>_type</code> edge type <code>_rank</code> the rank value for the edge"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#examples","title":"Examples","text":"<p>The following query returns the <code>name</code> property of the <code>player</code> tag on the source vertex and the <code>age</code> property of the <code>player</code> tag on the destination vertex.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD $^.player.name AS startName, $$.player.age AS endAge;\n+--------------+--------+\n| startName    | endAge |\n+--------------+--------+\n| \"Tim Duncan\" | 36     |\n| \"Tim Duncan\" | 41     |\n+--------------+--------+\n</code></pre> <p>The following query returns the <code>degree</code> property of the edge type <code>follow</code>.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD follow.degree;\n+---------------+\n| follow.degree |\n+---------------+\n| 95            |\n+---------------+\n</code></pre> <p>The following query returns the source vertex, the destination vertex, the edge type, and the edge rank value of the edge type <code>follow</code>.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD follow._src, follow._dst, follow._type, follow._rank;\n+-------------+-------------+--------------+--------------+\n| follow._src | follow._dst | follow._type | follow._rank |\n+-------------+-------------+--------------+--------------+\n| \"player100\" | \"player101\" | 17           | 0            |\n| \"player100\" | \"player125\" | 17           | 0            |\n+-------------+-------------+--------------+--------------+\n</code></pre> <p>Legacy version compatibility</p> <p>NebulaGraph 2.6.0 and later versions support the new Schema-related functions. Similar statements as the above examples are written as follows in 2.0.0.</p> <pre><code>GO FROM \"player100\" OVER follow YIELD properties($^).name AS startName, properties($$).age AS endAge;\nGO FROM \"player100\" OVER follow YIELD properties(edge).degree;\nGO FROM \"player100\" OVER follow YIELD src(edge), dst(edge), type(edge), rank(edge);\n</code></pre> <p>In 2.0.0, NebulaGraph is still compatible with the old syntax.</p>"},{"location":"3.ngql-guide/5.operators/1.comparison/","title":"Comparison operators","text":"<p>NebulaGraph supports the following comparison operators.</p> Name Description <code>==</code> Equal operator <code>!=</code>, <code>&lt;&gt;</code> Not equal operator <code>&gt;</code> Greater than operator <code>&gt;=</code> Greater than or equal operator <code>&lt;</code> Less than operator <code>&lt;=</code> Less than or equal operator <code>IS NULL</code> NULL check <code>IS NOT NULL</code> Not NULL check <code>IS EMPTY</code> EMPTY check <code>IS NOT EMPTY</code> Not EMPTY check <p>The result of the comparison operation is <code>true</code> or <code>false</code>.</p> <p>Note</p> <ul> <li>Comparability between values of different types is often undefined. The result could be <code>NULL</code> or others.</li> </ul> <ul> <li><code>EMPTY</code> is currently used only for checking, and does not support functions or operations such as <code>GROUP BY</code>, <code>count()</code>, <code>sum()</code>, <code>max()</code>, <code>hash()</code>, <code>collect()</code>, <code>+</code> or <code>*</code>.</li> </ul>"},{"location":"3.ngql-guide/5.operators/1.comparison/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>openCypher does not have <code>EMPTY</code>. Thus <code>EMPTY</code> is not supported in MATCH statements.</p>"},{"location":"3.ngql-guide/5.operators/1.comparison/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/5.operators/1.comparison/#_1","title":"<code>==</code>","text":"<p>String comparisons are case-sensitive. Values of different types are not equal.</p> <p>Note</p> <p>The equal operator is <code>==</code> in nGQL, while in openCypher it is <code>=</code>.</p> <pre><code>nebula&gt; RETURN 'A' == 'a', toUpper('A') == toUpper('a'), toLower('A') == toLower('a');\n+------------+------------------------------+------------------------------+\n| (\"A\"==\"a\") | (toUpper(\"A\")==toUpper(\"a\")) | (toLower(\"A\")==toLower(\"a\")) |\n+------------+------------------------------+------------------------------+\n| false      | true                         | true                         |\n+------------+------------------------------+------------------------------+\n\nnebula&gt; RETURN '2' == 2, toInteger('2') == 2;\n+----------+---------------------+\n| (\"2\"==2) | (toInteger(\"2\")==2) |\n+----------+---------------------+\n| false    | true                |\n+----------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_2","title":"<code>&gt;</code>","text":"<pre><code>nebula&gt; RETURN 3 &gt; 2;\n+-------+\n| (3&gt;2) |\n+-------+\n| true  |\n+-------+\n\nnebula&gt; WITH 4 AS one, 3 AS two \\\n        RETURN one &gt; two AS result;\n+--------+\n| result |\n+--------+\n| true   |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_3","title":"<code>&gt;=</code>","text":"<pre><code>nebula&gt; RETURN 2 &gt;= \"2\", 2 &gt;= 2;\n+----------+--------+\n| (2&gt;=\"2\") | (2&gt;=2) |\n+----------+--------+\n| __NULL__ | true   |\n+----------+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_4","title":"<code>&lt;</code>","text":"<pre><code>nebula&gt; YIELD 2.0 &lt; 1.9;\n+---------+\n| (2&lt;1.9) |\n+---------+\n| false   |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_5","title":"<code>&lt;=</code>","text":"<pre><code>nebula&gt; YIELD 0.11 &lt;= 0.11;\n+--------------+\n| (0.11&lt;=0.11) |\n+--------------+\n| true         |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_6","title":"<code>!=</code>","text":"<pre><code>nebula&gt; YIELD 1 != '1';\n+----------+\n| (1!=\"1\") |\n+----------+\n| true     |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#is_not_null","title":"<code>IS [NOT] NULL</code>","text":"<pre><code>nebula&gt; RETURN null IS NULL AS value1, null == null AS value2, null != null AS value3;\n+--------+----------+----------+\n| value1 | value2   | value3   |\n+--------+----------+----------+\n| true   | __NULL__ | __NULL__ |\n+--------+----------+----------+\n\nnebula&gt; RETURN length(NULL), size(NULL), count(NULL), NULL IS NULL, NULL IS NOT NULL, sin(NULL), NULL + NULL, [1, NULL] IS NULL;\n+--------------+------------+-------------+--------------+------------------+-----------+-------------+------------------+\n| length(NULL) | size(NULL) | count(NULL) | NULL IS NULL | NULL IS NOT NULL | sin(NULL) | (NULL+NULL) | [1,NULL] IS NULL |\n+--------------+------------+-------------+--------------+------------------+-----------+-------------+------------------+\n| __NULL__     | __NULL__   | 0           | true         | false            | __NULL__  | __NULL__    | false            |\n+--------------+------------+-------------+--------------+------------------+-----------+-------------+------------------+\n\nnebula&gt; WITH {name: null} AS `map` \\\n        RETURN `map`.name IS NOT NULL;\n+----------------------+\n| map.name IS NOT NULL |\n+----------------------+\n| false                |\n+----------------------+\n\nnebula&gt; WITH {name: 'Mats', name2: 'Pontus'} AS map1, \\\n        {name: null} AS map2, {notName: 0, notName2: null } AS map3 \\\n        RETURN map1.name IS NULL, map2.name IS NOT NULL, map3.name IS NULL;\n+-------------------+-----------------------+-------------------+\n| map1.name IS NULL | map2.name IS NOT NULL | map3.name IS NULL |\n+-------------------+-----------------------+-------------------+\n| false             | false                 | true              |\n+-------------------+-----------------------+-------------------+\n\nnebula&gt; MATCH (n:player) \\\n        RETURN n.player.age IS NULL, n.player.name IS NOT NULL, n.player.empty IS NULL;\n+----------------------+---------------------------+------------------------+\n| n.player.age IS NULL | n.player.name IS NOT NULL | n.player.empty IS NULL |\n+----------------------+---------------------------+------------------------+\n| false                | true                      | true                   |\n| false                | true                      | true                   |\n...\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#is_not_empty","title":"<code>IS [NOT] EMPTY</code>","text":"<pre><code>nebula&gt; RETURN null IS EMPTY;\n+---------------+\n| NULL IS EMPTY |\n+---------------+\n| false         |\n+---------------+\n\nnebula&gt; RETURN \"a\" IS NOT EMPTY;\n+------------------+\n| \"a\" IS NOT EMPTY |\n+------------------+\n| true             |\n+------------------+\n\nnebula&gt; GO FROM \"player100\" OVER * WHERE properties($$).name IS NOT EMPTY YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"team204\"   |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/10.arithmetic/","title":"Arithmetic operators","text":"<p>NebulaGraph supports the following arithmetic operators.</p> Name Description <code>+</code> Addition operator <code>-</code> Minus operator <code>*</code> Multiplication operator <code>/</code> Division operator <code>%</code> Modulo operator <code>-</code> Changes the sign of the argument"},{"location":"3.ngql-guide/5.operators/10.arithmetic/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN 1+2 AS result;\n+--------+\n| result |\n+--------+\n| 3      |\n+--------+\n\nnebula&gt; RETURN -10+5 AS result;\n+--------+\n| result |\n+--------+\n| -5     |\n+--------+\n\nnebula&gt; RETURN (3*8)%5 AS result;\n+--------+\n| result |\n+--------+\n| 4      |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/2.boolean/","title":"Boolean operators","text":"<p>NebulaGraph supports the following boolean operators.</p> Name Description AND Logical AND NOT Logical NOT OR Logical OR XOR Logical XOR <p>For the precedence of the operators, refer to Operator Precedence.</p> <p>For the logical operations with <code>NULL</code>, refer to NULL.</p>"},{"location":"3.ngql-guide/5.operators/2.boolean/#legacy_version_compatibility","title":"Legacy version compatibility","text":"<ul> <li>Non-zero numbers cannot be converted to boolean values.</li> </ul>"},{"location":"3.ngql-guide/5.operators/4.pipe/","title":"Pipe operators","text":"<p>Multiple queries can be combined using pipe operators in nGQL.</p>"},{"location":"3.ngql-guide/5.operators/4.pipe/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Pipe operators apply to native nGQL only.</p>"},{"location":"3.ngql-guide/5.operators/4.pipe/#syntax","title":"Syntax","text":"<p>One major difference between nGQL and SQL is how sub-queries are composed.</p> <ul> <li>In SQL, sub-queries are nested in the query statements.</li> </ul> <ul> <li>In nGQL, the shell style <code>PIPE (|)</code> is introduced into the sub-queries.</li> </ul>"},{"location":"3.ngql-guide/5.operators/4.pipe/#examples","title":"Examples","text":"<pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS dstid, properties($$).name AS Name | \\\n        GO FROM $-.dstid OVER follow YIELD dst(edge);\n\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n| \"player100\" |\n+-------------+\n</code></pre> <p>Users must define aliases in the <code>YIELD</code> clause for the reference operator <code>$-</code> to use, just like <code>$-.dstid</code> in the preceding example.</p>"},{"location":"3.ngql-guide/5.operators/4.pipe/#performance_tips","title":"Performance tips","text":"<p>In NebulaGraph, pipes will affect the performance. Take <code>A | B</code> as an example, the effects are as follows:</p> <ol> <li> <p>Pipe operators operate synchronously. That is, the data can enter the pipe clause as a whole after the execution of clause <code>A</code> before the pipe operator is completed.</p> </li> <li> <p>Pipe operators need to be serialized and deserialized, which is executed in a single thread.</p> </li> <li> <p>If <code>A</code> sends a large amount of data to <code>|</code>, the entire query request may be very slow. You can try to split this statement.</p> <ol> <li> <p>Send <code>A</code> from the application,</p> </li> <li> <p>Split the return results on the application,</p> </li> <li> <p>Send to multiple graphd processes concurrently,</p> </li> <li> <p>Every graphd process executes part of B.</p> </li> </ol> <p>This is usually much faster than executing a complete <code>A | B</code> with a single graphd process.</p> </li> </ol>"},{"location":"3.ngql-guide/5.operators/5.property-reference/","title":"Reference operators","text":"<p>NGQL provides reference operators to represent a property in a <code>WHERE</code> or <code>YIELD</code> clause, or the output of the statement before the pipe operator in a composite query.</p>"},{"location":"3.ngql-guide/5.operators/5.property-reference/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Reference operators apply to native nGQL only.</p>"},{"location":"3.ngql-guide/5.operators/5.property-reference/#reference_operator_list","title":"Reference operator List","text":"Reference operator Description <code>$^</code> Refers to a source vertex property. For more information, see Property reference. <code>$$</code> Refers to a destination vertex property. For more information, see Property reference. <code>$-</code> Refers to the output of the statement before the pipe operator in a composite query. For more information, see Pipe."},{"location":"3.ngql-guide/5.operators/5.property-reference/#examples","title":"Examples","text":"<pre><code># The following example returns the age of the source vertex and the destination vertex.\nnebula&gt; GO FROM \"player100\" OVER follow YIELD properties($^).age AS SrcAge, properties($$).age AS DestAge;\n+--------+---------+\n| SrcAge | DestAge |\n+--------+---------+\n| 42     | 36      |\n| 42     | 41      |\n+--------+---------+\n\n# The following example returns the name and team of the players that player100 follows.\nnebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve \\\n        YIELD $^.player.name AS Player, properties($$).name AS Team;\n+-----------------+-----------+\n| Player          | Team      |\n+-----------------+-----------+\n| \"Tony Parker\"   | \"Spurs\"   |\n| \"Tony Parker\"   | \"Hornets\" |\n| \"Manu Ginobili\" | \"Spurs\"   |\n+-----------------+-----------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/6.set/","title":"Set operators","text":"<p>This topic will describe the set operators, including <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. To combine multiple queries, use these set operators.</p> <p>All set operators have equal precedence. If a nGQL statement contains multiple set operators, NebulaGraph will evaluate them from left to right unless parentheses explicitly specify another order.</p> <p>Caution</p> <p>The names and order of the variables defined in the query statements before and after the set operator must be consistent. For example, the names and order of <code>a,b,c</code> in <code>RETURN a,b,c UNION RETURN a,b,c</code> need to be consistent.</p>"},{"location":"3.ngql-guide/5.operators/6.set/#union_union_distinct_and_union_all","title":"UNION, UNION DISTINCT, and UNION ALL","text":"<pre><code>&lt;left&gt; UNION [DISTINCT | ALL] &lt;right&gt; [ UNION [DISTINCT | ALL] &lt;right&gt; ...]\n</code></pre> <ul> <li>Operator <code>UNION DISTINCT</code> (or by short <code>UNION</code>) returns the union of two sets A and B without duplicated elements.</li> </ul> <ul> <li>Operator <code>UNION ALL</code> returns the union of two sets A and B with duplicated elements.</li> </ul> <ul> <li>The <code>&lt;left&gt;</code> and <code>&lt;right&gt;</code> must have the same number of columns and data types. Different data types are converted according to the Type Conversion.</li> </ul>"},{"location":"3.ngql-guide/5.operators/6.set/#examples","title":"Examples","text":"<pre><code># The following statement returns the union of two query results without duplicated elements.\nnebula&gt; GO FROM \"player102\" OVER follow YIELD dst(edge) \\\n        UNION \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n\nnebula&gt; MATCH (v:player) \\\n        WITH v.player.name AS v \\\n        RETURN n ORDER BY n LIMIT 3 \\\n        UNION \\\n        UNWIND [\"Tony Parker\", \"Ben Simmons\"] AS n \\\n        RETURN n;\n+---------------------+\n| n                   |\n+---------------------+\n| \"Amar'e Stoudemire\" |\n| \"Aron Baynes\"       |\n| \"Ben Simmons\"       |\n| \"Tony Parker\"       |\n+---------------------+\n\n# The following statement returns the union of two query results with duplicated elements.\nnebula&gt; GO FROM \"player102\" OVER follow YIELD dst(edge) \\\n        UNION ALL \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n\nnebula&gt; MATCH (v:player) \\\n        WITH v.player.name AS n \\\n        RETURN n ORDER BY n LIMIT 3 \\\n        UNION ALL \\\n        UNWIND [\"Tony Parker\", \"Ben Simmons\"] AS n \\\n        RETURN n;\n+---------------------+\n| n                   |\n+---------------------+\n| \"Amar'e Stoudemire\" |\n| \"Aron Baynes\"       |\n| \"Ben Simmons\"       |\n| \"Tony Parker\"       |\n| \"Ben Simmons\"       |\n+---------------------+\n\n# UNION can also work with the YIELD statement. The DISTINCT keyword will check duplication by all the columns for every line, and remove duplicated lines if every column is the same.\nnebula&gt; GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age \\\n        UNION /* DISTINCT */ \\\n        GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age;\n+-------------+--------+-----+\n| id          | Degree | Age |\n+-------------+--------+-----+\n| \"player100\" | 75     | 42  |\n| \"player101\" | 75     | 36  |\n| \"player101\" | 95     | 36  |\n| \"player125\" | 95     | 41  |\n+-------------+--------+-----+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/6.set/#intersect","title":"INTERSECT","text":"<pre><code>&lt;left&gt; INTERSECT &lt;right&gt;\n</code></pre> <ul> <li>Operator <code>INTERSECT</code> returns the intersection of two sets A and B (denoted by A \u22c2 B).</li> </ul> <ul> <li>Similar to <code>UNION</code>, the <code>left</code> and <code>right</code> must have the same number of columns and data types. Different data types are converted according to the Type Conversion.</li> </ul>"},{"location":"3.ngql-guide/5.operators/6.set/#example","title":"Example","text":"<pre><code># The following statement returns the intersection of two query results.\nnebula&gt; GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age \\\n        INTERSECT \\\n        GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age;\n+----+--------+-----+\n| id | Degree | Age |\n+----+--------+-----+\n+----+--------+-----+\n\nnebula&gt; MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) == \"player102\" \\\n        RETURN id(v2) As id, e.degree As Degree, v2.player.age AS Age \\\n        INTERSECT \\\n        MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) == \"player100\" \\\n        RETURN id(v2) As id, e.degree As Degree, v2.player.age AS Age;\n+----+--------+-----+\n| id | Degree | Age |\n+----+--------+-----+\n+----+--------+-----+\n\nnebula&gt; UNWIND [1,2] AS a RETURN a \\\n        INTERSECT \\\n        UNWIND [1,2,3,4] AS a \\\n        RETURN a;\n+---+\n| a |\n+---+\n| 1 |\n| 2 |\n+---+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/6.set/#minus","title":"MINUS","text":"<pre><code>&lt;left&gt; MINUS &lt;right&gt;\n</code></pre> <p>Operator <code>MINUS</code> returns the subtraction (or difference) of two sets A and B (denoted by <code>A-B</code>). Always pay attention to the order of <code>left</code> and <code>right</code>. The set <code>A-B</code> consists of elements that are in A but not in B.</p>"},{"location":"3.ngql-guide/5.operators/6.set/#example_1","title":"Example","text":"<pre><code># The following statement returns the elements in the first query result but not in the second query result.\nnebula&gt; GO FROM \"player100\" OVER follow YIELD dst(edge) \\\n        MINUS \\\n        GO FROM \"player102\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player125\" |\n+-------------+\n\nnebula&gt; GO FROM \"player102\" OVER follow YIELD dst(edge) AS id\\\n        MINUS \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge) AS id;\n+-------------+\n| id          |\n+-------------+\n| \"player100\" |\n+-------------+\n\nnebula&gt; MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) ==\"player102\" \\\n        RETURN id(v2) AS id\\\n        MINUS \\\n        MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) ==\"player100\" \\\n        RETURN id(v2) AS id;\n+-------------+\n| id          |\n+-------------+\n| \"player100\" |\n+-------------+\n\nnebula&gt; UNWIND [1,2,3] AS a RETURN a \\\n        MINUS \\\n        WITH 4 AS a \\\n        RETURN a;\n+---+\n| a |\n+---+\n| 1 |\n| 2 |\n| 3 |\n+---+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/6.set/#precedence_of_the_set_operators_and_pipe_operators","title":"Precedence of the set operators and pipe operators","text":"<p>Please note that when a query contains a pipe <code>|</code> and a set operator, the pipe takes precedence. Refer to Pipe for details. The query <code>GO FROM 1 UNION GO FROM 2 | GO FROM 3</code> is the same as the query <code>GO FROM 1 UNION (GO FROM 2 | GO FROM 3)</code>.</p>"},{"location":"3.ngql-guide/5.operators/6.set/#examples_1","title":"Examples","text":"<pre><code>nebula&gt; GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS play_dst  \\\n        UNION \\\n        GO FROM \"team200\" OVER serve REVERSELY \\\n        YIELD src(edge) AS play_src \\\n        | GO FROM $-.play_src OVER follow YIELD dst(edge) AS play_dst;\n\n+-------------+\n| play_dst    |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player117\" |\n| \"player105\" |\n+-------------+\n</code></pre> <p>The above query executes the statements in the red bar first and then executes the statement in the green box.</p> <p>The parentheses can change the execution priority. For example:</p> <pre><code>nebula&gt; (GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS play_dst  \\\n        UNION \\\n        GO FROM \"team200\" OVER serve REVERSELY \\\n        YIELD src(edge) AS play_dst) \\\n        | GO FROM $-.play_dst OVER follow YIELD dst(edge) AS play_dst;\n</code></pre> <p>In the above query, the statements within the parentheses take precedence. That is, the <code>UNION</code> operation will be executed first, and its output will be executed as the input of the next operation with pipes.</p>"},{"location":"3.ngql-guide/5.operators/7.string/","title":"String operators","text":"<p>You can use the following string operators for concatenating, querying, and matching.</p> Name Description + Concatenates strings. CONTAINS Performs searchings in strings. (NOT) IN Checks whether a value is within a set of values. (NOT) STARTS WITH Performs matchings at the beginning of a string. (NOT) ENDS WITH Performs matchings at the end of a string. Regular expressions Perform string matchings using regular expressions. <p>Note</p> <p>All the string searchings or matchings are case-sensitive.</p>"},{"location":"3.ngql-guide/5.operators/7.string/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/5.operators/7.string/#_1","title":"<code>+</code>","text":"<pre><code>nebula&gt; RETURN 'a' + 'b';\n+-----------+\n| (\"a\"+\"b\") |\n+-----------+\n| \"ab\"      |\n+-----------+\nnebula&gt; UNWIND 'a' AS a UNWIND 'b' AS b RETURN a + b;\n+-------+\n| (a+b) |\n+-------+\n| \"ab\"  |\n+-------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#contains","title":"<code>CONTAINS</code>","text":"<p>The <code>CONTAINS</code> operator requires string types on both left and right sides.</p> <pre><code>nebula&gt; MATCH (s:player)-[e:serve]-&gt;(t:team) WHERE id(s) == \"player101\" \\\n        AND t.team.name CONTAINS \"ets\" RETURN s.player.name, e.start_year, e.end_year, t.team.name;\n+---------------+--------------+------------+-------------+\n| s.player.name | e.start_year | e.end_year | t.team.name |\n+---------------+--------------+------------+-------------+\n| \"Tony Parker\" | 2018         | 2019       | \"Hornets\"   |\n+---------------+--------------+------------+-------------+\n\nnebula&gt; GO FROM \"player101\" OVER serve WHERE (STRING)properties(edge).start_year CONTAINS \"19\" AND \\\n        properties($^).name CONTAINS \"ny\" \\\n        YIELD properties($^).name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+---------------------+-----------------------------+---------------------------+---------------------+\n| properties($^).name | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+---------------------+-----------------------------+---------------------------+---------------------+\n| \"Tony Parker\"       | 1999                        | 2018                      | \"Spurs\"             |\n+---------------------+-----------------------------+---------------------------+---------------------+\n\nnebula&gt; GO FROM \"player101\" OVER serve WHERE !(properties($$).name CONTAINS \"ets\") \\\n        YIELD properties($^).name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+---------------------+-----------------------------+---------------------------+---------------------+\n| properties($^).name | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+---------------------+-----------------------------+---------------------------+---------------------+\n| \"Tony Parker\"       | 1999                        | 2018                      | \"Spurs\"             |\n+---------------------+-----------------------------+---------------------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#not_in","title":"<code>(NOT) IN</code>","text":"<pre><code>nebula&gt; RETURN  1 IN [1,2,3], \"Yao\" NOT IN [\"Yi\", \"Tim\", \"Kobe\"], NULL IN [\"Yi\", \"Tim\", \"Kobe\"];\n+----------------+------------------------------------+-------------------------------+\n| (1 IN [1,2,3]) | (\"Yao\" NOT IN [\"Yi\",\"Tim\",\"Kobe\"]) | (NULL IN [\"Yi\",\"Tim\",\"Kobe\"]) |\n+----------------+------------------------------------+-------------------------------+\n| true           | true                               | __NULL__                      |\n+----------------+------------------------------------+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#not_starts_with","title":"<code>(NOT) STARTS WITH</code>","text":"<pre><code>nebula&gt; RETURN 'apple' STARTS WITH 'app', 'apple' STARTS WITH 'a', 'apple' STARTS WITH toUpper('a');\n+-----------------------------+---------------------------+------------------------------------+\n| (\"apple\" STARTS WITH \"app\") | (\"apple\" STARTS WITH \"a\") | (\"apple\" STARTS WITH toUpper(\"a\")) |\n+-----------------------------+---------------------------+------------------------------------+\n| true                        | true                      | false                              |\n+-----------------------------+---------------------------+------------------------------------+\n\nnebula&gt; RETURN 'apple' STARTS WITH 'b','apple' NOT STARTS WITH 'app';\n+---------------------------+---------------------------------+\n| (\"apple\" STARTS WITH \"b\") | (\"apple\" NOT STARTS WITH \"app\") |\n+---------------------------+---------------------------------+\n| false                     | false                           |\n+---------------------------+---------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#not_ends_with","title":"<code>(NOT) ENDS WITH</code>","text":"<pre><code>nebula&gt; RETURN 'apple' ENDS WITH 'app', 'apple' ENDS WITH 'e', 'apple' ENDS WITH 'E', 'apple' ENDS WITH 'b';\n+---------------------------+-------------------------+-------------------------+-------------------------+\n| (\"apple\" ENDS WITH \"app\") | (\"apple\" ENDS WITH \"e\") | (\"apple\" ENDS WITH \"E\") | (\"apple\" ENDS WITH \"b\") |\n+---------------------------+-------------------------+-------------------------+-------------------------+\n| false                     | true                    | false                   | false                   |\n+---------------------------+-------------------------+-------------------------+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#regular_expressions","title":"Regular expressions","text":"<p>Note</p> <p>Regular expressions cannot work with native nGQL statements (<code>GO</code>, <code>FETCH</code>, <code>LOOKUP</code>, etc.). Use it in openCypher only (<code>MATCH</code>, <code>WHERE</code>, etc.).</p> <p>NebulaGraph supports filtering by using regular expressions. The regular expression syntax is inherited from <code>std::regex</code>. You can match on regular expressions by using <code>=~ 'regexp'</code>. For example:</p> <pre><code>nebula&gt; RETURN \"384748.39\" =~ \"\\\\d+(\\\\.\\\\d{2})?\";\n+--------------------------------+\n| (\"384748.39\"=~\"\\d+(\\.\\d{2})?\") |\n+--------------------------------+\n| true                           |\n+--------------------------------+\n\nnebula&gt; MATCH (v:player) WHERE v.player.name =~ 'Tony.*' RETURN v.player.name;\n+---------------+\n| v.player.name |\n+---------------+\n| \"Tony Parker\" |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/8.list/","title":"List operators","text":"<p>NebulaGraph supports the following list operators:</p> List operator Description + Concatenates lists. IN Checks if an element exists in a list. [] Accesses an element(s) in a list using the index operator."},{"location":"3.ngql-guide/5.operators/8.list/#examples","title":"Examples","text":"<pre><code>nebula&gt; YIELD [1,2,3,4,5]+[6,7] AS myList;\n+-----------------------+\n| myList                |\n+-----------------------+\n| [1, 2, 3, 4, 5, 6, 7] |\n+-----------------------+\n\nnebula&gt; RETURN size([NULL, 1, 2]);\n+------------------+\n| size([NULL,1,2]) |\n+------------------+\n| 3                |\n+------------------+\n\nnebula&gt; RETURN NULL IN [NULL, 1];\n+--------------------+\n| (NULL IN [NULL,1]) |\n+--------------------+\n| __NULL__           |\n+--------------------+\n\nnebula&gt; WITH [2, 3, 4, 5] AS numberlist \\\n    UNWIND numberlist AS number \\\n    WITH number \\\n    WHERE number IN [2, 3, 8] \\\n    RETURN number;\n+--------+\n| number |\n+--------+\n| 2      |\n| 3      |\n+--------+\n\nnebula&gt; WITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names RETURN names[1] AS result;\n+--------+\n| result |\n+--------+\n| \"John\" |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/9.precedence/","title":"Operator precedence","text":"<p>The following list shows the precedence of nGQL operators in descending order. Operators that are shown together on a line have the same precedence.</p> <ul> <li><code>-</code> (negative number)</li> <li><code>!</code>, <code>NOT</code></li> <li><code>*</code>, <code>/</code>, <code>%</code></li> <li><code>-</code>, <code>+</code></li> <li><code>==</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&lt;&gt;</code>, <code>!=</code></li> <li><code>AND</code></li> <li><code>OR</code>, <code>XOR</code></li> <li><code>=</code> (assignment)</li> </ul> <p>For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left.</p> <p>The precedence of operators determines the order of evaluation of terms in an expression. To modify this order and group terms explicitly, use parentheses.</p>"},{"location":"3.ngql-guide/5.operators/9.precedence/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN 2+3*5;\n+-----------+\n| (2+(3*5)) |\n+-----------+\n| 17        |\n+-----------+\n\nnebula&gt; RETURN (2+3)*5;\n+-----------+\n| ((2+3)*5) |\n+-----------+\n| 25        |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/9.precedence/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>In openCypher, comparisons can be chained arbitrarily, e.g., <code>x &lt; y &lt;= z</code> is equivalent to <code>x &lt; y AND y &lt;= z</code> in openCypher.</p> <p>But in nGQL, <code>x &lt; y &lt;= z</code> is equivalent to <code>(x &lt; y) &lt;= z</code>. The result of <code>(x &lt; y)</code> is a boolean. Compare it with an integer <code>z</code>, and you will get the final result <code>NULL</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/","title":"Built-in math functions","text":"<p>This topic describes the built-in math functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#abs","title":"abs()","text":"<p>abs() returns the absolute value of the argument.</p> <p>Syntax: <code>abs(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN abs(-10);\n+------------+\n| abs(-(10)) |\n+------------+\n| 10         |\n+------------+\nnebula&gt; RETURN abs(5-6);\n+------------+\n| abs((5-6)) |\n+------------+\n| 1          |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#floor","title":"floor()","text":"<p>floor() returns the largest integer value smaller than or equal to the argument.(Rounds down)</p> <p>Syntax: <code>floor(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN floor(9.9);\n+------------+\n| floor(9.9) |\n+------------+\n| 9.0        |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#ceil","title":"ceil()","text":"<p>ceil() returns the smallest integer greater than or equal to the argument.(Rounds up)</p> <p>Syntax: <code>ceil(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN ceil(9.1);\n+-----------+\n| ceil(9.1) |\n+-----------+\n| 10.0      |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#round","title":"round()","text":"<p>round() returns the rounded value of the specified number. Pay attention to the floating-point precision when using this function.</p> <p>Syntax: <code>round(&lt;expression&gt;, &lt;digit&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li><code>digit</code>: Decimal digits. If <code>digit</code> is less than 0, round at the left of the decimal point.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN round(314.15926, 2);\n+--------------------+\n| round(314.15926,2) |\n+--------------------+\n| 314.16             |\n+--------------------+\nnebula&gt; RETURN round(314.15926, -1);\n+-----------------------+\n| round(314.15926,-(1)) |\n+-----------------------+\n| 310.0                 |\n+-----------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#sqrt","title":"sqrt()","text":"<p>sqrt() returns the square root of the argument.</p> <p>Syntax: <code>sqrt(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN sqrt(9);\n+---------+\n| sqrt(9) |\n+---------+\n| 3.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#cbrt","title":"cbrt()","text":"<p>cbrt() returns the cubic root of the argument.</p> <p>Syntax: <code>cbrt(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN cbrt(8);\n+---------+\n| cbrt(8) |\n+---------+\n| 2.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#hypot","title":"hypot()","text":"<p>hypot() returns the hypotenuse of a right-angled triangle.</p> <p>Syntax: <code>hypot(&lt;expression_x&gt;,&lt;expression_y&gt;)</code></p> <ul> <li><code>expression_x</code>, <code>expression_y</code>: An expression of which the result type is double. They represent the side lengths x and y of a right triangle.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN hypot(3,2*2);\n+----------------+\n| hypot(3,(2*2)) |\n+----------------+\n| 5.0            |\n+----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#pow","title":"pow()","text":"<p>pow() returns the result of x^y^.</p> <p>Syntax: <code>pow(&lt;expression_x&gt;,&lt;expression_y&gt;,)</code></p> <ul> <li><code>expression_x</code>: An expression of which the result type is double. It represents the base <code>x</code>.</li> </ul> <ul> <li><code>expression_y</code>: An expression of which the result type is double. It represents the exponential <code>y</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN pow(3,3);\n+----------+\n| pow(3,3) |\n+----------+\n| 27       |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#exp","title":"exp()","text":"<p>exp() returns the result of e^x^.</p> <p>Syntax: <code>exp(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the exponential <code>x</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN exp(2);\n+------------------+\n| exp(2)           |\n+------------------+\n| 7.38905609893065 |\n+------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#exp2","title":"exp2()","text":"<p>exp2() returns the result of 2^x^.</p> <p>Syntax: <code>exp2(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the exponential <code>x</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN exp2(3);\n+---------+\n| exp2(3) |\n+---------+\n| 8.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#log","title":"log()","text":"<p>log() returns the base-e logarithm of the argument. ($log_{e}{N}$)</p> <p>Syntax: <code>log(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the antilogarithm <code>N</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN log(8);\n+--------------------+\n| log(8)             |\n+--------------------+\n| 2.0794415416798357 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#log2","title":"log2()","text":"<p>log2() returns the base-2 logarithm of the argument. ($log_{2}{N}$)</p> <p>Syntax: <code>log2(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the antilogarithm <code>N</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN log2(8);\n+---------+\n| log2(8) |\n+---------+\n| 3.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#log10","title":"log10()","text":"<p>log10() returns the base-10 logarithm of the argument. ($log_{10}{N}$)</p> <p>Syntax: <code>log10(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the antilogarithm <code>N</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN log10(100);\n+------------+\n| log10(100) |\n+------------+\n| 2.0        |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#sin","title":"sin()","text":"<p>sin() returns the sine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>sin(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN sin(3);\n+--------------------+\n| sin(3)             |\n+--------------------+\n| 0.1411200080598672 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#asin","title":"asin()","text":"<p>asin() returns the inverse sine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>asin(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN asin(0.5);\n+--------------------+\n| asin(0.5)          |\n+--------------------+\n| 0.5235987755982989 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#cos","title":"cos()","text":"<p>cos() returns the cosine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>cos(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN cos(0.5);\n+--------------------+\n| cos(0.5)           |\n+--------------------+\n| 0.8775825618903728 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#acos","title":"acos()","text":"<p>acos() returns the inverse cosine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>acos(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN acos(0.5);\n+--------------------+\n| acos(0.5)          |\n+--------------------+\n| 1.0471975511965979 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#tan","title":"tan()","text":"<p>tan() returns the tangent of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>tan(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN tan(0.5);\n+--------------------+\n| tan(0.5)           |\n+--------------------+\n| 0.5463024898437905 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#atan","title":"atan()","text":"<p>atan() returns the inverse tangent of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>atan(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN atan(0.5);\n+--------------------+\n| atan(0.5)          |\n+--------------------+\n| 0.4636476090008061 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#rand","title":"rand()","text":"<p>rand() returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e.[0,1).</p> <p>Syntax: <code>rand()</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rand();\n+--------------------+\n| rand()             |\n+--------------------+\n| 0.6545837172298736 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#rand32","title":"rand32()","text":"<p>rand32() returns a random 32-bit integer in <code>[min, max)</code>.</p> <p>Syntax: <code>rand32(&lt;expression_min&gt;,&lt;expression_max&gt;)</code></p> <ul> <li><code>expression_min</code>: An expression of which the result type is int. It represents the minimum <code>min</code>.</li> </ul> <ul> <li><code>expression_max</code>: An expression of which the result type is int. It represents the maximum <code>max</code>.</li> </ul> <ul> <li>Result type: Int</li> </ul> <ul> <li>If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default. If you set no argument, the system returns a random signed 32-bit integer.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rand32(1,100);\n+---------------+\n| rand32(1,100) |\n+---------------+\n| 63            |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#rand64","title":"rand64()","text":"<p>rand64() returns a random 64-bit integer in <code>[min, max)</code>.</p> <p>Syntax: <code>rand64(&lt;expression_min&gt;,&lt;expression_max&gt;)</code></p> <ul> <li><code>expression_min</code>: An expression of which the result type is int. It represents the minimum <code>min</code>.</li> </ul> <ul> <li><code>expression_max</code>: An expression of which the result type is int. It represents the maximum <code>max</code>.</li> </ul> <ul> <li>Result type: Int</li> </ul> <ul> <li>If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default. If you set no argument, the system returns a random signed 64-bit integer.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rand64(1,100);\n+---------------+\n| rand64(1,100) |\n+---------------+\n| 34            |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#bit_and","title":"bit_and()","text":"<p>bit_and() returns the result of bitwise AND.</p> <p>Syntax: <code>bit_and(&lt;expression_1&gt;,&lt;expression_2&gt;)</code></p> <ul> <li><code>expression_1</code>, <code>expression_2</code>: An expression of which the result type is int.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN bit_and(5,6);\n+--------------+\n| bit_and(5,6) |\n+--------------+\n| 4            |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#bit_or","title":"bit_or()","text":"<p>bit_or() returns the result of bitwise OR.</p> <p>Syntax: <code>bit_or(&lt;expression_1&gt;,&lt;expression_2&gt;)</code></p> <ul> <li><code>expression_1</code>, <code>expression_2</code>: An expression of which the result type is int.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN bit_or(5,6);\n+-------------+\n| bit_or(5,6) |\n+-------------+\n| 7           |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#bit_xor","title":"bit_xor()","text":"<p>bit_xor() returns the result of bitwise XOR.</p> <p>Syntax: <code>bit_xor(&lt;expression_1&gt;,&lt;expression_2&gt;)</code></p> <ul> <li><code>expression_1</code>, <code>expression_2</code>: An expression of which the result type is int.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN bit_xor(5,6);\n+--------------+\n| bit_xor(5,6) |\n+--------------+\n| 3            |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#size","title":"size()","text":"<p>size() returns the number of elements in a list or a map, or the length of a string.</p> <p>Syntax: <code>size({&lt;expression&gt;|&lt;string&gt;})</code></p> <ul> <li><code>expression</code>: An expression for a list or map.</li> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN size([1,2,3,4]);\n+-----------------+\n| size([1,2,3,4]) |\n+-----------------+\n| 4               |\n+-----------------+\n</code></pre> <pre><code>nebula&gt; RETURN size(\"basketballplayer\") as size;\n+------+\n| size |\n+------+\n| 16   |\n+------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#range","title":"range()","text":"<p>range() returns a list of integers from <code>[start,end]</code> in the specified steps.</p> <p>Syntax: <code>range(&lt;expression_start&gt;,&lt;expression_end&gt;[,&lt;expression_step&gt;])</code></p> <ul> <li><code>expression_start</code>: An expression of which the result type is int. It represents the starting value <code>start</code>.</li> </ul> <ul> <li><code>expression_end</code>: An expression of which the result type is int. It represents the end value <code>end</code>.</li> </ul> <ul> <li><code>expression_step</code>: An expression of which the result type is int. It represents the step size <code>step</code>, <code>step</code> is 1 by default.</li> </ul> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN range(1,3*3,2);\n+------------------+\n| range(1,(3*3),2) |\n+------------------+\n| [1, 3, 5, 7, 9]  |\n+------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#sign","title":"sign()","text":"<p>sign() returns the signum of the given number. If the number is <code>0</code>, the system returns <code>0</code>. If the number is negative, the system returns <code>-1</code>. If the number is positive, the system returns <code>1</code>.</p> <p>Syntax: <code>sign(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN sign(10);\n+----------+\n| sign(10) |\n+----------+\n| 1        |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#e","title":"e()","text":"<p>e() returns the base of the natural logarithm, e (2.718281828459045).</p> <p>Syntax: <code>e()</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN e();\n+-------------------+\n| e()               |\n+-------------------+\n| 2.718281828459045 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#pi","title":"pi()","text":"<p>pi() returns the mathematical constant pi (3.141592653589793).</p> <p>Syntax: <code>pi()</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN pi();\n+-------------------+\n| pi()              |\n+-------------------+\n| 3.141592653589793 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#radians","title":"radians()","text":"<p>radians() converts angles to radians.</p> <p>Syntax: <code>radians(&lt;angle&gt;)</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN radians(180);\n+-------------------+\n| radians(180)      |\n+-------------------+\n| 3.141592653589793 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/14.geo/","title":"Geography functions","text":"<p>Geography functions are used to generate or perform operations on the value of the geography data type.</p> <p>For descriptions of the geography data types, see Geography.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/14.geo/#descriptions","title":"Descriptions","text":"Function Return Type Description ST_Point(longitude, latitude) <code>GEOGRAPHY</code> Creates the geography that contains a point. ST_GeogFromText(wkt_string) <code>GEOGRAPHY</code> Returns the geography corresponding to the input WKT string. ST_ASText(geography) <code>STRING</code> Returns the WKT string of the input geography. ST_Centroid(geography) <code>GEOGRAPHY</code> Returns the centroid of the input geography in the form of the single point geography. ST_ISValid(geography) <code>BOOL</code> Returns whether the input geography is valid. ST_Intersects(geography_1, geography_2) <code>BOOL</code> Returns whether geography_1 and geography_2 have intersections. ST_Covers(geography_1, geography_2) <code>BOOL</code> Returns whether geography_1 completely contains geography_2. If there is no point outside geography_1 in geography_2, return True. ST_CoveredBy(geography_1, geography_2) <code>BOOL</code> Returns whether geography_2 completely contains geography_1.If there is no point outside geography_2 in geography_1, return True. ST_DWithin(geography_1, geography_2, distance) <code>BOOL</code> If the distance between one point (at least) in geography_1 and one point in geography_2 is less than or equal to the distance specified by the distance parameter (measured by meters), return True. ST_Distance(geography_1, geography_2) <code>FLOAT</code> Returns the smallest possible distance (measured by meters) between two non-empty geographies. S2_CellIdFromPoint(point_geography) <code>INT</code> Returns the S2 Cell ID that covers the point geography. S2_CoveringCellIds(geography) <code>ARRAY&lt;INT64&gt;</code> Returns an array of S2 Cell IDs that cover the input geography."},{"location":"3.ngql-guide/6.functions-and-expressions/14.geo/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN ST_ASText(ST_Point(1,1));\n+--------------------------+\n| ST_ASText(ST_Point(1,1)) |\n+--------------------------+\n| \"POINT(1 1)\"             |\n+--------------------------+\n\nnebula&gt; RETURN ST_ASText(ST_GeogFromText(\"POINT(3 8)\"));\n+------------------------------------------+\n| ST_ASText(ST_GeogFromText(\"POINT(3 8)\")) |\n+------------------------------------------+\n| \"POINT(3 8)\"                             |\n+------------------------------------------+\n\nnebula&gt; RETURN ST_ASTEXT(ST_Centroid(ST_GeogFromText(\"LineString(0 1,1 0)\")));\n+----------------------------------------------------------------+\n| ST_ASTEXT(ST_Centroid(ST_GeogFromText(\"LineString(0 1,1 0)\"))) |\n+----------------------------------------------------------------+\n| \"POINT(0.5000380800773782 0.5000190382261059)\"                 |\n+----------------------------------------------------------------+\n\nnebula&gt; RETURN ST_ISValid(ST_GeogFromText(\"POINT(3 8)\"));\n+-------------------------------------------+\n| ST_ISValid(ST_GeogFromText(\"POINT(3 8)\")) |\n+-------------------------------------------+\n| true                                      |\n+-------------------------------------------+\n\nnebula&gt; RETURN ST_Intersects(ST_GeogFromText(\"LineString(0 1,1 0)\"),ST_GeogFromText(\"LineString(0 0,1 1)\"));\n+----------------------------------------------------------------------------------------------+\n| ST_Intersects(ST_GeogFromText(\"LineString(0 1,1 0)\"),ST_GeogFromText(\"LineString(0 0,1 1)\")) |\n+----------------------------------------------------------------------------------------------+\n| true                                                                                         |\n+----------------------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_Covers(ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"),ST_Point(1,2));\n+--------------------------------------------------------------------------------+\n| ST_Covers(ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"),ST_Point(1,2)) |\n+--------------------------------------------------------------------------------+\n| true                                                                           |\n+--------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_CoveredBy(ST_Point(1,2),ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"));\n+-----------------------------------------------------------------------------------+\n| ST_CoveredBy(ST_Point(1,2),ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\")) |\n+-----------------------------------------------------------------------------------+\n| true                                                                              |\n+-----------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_dwithin(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"),20000000000.0);\n+---------------------------------------------------------------------------------------+\n| ST_dwithin(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"),20000000000) |\n+---------------------------------------------------------------------------------------+\n| true                                                                                  |\n+---------------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_Distance(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"));\n+----------------------------------------------------------------------------+\n| ST_Distance(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\")) |\n+----------------------------------------------------------------------------+\n| 1.5685230187677438e+06                                                     |\n+----------------------------------------------------------------------------+\n\nnebula&gt; RETURN S2_CellIdFromPoint(ST_GeogFromText(\"Point(1 1)\"));\n+---------------------------------------------------+\n| S2_CellIdFromPoint(ST_GeogFromText(\"Point(1 1)\")) |\n+---------------------------------------------------+\n| 1153277837650709461                               |\n+---------------------------------------------------+\n\nnebula&gt; RETURN S2_CoveringCellIds(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| S2_CoveringCellIds(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"))                                                                                                     |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [1152391494368201343, 1153466862374223872, 1153554823304445952, 1153836298281156608, 1153959443583467520, 1154240918560178176, 1160503736791990272, 1160591697722212352] |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/","title":"Aggregating functions","text":"<p>This topic describes the aggregating functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#avg","title":"avg()","text":"<p>avg() returns the average value of the argument.</p> <p>Syntax: <code>avg(&lt;expression&gt;)</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN avg(v.player.age);\n+--------------------+\n| avg(v.player.age)  |\n+--------------------+\n| 33.294117647058826 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#count","title":"count()","text":"<p>count() returns the number of records.</p> <ul> <li>(Native nGQL) You can use <code>count()</code> and <code>GROUP BY</code> together to group and count the number of parameters. Use <code>YIELD</code> to return.</li> </ul> <ul> <li>(OpenCypher style) You can use <code>count()</code> and <code>RETURN</code>. <code>GROUP BY</code> is not necessary.</li> </ul> <p>Syntax: <code>count({&lt;expression&gt; | *})</code></p> <ul> <li>count(*) returns the number of rows (including NULL).</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 1, 1, 2, 2] As a UNWIND a AS b \\\n        RETURN count(b), count(*), count(DISTINCT b);\n+----------+----------+-------------------+\n| count(b) | count(*) | count(distinct b) |\n+----------+----------+-------------------+\n| 4        | 5        | 2                 |\n+----------+----------+-------------------+\n</code></pre> <pre><code># The statement in the following example searches for the people whom `player101` follows and people who follow `player101`, i.e. a bidirectional query.\n# Group and count the number of parameters.\nnebula&gt; GO FROM \"player101\" OVER follow BIDIRECT \\\n        YIELD properties($$).name AS Name \\\n        | GROUP BY $-.Name YIELD $-.Name, count(*);\n+---------------------+----------+\n| $-.Name             | count(*) |\n+---------------------+----------+\n| \"LaMarcus Aldridge\" | 2        |\n| \"Tim Duncan\"        | 2        |\n| \"Marco Belinelli\"   | 1        |\n| \"Manu Ginobili\"     | 1        |\n| \"Boris Diaw\"        | 1        |\n| \"Dejounte Murray\"   | 1        |\n+---------------------+----------+\n\n# Count the number of parameters.\nnebula&gt; MATCH (v1:player)-[:follow]-(v2:player) \\\n        WHERE id(v1)== \"player101\" \\\n        RETURN v2.player.name AS Name, count(*) as cnt ORDER BY cnt DESC;\n+---------------------+-----+\n| Name                | cnt |\n+---------------------+-----+\n| \"LaMarcus Aldridge\" | 2   |\n| \"Tim Duncan\"        | 2   |\n| \"Boris Diaw\"        | 1   |\n| \"Manu Ginobili\"     | 1   |\n| \"Dejounte Murray\"   | 1   |\n| \"Marco Belinelli\"   | 1   |\n+---------------------+-----+\n</code></pre> <p>The preceding example retrieves two columns:</p> <ul> <li><code>$-.Name</code>: the names of the people.</li> </ul> <ul> <li><code>count(*)</code>: how many times the names show up.</li> </ul> <p>Because there are no duplicate names in the <code>basketballplayer</code> dataset, the number <code>2</code> in the column <code>count(*)</code> shows that the person in that row and <code>player101</code> have followed each other.</p> <pre><code># a: The statement in the following example retrieves the age distribution of the players in the dataset.\nnebula&gt; LOOKUP ON player \\\n        YIELD player.age As playerage \\\n        | GROUP BY $-.playerage \\\n        YIELD $-.playerage as age, count(*) AS number \\\n        | ORDER BY $-.number DESC, $-.age DESC;\n+-----+--------+\n| age | number |\n+-----+--------+\n| 34  | 4      |\n| 33  | 4      |\n| 30  | 4      |\n| 29  | 4      |\n| 38  | 3      |\n+-----+--------+\n...\n# b: The statement in the following example retrieves the age distribution of the players in the dataset.\nnebula&gt; MATCH (n:player) \\\n        RETURN n.player.age as age, count(*) as number \\\n        ORDER BY number DESC, age DESC;\n+-----+--------+\n| age | number |\n+-----+--------+\n| 34  | 4      |\n| 33  | 4      |\n| 30  | 4      |\n| 29  | 4      |\n| 38  | 3      |\n+-----+--------+\n...\n</code></pre> <pre><code># The statement in the following example counts the number of edges that Tim Duncan relates.\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) -[e]- (v2) \\\n        RETURN count(e);\n+----------+\n| count(e) |\n+----------+\n| 13       |\n+----------+\n\n# The statement in the following example counts the number of edges that Tim Duncan relates and returns two columns (no DISTINCT and DISTINCT) in multi-hop queries.\nnebula&gt; MATCH (n:player {name : \"Tim Duncan\"})-[]-&gt;(friend:player)-[]-&gt;(fof:player) \\\n        RETURN count(fof), count(DISTINCT fof);\n+------------+---------------------+\n| count(fof) | count(distinct fof) |\n+------------+---------------------+\n| 4          | 3                   |\n+------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#max","title":"max()","text":"<p>max() returns the maximum value.</p> <p>Syntax: <code>max(&lt;expression&gt;)</code></p> <ul> <li>Result type: Same as the original argument.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN max(v.player.age);\n+-------------------+\n| max(v.player.age) |\n+-------------------+\n| 47                |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#min","title":"min()","text":"<p>min() returns the minimum value.</p> <p>Syntax: <code>min(&lt;expression&gt;)</code></p> <ul> <li>Result type: Same as the original argument.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN min(v.player.age);\n+-------------------+\n| min(v.player.age) |\n+-------------------+\n| 20                |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#collect","title":"collect()","text":"<p>collect() returns a list containing the values returned by an expression. Using this function aggregates data by merging multiple records or values into a single list.</p> <p>Syntax: <code>collect(&lt;expression&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; UNWIND [1, 2, 1] AS a \\\n        RETURN a;\n+---+\n| a |\n+---+\n| 1 |\n| 2 |\n| 1 |\n+---+\n\nnebula&gt; UNWIND [1, 2, 1] AS a \\\n        RETURN collect(a);\n+------------+\n| collect(a) |\n+------------+\n| [1, 2, 1]  |\n+------------+\n\nnebula&gt; UNWIND [1, 2, 1] AS a \\\n        RETURN a, collect(a), size(collect(a));\n+---+------------+------------------+\n| a | collect(a) | size(collect(a)) |\n+---+------------+------------------+\n| 2 | [2]        | 1                |\n| 1 | [1, 1]     | 2                |\n+---+------------+------------------+\n\n# The following examples sort the results in descending order, limit output rows to 3, and collect the output into a list.\nnebula&gt; UNWIND [\"c\", \"b\", \"a\", \"d\" ] AS p \\\n        WITH p AS q \\\n        ORDER BY q DESC LIMIT 3 \\\n        RETURN collect(q);\n+-----------------+\n| collect(q)      |\n+-----------------+\n| [\"d\", \"c\", \"b\"] |\n+-----------------+\n\nnebula&gt; WITH [1, 1, 2, 2] AS coll \\\n        UNWIND coll AS x \\\n        WITH DISTINCT x \\\n        RETURN collect(x) AS ss;\n+--------+\n| ss     |\n+--------+\n| [1, 2] |\n+--------+\n\nnebula&gt; MATCH (n:player) \\\n        RETURN collect(n.player.age);\n+---------------------------------------------------------------+\n| collect(n.player.age)                                         |\n+---------------------------------------------------------------+\n| [32, 32, 34, 29, 41, 40, 33, 25, 40, 37, ...\n...\n\n# The following example aggregates all the players' names by their ages.\nnebula&gt; MATCH (n:player) \\\n        RETURN n.player.age AS age, collect(n.player.name);\n+-----+--------------------------------------------------------------------------+\n| age | collect(n.player.name)                                                   |\n+-----+--------------------------------------------------------------------------+\n| 24  | [\"Giannis Antetokounmpo\"]                                                |\n| 20  | [\"Luka Doncic\"]                                                          |\n| 25  | [\"Joel Embiid\", \"Kyle Anderson\"]                                         |\n+-----+--------------------------------------------------------------------------+\n...\n\nnebula&gt; GO FROM \"player100\" OVER serve \\\n        YIELD properties($$).name AS name \\\n        | GROUP BY $-.name \\\n        YIELD collect($-.name) AS name;\n+-----------+\n| name      |\n+-----------+\n| [\"Spurs\"] |\n+-----------+\n\nnebula&gt; LOOKUP ON player \\\n        YIELD player.age As playerage \\\n        | GROUP BY $-.playerage \\\n        YIELD collect($-.playerage) AS playerage;\n+------------------+\n| playerage        |\n+------------------+\n| [22]             |\n| [47]             |\n| [43]             |\n| [25, 25]         |\n+------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#std","title":"std()","text":"<p>std() returns the population standard deviation.</p> <p>Syntax: <code>std(&lt;expression&gt;)</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN std(v.player.age);\n+-------------------+\n| std(v.player.age) |\n+-------------------+\n| 6.423895701687502 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#sum","title":"sum()","text":"<p>sum() returns the sum value.</p> <p>Syntax: <code>sum(&lt;expression&gt;)</code></p> <ul> <li>Result type: Same as the original argument.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN sum(v.player.age);\n+-------------------+\n| sum(v.player.age) |\n+-------------------+\n| 1698              |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#aggregating_example","title":"Aggregating example","text":"<pre><code>nebula&gt;  GO FROM \"player100\" OVER follow YIELD dst(edge) AS dst, properties($$).age AS age \\\n         | GROUP BY $-.dst \\\n         YIELD \\\n         $-.dst AS dst, \\\n         toInteger((sum($-.age)/count($-.age)))+avg(distinct $-.age+1)+1 AS statistics;\n+-------------+------------+\n| dst         | statistics |\n+-------------+------------+\n| \"player125\" | 84.0       |\n| \"player101\" | 74.0       |\n+-------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/","title":"Type conversion functions","text":"<p>This topic describes the type conversion functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#toboolean","title":"toBoolean()","text":"<p>toBoolean() converts a string value to a boolean value.</p> <p>Syntax: <code>toBoolean(&lt;value&gt;)</code></p> <ul> <li>Result type: Bool</li> </ul> <p>Example:</p> <pre><code>nebula&gt; UNWIND [true, false, 'true', 'false', NULL] AS b \\\n        RETURN toBoolean(b) AS b;\n+----------+\n| b        |\n+----------+\n| true     |\n| false    |\n| true     |\n| false    |\n| __NULL__ |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#tofloat","title":"toFloat()","text":"<p>toFloat() converts an integer or string value to a floating point number.</p> <p>Syntax: <code>toFloat(&lt;value&gt;)</code></p> <ul> <li>Result type: Float</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toFloat(1), toFloat('1.3'), toFloat('1e3'), toFloat('not a number');\n+------------+----------------+----------------+-------------------------+\n| toFloat(1) | toFloat(\"1.3\") | toFloat(\"1e3\") | toFloat(\"not a number\") |\n+------------+----------------+----------------+-------------------------+\n| 1.0        | 1.3            | 1000.0         | __NULL__                |\n+------------+----------------+----------------+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#tostring","title":"toString()","text":"<p>toString() converts non-compound types of data, such as numbers, booleans, and so on, to strings.</p> <p>Syntax: <code>toString(&lt;value&gt;)</code></p> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toString(9669) AS int2str, toString(null) AS null2str;\n+---------+----------+\n| int2str | null2str |\n+---------+----------+\n| \"9669\"  | __NULL__ |\n+---------+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#tointeger","title":"toInteger()","text":"<p>toInteger() converts a floating point or string value to an integer value.</p> <p>Syntax: <code>toInteger(&lt;value&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toInteger(1), toInteger('1'), toInteger('1e3'), toInteger('not a number');\n+--------------+----------------+------------------+---------------------------+\n| toInteger(1) | toInteger(\"1\") | toInteger(\"1e3\") | toInteger(\"not a number\") |\n+--------------+----------------+------------------+---------------------------+\n| 1            | 1              | 1000             | __NULL__                  |\n+--------------+----------------+------------------+---------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#toset","title":"toSet()","text":"<p>toSet() converts a list or set value to a set value.</p> <p>Syntax: <code>toSet(&lt;value&gt;)</code></p> <ul> <li>Result type: Set</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toSet(list[1,2,3,1,2]) AS list2set;\n+-----------+\n| list2set  |\n+-----------+\n| {3, 1, 2} |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#hash","title":"hash()","text":"<p>hash() returns the hash value of the argument. The argument can be a number, a string, a list, a boolean, null, or an expression that evaluates to a value of the preceding data types.</p> <p>The source code of the <code>hash()</code> function (MurmurHash2), seed (<code>0xc70f6907UL</code>), and other parameters can be found in <code>MurmurHash2.h</code>.</p> <p>For Java, the hash function operates as follows.</p> <pre><code>MurmurHash2.hash64(\"to_be_hashed\".getBytes(),\"to_be_hashed\".getBytes().length, 0xc70f6907)\n</code></pre> <p>Syntax: <code>hash(&lt;string&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN hash(\"abcde\");\n+--------------------+\n| hash(\"abcde\")      |\n+--------------------+\n| 811036730794841393 |\n+--------------------+\nnebula&gt; YIELD hash([1,2,3]);\n+----------------+\n| hash([1,2,3])  |\n+----------------+\n| 11093822460243 |\n+----------------+\nnebula&gt; YIELD hash(NULL);\n+------------+\n| hash(NULL) |\n+------------+\n| -1         |\n+------------+\nnebula&gt; YIELD hash(toLower(\"HELLO NEBULA\"));\n+-------------------------------+\n| hash(toLower(\"HELLO NEBULA\")) |\n+-------------------------------+\n| -8481157362655072082          |\n+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/","title":"Built-in string functions","text":"<p>This topic describes the built-in string functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#precautions","title":"Precautions","text":"<ul> <li>A string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes.</li> </ul> <ul> <li>Like SQL, the position index of nGQL starts from <code>1</code>, while in C language it starts from <code>0</code>.</li> </ul>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#strcasecmp","title":"strcasecmp()","text":"<p>strcasecmp() compares string a and b without case sensitivity.</p> <p>Syntax: <code>strcasecmp(&lt;string_a&gt;,&lt;string_b&gt;)</code></p> <ul> <li><code>string_a</code>, <code>string_b</code>: Strings to compare.</li> </ul> <ul> <li>Result type: Int</li> </ul> <ul> <li>When <code>string_a = string_b</code>, the return value is <code>0</code>. When <code>string_a &gt; string_b</code>, the return value is greater than <code>0</code>. When <code>string_a &lt; string_b</code>, the return value is less than <code>0</code>.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN strcasecmp(\"a\",\"aa\");\n+----------------------+\n| strcasecmp(\"a\",\"aa\") |\n+----------------------+\n| -97                  |\n+----------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#lower_and_tolower","title":"lower() and toLower()","text":"<p>lower() and toLower() can both returns the argument in lowercase.</p> <p>Syntax: <code>lower(&lt;string&gt;)</code>, <code>toLower(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN lower(\"Basketball_Player\");\n+----------------------------+\n| lower(\"Basketball_Player\") |\n+----------------------------+\n| \"basketball_player\"        |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#upper_and_toupper","title":"upper() and toUpper()","text":"<p>upper() and toUpper() can both returns the argument in uppercase.</p> <p>Syntax: <code>upper(&lt;string&gt;)</code>, <code>toUpper(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN upper(\"Basketball_Player\");\n+----------------------------+\n| upper(\"Basketball_Player\") |\n+----------------------------+\n| \"BASKETBALL_PLAYER\"        |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#length","title":"length()","text":"<p>length() returns the length of the given string in bytes.</p> <p>Syntax: <code>length({&lt;string&gt;|&lt;path&gt;})</code></p> <ul> <li><code>string</code>: A specified string.</li> <li><code>path</code>: A specified path represented by a variable.</li> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN length(\"basketball\");\n+----------------------+\n| length(\"basketball\") |\n+----------------------+\n| 10                   |\n+----------------------+\n</code></pre> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) return length(p);\n+-----------+\n| length(p) |\n+-----------+\n| 1         |\n| 1         |\n| 1         |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#trim","title":"trim()","text":"<p>trim() removes the spaces at the leading and trailing of the string.</p> <p>Syntax: <code>trim(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN trim(\" basketball player \");\n+-----------------------------+\n| trim(\" basketball player \") |\n+-----------------------------+\n| \"basketball player\"         |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#ltrim","title":"ltrim()","text":"<p>ltrim() removes the spaces at the leading of the string.</p> <p>Syntax: <code>ltrim(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN ltrim(\" basketball player \");\n+------------------------------+\n| ltrim(\" basketball player \") |\n+------------------------------+\n| \"basketball player \"         |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#rtrim","title":"rtrim()","text":"<p>rtrim() removes the spaces at the trailing of the string.</p> <p>Syntax: <code>rtrim(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rtrim(\" basketball player \");\n+------------------------------+\n| rtrim(\" basketball player \") |\n+------------------------------+\n| \" basketball player\"         |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#left","title":"left()","text":"<p>left() returns a substring consisting of several characters from the leading of a string.</p> <p>Syntax: <code>left(&lt;string&gt;,&lt;count&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The number of characters from the leading of the string. If the string is shorter than <code>count</code>, the system returns the string itself.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN left(\"basketball_player\",6);\n+-----------------------------+\n| left(\"basketball_player\",6) |\n+-----------------------------+\n| \"basket\"                    |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#right","title":"right()","text":"<p>right() returns a substring consisting of several characters from the trailing of a string.</p> <p>Syntax: <code>right(&lt;string&gt;,&lt;count&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The number of characters from the trailing of the string. If the string is shorter than <code>count</code>, the system returns the string itself.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN right(\"basketball_player\",6);\n+------------------------------+\n| right(\"basketball_player\",6) |\n+------------------------------+\n| \"player\"                     |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#lpad","title":"lpad()","text":"<p>lpad() pads a specified string from the left-side to the specified length and returns the result string.</p> <p>Syntax: <code>lpad(&lt;string&gt;,&lt;count&gt;,&lt;letters&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The length of the string after it has been left-padded. If the length is less than that of <code>string</code>, only the length of <code>string</code> characters from front to back will be returned.</li> </ul> <ul> <li><code>letters</code>: A string to be padding from the leading.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN lpad(\"abcd\",10,\"b\");\n+---------------------+\n| lpad(\"abcd\",10,\"b\") |\n+---------------------+\n| \"bbbbbbabcd\"        |\n+---------------------+\nnebula&gt; RETURN lpad(\"abcd\",3,\"b\");\n+--------------------+\n| lpad(\"abcd\",3,\"b\") |\n+--------------------+\n| \"abc\"              |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#rpad","title":"rpad()","text":"<p>rpad() pads a specified string from the right-side to the specified length and returns the result string.</p> <p>Syntax: <code>rpad(&lt;string&gt;,&lt;count&gt;,&lt;letters&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The length of the string after it has been right-padded. If the length is less than that of <code>string</code>, only the length of <code>string</code> characters from front to back will be returned.</li> </ul> <ul> <li><code>letters</code>: A string to be padding from the trailing.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rpad(\"abcd\",10,\"b\");\n+---------------------+\n| rpad(\"abcd\",10,\"b\") |\n+---------------------+\n| \"abcdbbbbbb\"        |\n+---------------------+\nnebula&gt; RETURN rpad(\"abcd\",3,\"b\");\n+--------------------+\n| rpad(\"abcd\",3,\"b\") |\n+--------------------+\n| \"abc\"              |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#substr_and_substring","title":"substr() and substring()","text":"<p>substr() and substring() return a substring extracting <code>count</code> characters starting from the specified position <code>pos</code> of a specified string.</p> <p>Syntax: <code>substr(&lt;string&gt;,&lt;pos&gt;,&lt;count&gt;)</code>, <code>substring(&lt;string&gt;,&lt;pos&gt;,&lt;count&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>pos</code>: The position of starting extract (character index). Data type is int.</li> </ul> <ul> <li><code>count</code>: The number of characters extracted from the start position onwards.</li> </ul> <ul> <li>Result type: String</li> </ul>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#explanations_for_the_return_of_substr_and_substring","title":"Explanations for the return of <code>substr()</code> and <code>substring()</code>","text":"<ul> <li>If <code>pos</code> is 0, it extracts from the specified string leading (including the first character).</li> </ul> <ul> <li>If <code>pos</code> is greater than the maximum string index, an empty string is returned.</li> </ul> <ul> <li>If <code>pos</code> is a negative number, <code>BAD_DATA</code> is returned.</li> </ul> <ul> <li>If <code>count</code> is omitted, the function returns the substring starting at the position given by <code>pos</code> and extending to the end of the string.</li> </ul> <ul> <li>If <code>count</code> is 0, an empty string is returned.</li> </ul> <ul> <li>Using <code>NULL</code> as any of the argument of <code>substr()</code> will cause an issue.</li> </ul> <p>OpenCypher compatibility</p> <p>In openCypher, if <code>a</code> is <code>null</code>, <code>null</code> is returned.</p> <p>Example:</p> <pre><code>nebula&gt; RETURN substr(\"abcdefg\",2,4);\n+-----------------------+\n| substr(\"abcdefg\",2,4) |\n+-----------------------+\n| \"cdef\"                |\n+-----------------------+\nnebula&gt; RETURN substr(\"abcdefg\",0,4);\n+-----------------------+\n| substr(\"abcdefg\",0,4) |\n+-----------------------+\n| \"abcd\"                |\n+-----------------------+\nnebula&gt; RETURN substr(\"abcdefg\",2);\n+---------------------+\n| substr(\"abcdefg\",2) |\n+---------------------+\n| \"cdefg\"             |\n+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#reverse","title":"reverse()","text":"<p>reverse() returns a string in reverse order.</p> <p>Syntax: <code>reverse(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN reverse(\"abcdefg\");\n+--------------------+\n| reverse(\"abcdefg\") |\n+--------------------+\n| \"gfedcba\"          |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#replace","title":"replace()","text":"<p>replace() replaces string a in a specified string with string b.</p> <p>Syntax: <code>replace(&lt;string&gt;,&lt;substr_a&gt;,&lt;string_b&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>substr_a</code>: String a.</li> </ul> <ul> <li><code>string_b</code>: String b.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN replace(\"abcdefg\",\"cd\",\"AAAAA\");\n+---------------------------------+\n| replace(\"abcdefg\",\"cd\",\"AAAAA\") |\n+---------------------------------+\n| \"abAAAAAefg\"                    |\n+---------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#split","title":"split()","text":"<p>split() splits a specified string at string b and returns a list of strings.</p> <p>Syntax: <code>split(&lt;string&gt;,&lt;substr&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>substr</code>: String b.</li> </ul> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN split(\"basketballplayer\",\"a\");\n+-------------------------------+\n| split(\"basketballplayer\",\"a\") |\n+-------------------------------+\n| [\"b\", \"sketb\", \"llpl\", \"yer\"] |\n+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#concat","title":"concat()","text":"<p>concat() returns strings concatenated by all strings.</p> <p>Syntax: <code>concat(&lt;string1&gt;,&lt;string2&gt;,...)</code></p> <ul> <li>The function requires at least two or more strings. If there is only one string, the string itself is returned.</li> </ul> <ul> <li>If any one of the strings is <code>NULL</code>, <code>NULL</code> is returned.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>//This example concatenates 1, 2, and 3.\nnebula&gt; RETURN concat(\"1\",\"2\",\"3\") AS r;\n+-------+\n| r     |\n+-------+\n| \"123\" |\n+-------+\n\n//In this example, one of the string is NULL.\nnebula&gt; RETURN concat(\"1\",\"2\",NULL) AS r;\n+----------+\n| r        |\n+----------+\n| __NULL__ |\n+----------+\n\nnebula&gt; GO FROM \"player100\" over follow \\\n        YIELD concat(src(edge), properties($^).age, properties($$).name, properties(edge).degree) AS A;\n+------------------------------+\n| A                            |\n+------------------------------+\n| \"player10042Tony Parker95\"   |\n| \"player10042Manu Ginobili95\" |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#concat_ws","title":"concat_ws()","text":"<p>concat_ws() returns strings concatenated by all strings that are delimited with a separator.</p> <p>Syntax: <code>concat_ws(&lt;separator&gt;,&lt;string1&gt;,&lt;string2&gt;,... )</code></p> <ul> <li>The function requires at least two or more strings.</li> </ul> <ul> <li>If the separator is <code>NULL</code>, the <code>concat_ws()</code> function returns <code>NULL</code>.</li> </ul> <ul> <li>If the separator is not <code>NULL</code> and there is only one string, the string itself is returned.</li> </ul> <ul> <li>If there is a <code>NULL</code> in the strings, <code>NULL</code> is ignored during the concatenation.</li> </ul> <p>Example:</p> <pre><code>//This example concatenates a, b, and c with the separator +.\nnebula&gt; RETURN concat_ws(\"+\",\"a\",\"b\",\"c\") AS r;\n+---------+\n| r       |\n+---------+\n| \"a+b+c\" |\n+---------+\n\n//In this example, the separator is NULL.\nneubla&gt; RETURN concat_ws(NULL,\"a\",\"b\",\"c\") AS r;\n+----------+\n| r        |\n+----------+\n| __NULL__ |\n+----------+\n\n//In this example, the separator is + and there is a NULL in the strings.\nnebula&gt; RETURN concat_ws(\"+\",\"a\",NULL,\"b\",\"c\") AS r;\n+---------+\n| r       |\n+---------+\n| \"a+b+c\" |\n+---------+\n\n//In this example, the separator is + and there is only one string.\nnebula&gt; RETURN concat_ws(\"+\",\"a\") AS r;\n+-----+\n| r   |\n+-----+\n| \"a\" |\n+-----+\nnebula&gt; GO FROM \"player100\" over follow \\\n        YIELD concat_ws(\" \",src(edge), properties($^).age, properties($$).name, properties(edge).degree) AS A;\n+---------------------------------+\n| A                               |\n+---------------------------------+\n| \"player100 42 Tony Parker 95\"   |\n| \"player100 42 Manu Ginobili 95\" |\n+---------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#extract","title":"extract()","text":"<p>extract() uses regular expression matching to retrieve a single substring or all substrings from a string.</p> <p>Syntax: <code>extract(&lt;string&gt;,\"&lt;regular_expression&gt;\")</code></p> <ul> <li><code>string</code>: A specified string</li> <li><code>regular_expression</code>: A regular expression</li> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (a:player)-[b:serve]-(c:team{name: \"Lakers\"}) \\\n        WHERE a.player.age &gt; 45 \\\n        RETURN extract(a.player.name, \"\\\\w+\") AS result;\n+----------------------------+\n| result                     |\n+----------------------------+\n| [\"Shaquille\", \"O\", \"Neal\"] |\n+----------------------------+\n\nnebula&gt; MATCH (a:player)-[b:serve]-(c:team{name: \"Lakers\"}) \\\n        WHERE a.player.age &gt; 45 \\\n        RETURN extract(a.player.name, \"hello\") AS result;\n+--------+\n| result |\n+--------+\n| []     |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#json_extract","title":"json_extract()","text":"<p>json_extract() converts the specified JSON string to a map.</p> <p>Syntax: <code>extract(&lt;string&gt;)</code></p> <ul> <li><code>string</code>:A specified string, must be JSON string.</li> <li>Result type: Map</li> </ul> <p>Caution</p> <ul> <li>Only Bool, Double, Int, String value and NULL are supported.</li> <li>Only depth-1 nested Map is supported now. If nested Map depth is greater than 1, the nested item is left as an empty Map().</li> </ul> <p>Example:</p> <pre><code>nebula&gt; YIELD json_extract('{\"a\": 1, \"b\": {}, \"c\": {\"d\": true}}') AS result;\n+-----------------------------+\n| result                      |\n+-----------------------------+\n| {a: 1, b: {}, c: {d: true}} |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/","title":"Built-in date and time functions","text":"<p>NebulaGraph supports the following built-in date and time functions:</p> Function Description int now() Returns the current timestamp of the system. timestamp timestamp() Returns the current timestamp of the system. date date() Returns the current UTC date based on the current system. time time() Returns the current UTC time based on the current system. datetime datetime() Returns the current UTC date and time based on the current system. map duration() Returns the period of time. It can be used to calculate the specified time. <p>For more information, see Date and time types.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/#examples","title":"Examples","text":"<pre><code>nebula&gt;  RETURN now(), timestamp(), date(), time(), datetime();\n+------------+-------------+------------+-----------------+----------------------------+\n| now()      | timestamp() | date()     | time()          | datetime()                 |\n+------------+-------------+------------+-----------------+----------------------------+\n| 1640057560 | 1640057560  | 2021-12-21 | 03:32:40.351000 | 2021-12-21T03:32:40.351000 |\n+------------+-------------+------------+-----------------+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/","title":"Schema-related functions","text":"<p>This topic describes the schema-related functions supported by NebulaGraph. There are two types of schema-related functions, one for native nGQL statements and the other for openCypher-compatible statements.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#for_ngql_statements","title":"For nGQL statements","text":"<p>The following functions are available in <code>YIELD</code> and <code>WHERE</code> clauses of nGQL statements.</p> <p>Note</p> <p>Since vertex, edge, vertices, edges, and path are keywords, you need to use <code>AS &lt;alias&gt;</code> to set the alias, such as <code>GO FROM \"player100\" OVER follow YIELD edge AS e;</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#idvertex","title":"id(vertex)","text":"<p>id(vertex) returns the ID of a vertex.</p> <p>Syntax: <code>id(vertex)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age  &gt; 45 YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player144\" |\n| \"player140\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#propertiesvertex","title":"properties(vertex)","text":"<p>properties(vertex) returns the properties of a vertex.</p> <p>Syntax: <code>properties(vertex)</code></p> <ul> <li>Result type: Map</li> </ul> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age  &gt; 45 \\\n        YIELD properties(vertex);\n+-------------------------------------+\n| properties(VERTEX)                  |\n+-------------------------------------+\n| {age: 47, name: \"Shaquille O'Neal\"} |\n| {age: 46, name: \"Grant Hill\"}       |\n+-------------------------------------+\n</code></pre> <p>You can also use the property reference symbols (<code>$^</code> and <code>$$</code>) instead of the <code>vertex</code> field in the <code>properties()</code> function to get all properties of a vertex.</p> <ul> <li><code>$^</code> represents the data of the starting vertex at the beginning of exploration. For example, in <code>GO FROM \"player100\" OVER follow reversely YIELD properties($^)</code>, <code>$^</code> refers to the vertex <code>player100</code>.</li> </ul> <ul> <li><code>$$</code> represents the data of the end vertex at the end of exploration.</li> </ul> <p><code>properties($^)</code> and <code>properties($$)</code> are generally used in <code>GO</code> statements. For more information, see Property reference.</p> <p>Caution</p> <p>You can use <code>properties().&lt;property_name&gt;</code> to get a specific property of a vertex. However, it is not recommended to use this method to obtain specific properties because the <code>properties()</code> function returns all properties, which can decrease query performance.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#propertiesedge","title":"properties(edge)","text":"<p>properties(edge) returns the properties of an edge.</p> <p>Syntax: <code>properties(edge)</code></p> <ul> <li>Result type: Map</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties(edge);\n+------------------+\n| properties(EDGE) |\n+------------------+\n| {degree: 95}     |\n| {degree: 95}     |\n+------------------+\n</code></pre> <p>Caution</p> <p>You can use <code>properties(edge).&lt;property_name&gt;</code> to get a specific property of an edge. However, it is not recommended to use this method to obtain specific properties because the <code>properties(edge)</code> function returns all properties, which can decrease query performance.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#typeedge","title":"type(edge)","text":"<p>type(edge) returns the edge type of an edge.</p> <p>Syntax: <code>type(edge)</code></p> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge), type(edge), rank(edge);\n+-------------+-------------+------------+------------+\n| src(EDGE)   | dst(EDGE)   | type(EDGE) | rank(EDGE) |\n+-------------+-------------+------------+------------+\n| \"player100\" | \"player101\" | \"follow\"   | 0          |\n| \"player100\" | \"player125\" | \"follow\"   | 0          |\n+-------------+-------------+------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#srcedge","title":"src(edge)","text":"<p>src(edge) returns the source vertex ID of an edge.</p> <p>Syntax: <code>src(edge)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge);\n+-------------+-------------+\n| src(EDGE)   | dst(EDGE)   |\n+-------------+-------------+\n| \"player100\" | \"player101\" |\n| \"player100\" | \"player125\" |\n+-------------+-------------+\n</code></pre> <p>Note</p> <p>The semantics of the query for the starting vertex with src(edge) and properties(<code>$^</code>) are different. src(edge) indicates the starting vertex ID of the edge in the graph database, while properties(<code>$^</code>) indicates the data of the starting vertex where you start to expand the graph, such as the data of the starting vertex <code>player100</code> in the above GO statement. </p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#dstedge","title":"dst(edge)","text":"<p>dst(edge) returns the destination vertex ID of an edge.</p> <p>Syntax: <code>dst(edge)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge);\n+-------------+-------------+\n| src(EDGE)   | dst(EDGE)   |\n+-------------+-------------+\n| \"player100\" | \"player101\" |\n| \"player100\" | \"player125\" |\n+-------------+-------------+\n</code></pre> <p>Note</p> <p>dst(edge) indicates the destination vertex ID of the edge in the graph database.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#rankedge","title":"rank(edge)","text":"<p>rank(edge) returns the rank value of an edge.</p> <p>Syntax: <code>rank(edge)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge), rank(edge);\n+-------------+-------------+------------+\n| src(EDGE)   | dst(EDGE)   | rank(EDGE) |\n+-------------+-------------+------------+\n| \"player100\" | \"player101\" | 0          |\n| \"player100\" | \"player125\" | 0          |\n+-------------+-------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#vertex","title":"vertex","text":"<p>vertex returns the information of vertices, including VIDs, tags, properties, and values. You need to use <code>AS &lt;alias&gt;</code> to set the alias.</p> <p>Syntax: <code>vertex</code></p> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age &gt; 45 YIELD vertex AS v;\n+----------------------------------------------------------+\n| v                                                        |\n+----------------------------------------------------------+\n| (\"player144\" :player{age: 47, name: \"Shaquille O'Neal\"}) |\n| (\"player140\" :player{age: 46, name: \"Grant Hill\"})       |\n+----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#edge","title":"edge","text":"<p>edge returns the information of edges, including edge types, source vertices, destination vertices, ranks, properties, and values. You need to use <code>AS &lt;alias&gt;</code> to set the alias.</p> <p>Syntax: <code>edge</code></p> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD edge AS e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}] |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}] |\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#vertices","title":"vertices","text":"<p>vertices returns the information of vertices in a subgraph. For more information, see GET SUBGRAPH.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#edges","title":"edges","text":"<p>edges returns the information of edges in a subgraph. For more information, see GET SUBGRAPH.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#path","title":"path","text":"<p>path returns the information of a path. For more information, see FIND PATH.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#for_statements_compatible_with_opencypher","title":"For statements compatible with openCypher","text":"<p>The following functions are available in <code>RETURN</code> and <code>WHERE</code> clauses of openCypher-compatible statements.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#id","title":"id()","text":"<p>id() returns the ID of a vertex.</p> <p>Syntax: <code>id(&lt;vertex&gt;)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN id(v); \n+-------------+\n| id(v)       |\n+-------------+\n| \"player129\" |\n| \"player115\" |\n| \"player106\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#tags_and_labels","title":"tags() and labels()","text":"<p>tags() and labels() return the Tag of a vertex.</p> <p>Syntax: <code>tags(&lt;vertex&gt;)</code>, <code>labels(&lt;vertex&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v) WHERE id(v) == \"player100\" \\\n        RETURN tags(v);\n+------------+\n| tags(v)    |\n+------------+\n| [\"player\"] |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#properties","title":"properties()","text":"<p>properties() returns the properties of a vertex or an edge.</p> <p>Syntax: <code>properties(&lt;vertex_or_edge&gt;)</code></p> <ul> <li>Result type: Map</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player)-[e:follow]-() RETURN properties(v),properties(e);\n+---------------------------------------+---------------+\n| properties(v)                         | properties(e) |\n+---------------------------------------+---------------+\n| {age: 31, name: \"Stephen Curry\"}      | {degree: 90}  |\n| {age: 47, name: \"Shaquille O'Neal\"}   | {degree: 100} |\n| {age: 34, name: \"LeBron James\"}       | {degree: 13}  |\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#type","title":"type()","text":"<p>type() returns the edge type of an edge.</p> <p>Syntax: <code>type(&lt;edge&gt;)</code></p> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN type(e);\n+----------+\n| type(e)  |\n+----------+\n| \"serve\"  |\n| \"follow\" |\n| \"follow\" |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#typeid","title":"typeid()","text":"<p>typeid() returns the internal ID value of the Edge type of the edge, which can be used to determine the direction by positive or negative.</p> <p>Syntax: <code>typeid(&lt;edge&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player)-[e:follow]-(v2) RETURN e,typeid(e), \\\n        CASE WHEN typeid(e) &gt; 0 \\\n        THEN \"Forward\" ELSE \"Reverse\" END AS direction \\\n        LIMIT 5;\n+----------------------------------------------------+-----------+-----------+\n| e                                                  | typeid(e) | direction |\n+----------------------------------------------------+-----------+-----------+\n| [:follow \"player127\"-&gt;\"player114\" @0 {degree: 90}] | 5         | \"Forward\" |\n| [:follow \"player127\"-&gt;\"player148\" @0 {degree: 70}] | 5         | \"Forward\" |\n| [:follow \"player148\"-&gt;\"player127\" @0 {degree: 80}] | -5        | \"Reverse\" |\n| [:follow \"player147\"-&gt;\"player136\" @0 {degree: 90}] | 5         | \"Forward\" |\n| [:follow \"player136\"-&gt;\"player147\" @0 {degree: 90}] | -5        | \"Reverse\" |\n+----------------------------------------------------+-----------+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#src","title":"src()","text":"<p>src() returns the source vertex ID of an edge.</p> <p>Syntax: <code>src(&lt;edge&gt;)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH ()-[e]-&gt;(v:player{name:\"Tim Duncan\"}) \\\n        RETURN src(e);\n+-------------+\n| src(e)      |\n+-------------+\n| \"player125\" |\n| \"player113\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#dst","title":"dst()","text":"<p>dst() returns the destination vertex ID of an edge.</p> <p>Syntax: <code>dst(&lt;edge&gt;)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN dst(e);\n+-------------+\n| dst(e)      |\n+-------------+\n| \"team204\"   |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#startnode","title":"startNode()","text":"<p>startNode() visits a path and returns its information of source vertex ID, including VIDs, tags, properties, and values.</p> <p>Syntax: <code>startNode(&lt;path&gt;)</code></p> <p>Example:</p> <pre><code>nebula&gt; MATCH p = (a :player {name : \"Tim Duncan\"})-[r:serve]-(t) \\\n        RETURN startNode(p);\n+----------------------------------------------------+\n| startNode(p)                                       |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#endnode","title":"endNode()","text":"<p>endNode() visits a path and returns its information of destination vertex ID, including VIDs, tags, properties, and values.</p> <p>Syntax: <code>endNode(&lt;path&gt;)</code></p> <p>Example:</p> <pre><code>nebula&gt; MATCH p = (a :player {name : \"Tim Duncan\"})-[r:serve]-(t) \\\n        RETURN endNode(p);\n+----------------------------------+\n| endNode(p)                       |\n+----------------------------------+\n| (\"team204\" :team{name: \"Spurs\"}) |\n+----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#rank","title":"rank()","text":"<p>rank() returns the rank value of an edge.</p> <p>Syntax: <code>rank(&lt;edge&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN rank(e);\n+---------+\n| rank(e) |\n+---------+\n| 0       |\n| 0       |\n| 0       |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/","title":"Conditional expressions","text":"<p>This topic describes the conditional functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#case","title":"CASE","text":"<p>The <code>CASE</code> expression uses conditions to filter the parameters. nGQL provides two forms of <code>CASE</code> expressions just like openCypher: the simple form and the generic form.</p> <p>The <code>CASE</code> expression will traverse all the conditions. When the first condition is met, the <code>CASE</code> expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the <code>ELSE</code> clause. If there is no <code>ELSE</code> clause and no conditions are met, it returns <code>NULL</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#the_simple_form_of_case_expressions","title":"The simple form of CASE expressions","text":"<ul> <li>Syntax</li> </ul> <pre><code>CASE &lt;comparer&gt;\nWHEN &lt;value&gt; THEN &lt;result&gt;\n[WHEN ...]\n[ELSE &lt;default&gt;]\nEND\n</code></pre> <p>Caution</p> <p>Always remember to end the <code>CASE</code> expression with an <code>END</code>.</p> Parameter Description <code>comparer</code> A value or a valid expression that outputs a value. This value is used to compare with the <code>value</code>. <code>value</code> It will be compared with the <code>comparer</code>. If the <code>value</code> matches the <code>comparer</code>, then this condition is met. <code>result</code> The <code>result</code> is returned by the <code>CASE</code> expression if the <code>value</code> matches the <code>comparer</code>. <code>default</code> The <code>default</code> is returned by the <code>CASE</code> expression if no conditions are met. <ul> <li>Examples</li> </ul> <pre><code>nebula&gt; RETURN \\\n        CASE 2+3 \\\n        WHEN 4 THEN 0 \\\n        WHEN 5 THEN 1 \\\n        ELSE -1 \\\n        END \\\n        AS result;\n+--------+\n| result |\n+--------+\n| 1      |\n+--------+\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Name, \\\n        CASE properties($$).age &gt; 35 \\\n        WHEN true THEN \"Yes\" \\\n        WHEN false THEN \"No\" \\\n        ELSE \"Nah\" \\\n        END \\\n        AS Age_above_35;\n+-----------------+--------------+\n| Name            | Age_above_35 |\n+-----------------+--------------+\n| \"Tony Parker\"   | \"Yes\"        |\n| \"Manu Ginobili\" | \"Yes\"        |\n+-----------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#the_generic_form_of_case_expressions","title":"The generic form of CASE expressions","text":"<ul> <li>Syntax</li> </ul> <pre><code>CASE\nWHEN &lt;condition&gt; THEN &lt;result&gt;\n[WHEN ...]\n[ELSE &lt;default&gt;]\nEND\n</code></pre> Parameter Description <code>condition</code> If the <code>condition</code> is evaluated as true, the <code>result</code> is returned by the <code>CASE</code> expression. <code>result</code> The <code>result</code> is returned by the <code>CASE</code> expression if the <code>condition</code> is evaluated as true. <code>default</code> The <code>default</code> is returned by the <code>CASE</code> expression if no conditions are met. <ul> <li>Examples</li> </ul> <pre><code>nebula&gt; YIELD \\\n        CASE WHEN 4 &gt; 5 THEN 0 \\\n        WHEN 3+4==7 THEN 1 \\\n        ELSE 2 \\\n        END \\\n        AS result;\n+--------+\n| result |\n+--------+\n| 1      |\n+--------+\n</code></pre> <pre><code>nebula&gt; MATCH (v:player) WHERE v.player.age &gt; 30 \\\n        RETURN v.player.name AS Name,  \\\n        CASE \\\n        WHEN v.player.name STARTS WITH \"T\" THEN \"Yes\" \\\n        ELSE \"No\" \\\n        END \\\n        AS Starts_with_T;\n+---------------------+---------------+\n| Name                | Starts_with_T |\n+---------------------+---------------+\n| \"Tim Duncan\"        | \"Yes\"         |\n| \"LaMarcus Aldridge\" | \"No\"          |\n| \"Tony Parker\"       | \"Yes\"         |\n+---------------------+---------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#differences_between_the_simple_form_and_the_generic_form","title":"Differences between the simple form and the generic form","text":"<p>To avoid the misuse of the simple form and the generic form, it is important to understand their differences. The following example can help explain them.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Name, properties($$).age AS Age, \\\n        CASE properties($$).age \\\n        WHEN properties($$).age &gt; 35 THEN \"Yes\" \\\n        ELSE \"No\" \\\n        END \\\n        AS Age_above_35;\n+-----------------+-----+--------------+\n| Name            | Age | Age_above_35 |\n+-----------------+-----+--------------+\n| \"Tony Parker\"   | 36  | \"No\"         |\n| \"Manu Ginobili\" | 41  | \"No\"         |\n+-----------------+-----+--------------+\n</code></pre> <p>The preceding <code>GO</code> query is intended to output <code>Yes</code> when the player's age is above 35. However, in this example, when the player's age is 36, the actual output is not as expected: It is <code>No</code> instead of <code>Yes</code>.</p> <p>This is because the query uses the <code>CASE</code> expression in the simple form, and a comparison between the values of <code>$$.player.age</code> and <code>$$.player.age &gt; 35</code> is made. When the player age is 36:</p> <ul> <li>The value of <code>$$.player.age</code> is <code>36</code>. It is an integer.</li> </ul> <ul> <li><code>$$.player.age &gt; 35</code> is evaluated to be <code>true</code>. It is a boolean.</li> </ul> <p>The values of <code>$$.player.age</code> and <code>$$.player.age &gt; 35</code> do not match. Therefore, the condition is not met and <code>No</code> is returned.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#coalesce","title":"coalesce()","text":"<p>coalesce() returns the first not null value in all expressions.</p> <p>Syntax: <code>coalesce(&lt;expression_1&gt;[,&lt;expression_2&gt;...])</code></p> <ul> <li>Result type: Same as the original element.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN coalesce(null,[1,2,3]) as result;\n+-----------+\n| result    |\n+-----------+\n| [1, 2, 3] |\n+-----------+\nnebula&gt; RETURN coalesce(null) as result;\n+----------+\n| result   |\n+----------+\n| __NULL__ |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/","title":"List functions","text":"<p>This topic describes the list functions supported by NebulaGraph. Some of the functions have different syntax in native nGQL statements and openCypher-compatible statements.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#precautions","title":"Precautions","text":"<p>Like SQL, the position index in nGQL starts from <code>1</code>, while in the C language it starts from <code>0</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#general","title":"General","text":""},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#range","title":"range()","text":"<p>range() returns the list containing all the fixed-length steps in <code>[start,end]</code>.</p> <p>Syntax: <code>range(start, end [, step])</code></p> <ul> <li><code>step</code>: Optional parameters. <code>step</code> is 1 by default.</li> </ul> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN range(1,9,2);\n+-----------------+\n| range(1,9,2)    |\n+-----------------+\n| [1, 3, 5, 7, 9] |\n+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#reverse","title":"reverse()","text":"<p>reverse() returns the list reversing the order of all elements in the original list.</p> <p>Syntax: <code>reverse(&lt;list&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN reverse(ids);\n+-----------------------------------+\n| reverse(ids)                      |\n+-----------------------------------+\n| [487, 521, \"abc\", 4923, __NULL__] |\n+-----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#tail","title":"tail()","text":"<p>tail() returns all the elements of the original list, excluding the first one.</p> <p>Syntax: <code>tail(&lt;list&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN tail(ids);\n+-------------------------+\n| tail(ids)               |\n+-------------------------+\n| [4923, \"abc\", 521, 487] |\n+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#head","title":"head()","text":"<p>head() returns the first element of a list.</p> <p>Syntax: <code>head(&lt;list&gt;)</code></p> <ul> <li>Result type: Same as the element in the original list.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN head(ids);\n+-----------+\n| head(ids) |\n+-----------+\n| __NULL__  |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#last","title":"last()","text":"<p>last() returns the last element of a list.</p> <p>Syntax: <code>last(&lt;list&gt;)</code></p> <ul> <li>Result type: Same as the element in the original list.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN last(ids);\n+-----------+\n| last(ids) |\n+-----------+\n| 487       |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#reduce","title":"reduce()","text":"<p>reduce() applies an expression to each element in a list one by one, chains the result to the next iteration by taking it as the initial value, and returns the final result. This function iterates each element <code>e</code> in the given list, runs the expression on <code>e</code>, accumulates the result with the initial value, and store the new result in the accumulator as the initial value of the next iteration. It works like the fold or reduce method in functional languages such as Lisp and Scala.</p> <p>openCypher compatibility</p> <p>In openCypher, the <code>reduce()</code> function is not defined. nGQL will implement the <code>reduce()</code> function in the Cypher way.</p> <p>Syntax: <code>reduce(&lt;accumulator&gt; = &lt;initial&gt;, &lt;variable&gt; IN &lt;list&gt; | &lt;expression&gt;)</code></p> <ul> <li><code>accumulator</code>: A variable that will hold the accumulated results as the list is iterated.</li> </ul> <ul> <li><code>initial</code>: An expression that runs once to give an initial value to the <code>accumulator</code>.</li> </ul> <ul> <li><code>variable</code>: A variable in the list that will be applied to the expression successively.</li> </ul> <ul> <li><code>list</code>: A list or a list of expressions.</li> </ul> <ul> <li><code>expression</code>: This expression will be run on each element in the list once and store the result value in the <code>accumulator</code>.</li> </ul> <ul> <li>Result type: Depends on the parameters provided, along with the semantics of the expression.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN reduce(totalNum = -4 * 5, n IN [1, 2] | totalNum + n * 2) AS r;\n+-----+\n| r   |\n+-----+\n| -14 |\n+-----+\n\nnebula&gt; MATCH p = (n:player{name:\"LeBron James\"})&lt;-[:follow]-(m) \\\n        RETURN  nodes(p)[0].player.age AS src1,  nodes(p)[1].player.age AS dst2,  \\\n        reduce(totalAge = 100, n IN nodes(p) | totalAge + n.player.age) AS sum;\n+------+------+-----+\n| src1 | dst2 | sum |\n+------+------+-----+\n| 34   | 31   | 165 |\n| 34   | 29   | 163 |\n| 34   | 33   | 167 |\n| 34   | 26   | 160 |\n| 34   | 34   | 168 |\n| 34   | 37   | 171 |\n+------+------+-----+\n\nnebula&gt; LOOKUP ON player WHERE player.name == \"Tony Parker\" YIELD id(vertex) AS VertexID \\\n        |  GO FROM $-.VertexID over follow \\\n        WHERE properties(edge).degree != reduce(totalNum = 5, n IN range(1, 3) | properties($$).age + totalNum + n) \\\n        YIELD properties($$).name AS id, properties($$).age AS age, properties(edge).degree AS degree;\n+---------------------+-----+--------+\n| id                  | age | degree |\n+---------------------+-----+--------+\n| \"Tim Duncan\"        | 42  | 95     |\n| \"LaMarcus Aldridge\" | 33  | 90     |\n| \"Manu Ginobili\"     | 41  | 95     |\n+---------------------+-----+--------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#for_ngql_statements","title":"For nGQL statements","text":""},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#keys","title":"keys()","text":"<p>keys() returns a list containing the string representations for all the property names of vertices or edges.</p> <p>Syntax: <code>keys({vertex | edge})</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player \\\n        WHERE player.age  &gt; 45 \\\n        YIELD keys(vertex);\n+-----------------+\n| keys(VERTEX)    |\n+-----------------+\n| [\"age\", \"name\"] |\n| [\"age\", \"name\"] |\n+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#labels","title":"labels()","text":"<p>labels() returns the list containing all the tags of a vertex.</p> <p>Syntax: <code>labels(verte)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; FETCH PROP ON * \"player101\", \"player102\", \"team204\" \\\n        YIELD labels(vertex);\n+----------------+\n| labels(VERTEX) |\n+----------------+\n| [\"player\"]     |\n| [\"player\"]     |\n| [\"team\"]       |\n+----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#for_statements_compatible_with_opencypher","title":"For statements compatible with openCypher","text":""},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#keys_1","title":"keys()","text":"<p>keys() returns a list containing the string representations for all the property names of vertices, edges, or maps.</p> <p>Syntax: <code>keys(&lt;vertex_or_edge&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN keys(e);\n+----------------------------+\n| keys(e)                    |\n+----------------------------+\n| [\"end_year\", \"start_year\"] |\n| [\"degree\"]                 |\n| [\"degree\"]                 |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#labels_1","title":"labels()","text":"<p>labels() returns the list containing all the tags of a vertex.</p> <p>Syntax: <code>labels(&lt;vertex&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v)-[e:serve]-&gt;() \\\n        WHERE id(v)==\"player100\" \\\n        RETURN labels(v);\n+------------+\n| labels(v)  |\n+------------+\n| [\"player\"] |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#nodes","title":"nodes()","text":"<p>nodes() returns the list containing all the vertices in a path.</p> <p>Syntax: <code>nodes(&lt;path&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) \\\n        RETURN nodes(p);\n+-------------------------------------------------------------------------------------------------------------+\n| nodes(p)                                                                                                    |\n+-------------------------------------------------------------------------------------------------------------+\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"team204\" :team{name: \"Spurs\"})]                      |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player101\" :player{age: 36, name: \"Tony Parker\"})]   |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})] |\n+-------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#relationships","title":"relationships()","text":"<p>relationships() returns the list containing all the relationships in a path.</p> <p>Syntax: <code>relationships(&lt;path&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) \\\n        RETURN relationships(p);\n+-------------------------------------------------------------------------+\n| relationships(p)                                                        |\n+-------------------------------------------------------------------------+\n| [[:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}]] |\n| [[:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]]                    |\n| [[:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]]                    |\n+-------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/8.predicate/","title":"Predicate functions","text":"<p>Predicate functions return <code>true</code> or <code>false</code>. They are most commonly used in <code>WHERE</code> clauses.</p> <p>NebulaGraph supports the following predicate functions:</p> Functions Description exists() Returns <code>true</code> if the specified property exists in the vertex, edge or map. Otherwise, returns <code>false</code>. any() Returns <code>true</code> if the specified predicate holds for at least one element in the given list. Otherwise, returns <code>false</code>. all() Returns <code>true</code> if the specified predicate holds for all elements in the given list. Otherwise, returns <code>false</code>. none() Returns <code>true</code> if the specified predicate holds for no element in the given list. Otherwise, returns <code>false</code>. single() Returns <code>true</code> if the specified predicate holds for exactly one of the elements in the given list. Otherwise, returns <code>false</code>. <p>Note</p> <p>NULL is returned if the list is NULL or all of its elements are NULL.</p> <p>Compatibility</p> <p>In openCypher, only function <code>exists()</code> is defined and specified. The other functions are implement-dependent.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/8.predicate/#syntax","title":"Syntax","text":"<pre><code>&lt;predicate&gt;(&lt;variable&gt; IN &lt;list&gt; WHERE &lt;condition&gt;)\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/8.predicate/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN any(n IN [1, 2, 3, 4, 5, NULL] \\\n        WHERE n &gt; 2) AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; RETURN single(n IN range(1, 5) \\\n        WHERE n == 3) AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; RETURN none(n IN range(1, 3) \\\n        WHERE n == 0) AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; WITH [1, 2, 3, 4, 5, NULL] AS a \\\n        RETURN any(n IN a WHERE n &gt; 2);\n+-------------------------+\n| any(n IN a WHERE (n&gt;2)) |\n+-------------------------+\n| true                    |\n+-------------------------+\n\nnebula&gt; MATCH p = (n:player{name:\"LeBron James\"})&lt;-[:follow]-(m) \\\n        RETURN nodes(p)[0].player.name AS n1, nodes(p)[1].player.name AS n2, \\\n        all(n IN nodes(p) WHERE n.player.name NOT STARTS WITH \"D\") AS b;\n+----------------+-------------------+-------+\n| n1             | n2                | b     |\n+----------------+-------------------+-------+\n| \"LeBron James\" | \"Danny Green\"     | false |\n| \"LeBron James\" | \"Dejounte Murray\" | false |\n| \"LeBron James\" | \"Chris Paul\"      | true  |\n| \"LeBron James\" | \"Kyrie Irving\"    | true  |\n| \"LeBron James\" | \"Carmelo Anthony\" | true  |\n| \"LeBron James\" | \"Dwyane Wade\"     | false |\n+----------------+-------------------+-------+\n\nnebula&gt; MATCH p = (n:player{name:\"LeBron James\"})-[:follow]-&gt;(m) \\\n        RETURN single(n IN nodes(p) WHERE n.player.age &gt; 40) AS b;\n+------+\n| b    |\n+------+\n| true |\n+------+\n\nnebula&gt; MATCH (n:player) \\\n        RETURN exists(n.player.id), n IS NOT NULL;\n+---------------------+---------------+\n| exists(n.player.id) | n IS NOT NULL |\n+---------------------+---------------+\n| false               | true          |\n...\n\nnebula&gt; MATCH (n:player) \\\n        WHERE exists(n['name']) RETURN n;\n+-------------------------------------------------------------------------------------------------------------+\n| n                                                                                                           |\n+-------------------------------------------------------------------------------------------------------------+\n| (\"Grant Hill\" :player{age: 46, name: \"Grant Hill\"})                                                         |\n| (\"Marc Gasol\" :player{age: 34, name: \"Marc Gasol\"})                                                         |\n+-------------------------------------------------------------------------------------------------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/9.user-defined-functions/","title":"User-defined functions","text":""},{"location":"3.ngql-guide/6.functions-and-expressions/9.user-defined-functions/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>User-defined functions (UDF) and storage processes are not yet supported nor designed in NebulaGraph 2.0.0.</p>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/","title":"MATCH","text":"<p>The <code>MATCH</code> statement provides pattern-based search functionality, allowing you to retrieve data that matches one or more patterns in NebulaGraph. By defining one or more patterns, you can search for data that matches the patterns in NebulaGraph. Once the matching data is retrieved, you can use the <code>RETURN</code> clause to return it as a result.</p> <p>The examples in this topic use the basketballplayer dataset as the sample dataset.</p>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#syntax","title":"Syntax","text":"<p>The syntax of <code>MATCH</code> is relatively more flexible compared with that of other query statements such as <code>GO</code> or <code>LOOKUP</code>. The path type of the <code>MATCH</code> statement is <code>trail</code>. That is, only vertices can be repeatedly visited in the graph traversal. Edges cannot be repeatedly visited. For details, see path. But generally, it can be summarized as follows.</p> <pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> <ul> <li><code>pattern</code>: The <code>MATCH</code> statement supports matching one or multiple patterns. Multiple patterns are separated by commas (,). For example: <code>(a)-[]-&gt;(b),(c)-[]-&gt;(d)</code>. For the detailed description of patterns, see Patterns. </li> </ul> <ul> <li><code>clause_1</code>: The <code>WHERE</code>, <code>WITH</code>, <code>UNWIND</code>, and <code>OPTIONAL MATCH</code> clauses are supported, and the <code>MATCH</code> clause can also be used.</li> </ul> <ul> <li><code>output</code>: Define the list name for the output results to be returned. You can use <code>AS</code> to set an alias for the list.</li> </ul> <ul> <li><code>clause_2</code>: The <code>ORDER BY</code> and <code>LIMIT</code> clauses are supported.</li> </ul> <p>Legacy version compatibility</p> <ul> <li>Starting from version 3.5.0, the <code>MATCH</code> statement supports full table scans. It can traverse vertices or edges in the graph without using any indexes or filter conditions. In previous versions, the <code>MATCH</code> statement required an index for certain queries or needed to use <code>LIMIT</code> to restrict the number of output results.</li> </ul> <ul> <li>Starting from NebulaGraph version 3.0.0, in order to distinguish the properties of different tags, you need to specify a tag name when querying properties. The original statement <code>RETURN &lt;variable_name&gt;.&lt;property_name&gt;</code> is changed to <code>RETURN &lt;variable_name&gt;.&lt;tag_name&gt;.&lt;property_name&gt;</code>.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#notes","title":"Notes","text":"<ul> <li>Avoid full table scans, as they may result in decreased query performance, and if there is insufficient memory during a full table scan, the query may fail, and the system will report an error. It is recommended to use queries with filter conditions or specifying tags and edge types, such as <code>v:player</code> and <code>v.player.name</code> in the statement <code>MATCH (v:player) RETURN v.player.name AS Name</code>.</li> </ul> <ul> <li>You can create an index for a tag, edge type, or a specific property of a tag or edge type to improve query performance. For example, you can create an index for the <code>player</code> tag or the name property of the <code>player</code> tag. For more information about the usage and considerations for indexes, see Must-read for using indexes.</li> </ul> <ul> <li>The <code>MATCH</code> statement cannot query dangling edges.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#using_patterns_in_match_statements","title":"Using patterns in MATCH statements","text":""},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_vertices","title":"Match vertices","text":"<p>You can use a user-defined variable in a pair of parentheses to represent a vertex in a pattern. For example: <code>(v)</code>.</p> <pre><code>nebula&gt; MATCH (v) \\\n        RETURN v \\\n        LIMIT 3;\n+-----------------------------------------------------------+\n| v                                                         |\n+-----------------------------------------------------------+\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n| (\"player106\" :player{age: 25, name: \"Kyle Anderson\"})     |\n| (\"player115\" :player{age: 40, name: \"Kobe Bryant\"})       |\n+-----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_tags","title":"Match tags","text":"<p>Legacy version compatibility</p> <ul> <li>In NebulaGraph versions earlier than 3.0.0, the prerequisite for matching a tag is that the tag itself has an index or a certain property of the tag has an index. </li> </ul> <ul> <li>Starting from NebulaGraph 3.0.0, you can match tags without creating an index, but you need to use <code>LIMIT</code> to restrict the number of output results.</li> </ul> <ul> <li>Starting from NebulaGraph 3.5.0, the <code>MATCH</code> statement supports full table scans. There is no need to create an index for a tag or a specific property of a tag, nor use <code>LIMIT</code> to restrict the number of output results in order to execute the <code>MATCH</code> statement.</li> </ul> <p>You can specify a tag with <code>:&lt;tag_name&gt;</code> after the vertex in a pattern.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        RETURN v;\n+---------------------------------------------------------------+\n| v                                                             |\n+---------------------------------------------------------------+\n| (\"player105\" :player{age: 31, name: \"Danny Green\"})           |\n| (\"player109\" :player{age: 34, name: \"Tiago Splitter\"})        |\n| (\"player111\" :player{age: 38, name: \"David West\"})            |\n...\n</code></pre> <p>To match vertices with multiple tags, use colons (:).</p> <pre><code>nebula&gt; CREATE TAG actor (name string, age int);\nnebula&gt; INSERT VERTEX actor(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\nnebula&gt; MATCH (v:player:actor) \\\n        RETURN v \\\n+----------------------------------------------------------------------------------------+\n| v                                                                                      |\n+----------------------------------------------------------------------------------------+\n| (\"player100\" :actor{age: 42, name: \"Tim Duncan\"} :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_vertex_properties","title":"Match vertex properties","text":"<p>Note</p> <p>The prerequisite for matching a vertex property is that the tag itself has an index of the corresponding property. Otherwise, you cannot execute the <code>MATCH</code> statement to match the property.</p> <p>You can specify a vertex property with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> after the tag in a pattern.</p> <pre><code># The following example uses the name property to match a vertex.\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre> <p>The <code>WHERE</code> clause can do the same thing:</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name == \"Tim Duncan\" \\\n        RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre> <p>OpenCypher compatibility</p> <p>In openCypher 9, <code>=</code> is the equality operator. However, in nGQL, <code>==</code> is the equality operator and <code>=</code> is the assignment operator (as in C++ or Java).</p> <p>Use the <code>WHERE</code> clause to directly get all the vertices with the vertex property value Tim Duncan.</p> <pre><code>nebula&gt; MATCH (v) \\\n        WITH v, properties(v) as props, keys(properties(v)) as kk \\\n        WHERE [i in kk where props[i] == \"Tim Duncan\"] \\\n        RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n\nnebula&gt; WITH ['Tim Duncan', 'Yao Ming'] AS names \\\n        MATCH (v1:player)--&gt;(v2:player) \\\n        WHERE v1.player.name in names \\\n        return v1, v2;\n+----------------------------------------------------+----------------------------------------------------------+\n| v1                                                 | v2                                                       |\n+----------------------------------------------------+----------------------------------------------------------+\n| (\"player133\" :player{age: 38, name: \"Yao Ming\"})   | (\"player114\" :player{age: 39, name: \"Tracy McGrady\"})    |\n| (\"player133\" :player{age: 38, name: \"Yao Ming\"})   | (\"player144\" :player{age: 47, name: \"Shaquille O'Neal\"}) |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"player101\" :player{age: 36, name: \"Tony Parker\"})      |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})    |\n+----------------------------------------------------+----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_vids","title":"Match VIDs","text":"<p>You can use the VID to match a vertex. The <code>id()</code> function can retrieve the VID of a vertex.</p> <pre><code>nebula&gt; MATCH (v) \\\n        WHERE id(v) == 'player101' \\\n        RETURN v;\n+-----------------------------------------------------+\n| v                                                   |\n+-----------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"}) |\n+-----------------------------------------------------+\n</code></pre> <p>To match multiple VIDs, use <code>WHERE id(v) IN [vid_list]</code> or <code>WHERE id(v) IN {vid_list}</code>.</p> <pre><code>nebula&gt; MATCH (v:player { name: 'Tim Duncan' })--(v2) \\\n        WHERE id(v2) IN [\"player101\", \"player102\"] \\\n        RETURN v2;\n+-----------------------------------------------------------+\n| v2                                                        |\n+-----------------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n+-----------------------------------------------------------+\n\nnebula&gt; MATCH (v) WHERE id(v) IN {\"player100\", \"player101\"} \\\n        RETURN v.player.name AS name;\n+---------------+\n| name          |\n+---------------+\n| \"Tony Parker\" |\n| \"Tim Duncan\"  |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_connected_vertices","title":"Match connected vertices","text":"<p>You can use the <code>--</code> symbol to represent edges of both directions and match vertices connected by these edges.</p> <p>Legacy version compatibility</p> <p>In nGQL 1.x, the <code>--</code> symbol is used for inline comments. Starting from nGQL 2.x, the <code>--</code> symbol represents an incoming or outgoing edge.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--(v2) \\\n        RETURN v2.player.name AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Manu Ginobili\"     |\n| \"Manu Ginobili\"     |\n| \"Tiago Splitter\"    |\n...\n</code></pre> <p>You can add a <code>&gt;</code> or <code>&lt;</code> to the <code>--</code> symbol to specify the direction of an edge.</p> <p>In the following example, <code>--&gt;</code> represents an edge that starts from <code>v</code> and points to <code>v2</code>. To <code>v</code>, this is an outgoing edge, and to <code>v2</code> this is an incoming edge.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--&gt;(v2:player) \\\n        RETURN v2.player.name AS Name;\n+-----------------+\n| Name            |\n+-----------------+\n| \"Manu Ginobili\" |\n| \"Tony Parker\"   |\n+-----------------+\n</code></pre> <p>To query the properties of the target vertices, use the <code>CASE</code> expression.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--(v2) \\\n        RETURN \\\n        CASE WHEN v2.team.name IS NOT NULL \\\n        THEN v2.team.name  \\\n        WHEN v2.player.name IS NOT NULL \\\n        THEN v2.player.name END AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Manu Ginobili\"     |\n| \"Manu Ginobili\"     |\n| \"Spurs\"             |\n| \"Dejounte Murray\"   |\n...\n</code></pre> <p>To extend the pattern, you can add more vertices and edges.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--&gt;(v2)&lt;--(v3) \\\n        RETURN v3.player.name AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Dejounte Murray\"   |\n| \"LaMarcus Aldridge\" |\n| \"Marco Belinelli\"   |\n...\n</code></pre> <p>If you do not need to refer to a vertex, you can omit the variable representing it in the parentheses.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--&gt;()&lt;--(v3) \\\n        RETURN v3.player.name AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Dejounte Murray\"   |\n| \"LaMarcus Aldridge\" |\n| \"Marco Belinelli\"   |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_paths","title":"Match paths","text":"<p>Connected vertices and edges form a path. You can use a user-defined variable to name a path as follows.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) \\\n        RETURN p;\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                    |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt; |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;   |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt; |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <p>OpenCypher compatibility</p> <p>In nGQL, the <code>@</code> symbol represents the rank of an edge, but openCypher has no such concept.</p>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_edges","title":"Match edges","text":"<pre><code>nebula&gt; MATCH ()&lt;-[e]-() \\\n        RETURN e \\\n        LIMIT 3;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player101\"-&gt;\"player102\" @0 {degree: 90}] |\n| [:follow \"player103\"-&gt;\"player102\" @0 {degree: 70}] |\n| [:follow \"player135\"-&gt;\"player102\" @0 {degree: 80}] |\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_edge_types","title":"Match edge types","text":"<p>Just like vertices, you can specify edge types with <code>:&lt;edge_type&gt;</code> in a pattern. For example: <code>-[e:follow]-</code>.</p> <p>OpenCypher compatibility</p> <ul> <li>In NebulaGraph versions earlier than 3.0.0, the prerequisite for matching a edge type is that the edge type itself has an index or a certain property of the edge type has an index. </li> </ul> <ul> <li>Starting from version 3.0.0, there is no need to create an index for matching a edge type, but you need to use <code>LIMIT</code> to limit the number of output results and you must specify the direction of the edge.</li> </ul> <ul> <li>Starting from NebulaGraph 3.5.0, you can use the <code>MATCH</code> statement to match edges without creating an index for edge type or using <code>LIMIT</code> to restrict the number of output results.</li> </ul> <pre><code>nebula&gt; MATCH ()-[e:follow]-&gt;() \\\n        RETURN e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player102\"-&gt;\"player100\" @0 {degree: 75}] |\n| [:follow \"player102\"-&gt;\"player101\" @0 {degree: 75}] |\n| [:follow \"player129\"-&gt;\"player116\" @0 {degree: 90}] |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_edge_type_properties","title":"Match edge type properties","text":"<p>Note</p> <p>The prerequisite for matching an edge type property is that the edge type itself has an index of the corresponding property. Otherwise, you cannot execute the <code>MATCH</code> statement to match the property.</p> <p>You can specify edge type properties with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> in a pattern. For example: <code>[e:follow{likeness:95}]</code>.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e:follow{degree:95}]-&gt;(v2) \\\n        RETURN e;\n+--------------------------------------------------------+\n| e                                                      |\n+--------------------------------------------------------+\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]     |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]     |\n+--------------------------------------------------------+\n</code></pre> <p>Use the <code>WHERE</code> clause to directly get all the edges with the edge property value 90.</p> <pre><code>nebula&gt; MATCH ()-[e]-&gt;() \\\n        WITH e, properties(e) as props, keys(properties(e)) as kk \\\n        WHERE [i in kk where props[i] == 90] \\\n        RETURN e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player125\"-&gt;\"player100\" @0 {degree: 90}] |\n| [:follow \"player140\"-&gt;\"player114\" @0 {degree: 90}] |\n| [:follow \"player133\"-&gt;\"player144\" @0 {degree: 90}] |\n| [:follow \"player133\"-&gt;\"player114\" @0 {degree: 90}] |\n...\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_multiple_edge_types","title":"Match multiple edge types","text":"<p>The <code>|</code> symbol can help matching multiple edge types. For example: <code>[e:follow|:serve]</code>. The English colon (:) before the first edge type cannot be omitted, but the English colon before the subsequent edge type can be omitted, such as <code>[e:follow|serve]</code>.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e:follow|:serve]-&gt;(v2) \\\n        RETURN e;\n+---------------------------------------------------------------------------+\n| e                                                                         |\n+---------------------------------------------------------------------------+\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]                        |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]                        |\n| [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}]     |\n+---------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_multiple_edges","title":"Match multiple edges","text":"<p>You can extend a pattern to match multiple edges in a path.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[]-&gt;(v2)&lt;-[e:serve]-(v3) \\\n        RETURN v2, v3;\n+----------------------------------+-----------------------------------------------------------+\n| v2                               | v3                                                        |\n+----------------------------------+-----------------------------------------------------------+\n| (\"team204\" :team{name: \"Spurs\"}) | (\"player104\" :player{age: 32, name: \"Marco Belinelli\"})   |\n| (\"team204\" :team{name: \"Spurs\"}) | (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"team204\" :team{name: \"Spurs\"}) | (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_fixed-length_paths","title":"Match fixed-length paths","text":"<p>You can use the <code>:&lt;edge_type&gt;*&lt;hop&gt;</code> pattern to match a fixed-length path. <code>hop</code> must be a non-negative integer.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        RETURN DISTINCT v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n+-----------------------------------------------------------+\n</code></pre> <p>If <code>hop</code> is 0, the pattern will match the source vertex of the path.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) -[*0]-&gt; (v2) \\\n        RETURN v2;\n+----------------------------------------------------+\n| v2                                                 |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre> <p>Note</p> <p>When you conditionally filter on multi-hop edges, such as <code>-[e:follow*2]-&gt;</code>, note that the <code>e</code> is a list of edges instead of a single edge. </p> <p>For example, the following statement is correct from the syntax point of view which may not get your expected query result, because the <code>e</code> is a list without the <code>.degree</code> property. </p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        WHERE e.degree &gt; 1 \\\n        RETURN DISTINCT v2 AS Friends;\n</code></pre> <p>The correct statement is as follows:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        WHERE ALL(e_ in e WHERE e_.degree &gt; 0) \\\n        RETURN DISTINCT v2 AS Friends;\n</code></pre> <p>Further, the following statement is for filtering the properties of the first-hop edge in multi-hop edges:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        WHERE e[0].degree &gt; 98 \\\n        RETURN DISTINCT v2 AS Friends;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_variable-length_paths","title":"Match variable-length paths","text":"<p>You can use the <code>:&lt;edge_type&gt;*[minHop..maxHop]</code> pattern to match variable-length paths.<code>minHop</code> and <code>maxHop</code> are optional and default to 1 and infinity respectively.</p> <p>Note</p> <p>When setting bounds, at least one of <code>minHop</code> and <code>maxHop</code> exists.</p> <p>Caution</p> <p>If <code>maxHop</code> is not set, it may cause the Graph service to OOM, execute this command with caution.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*]-&gt;(v2) \\\n        RETURN v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n...\n\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]-&gt;(v2) \\\n        RETURN v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n...\n\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..]-&gt;(v2) \\\n        RETURN v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n...\n</code></pre> <p>You can use the <code>DISTINCT</code> keyword to aggregate duplicate results.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]-&gt;(v2:player) \\\n        RETURN DISTINCT v2 AS Friends, count(v2);\n+-----------------------------------------------------------+-----------+\n| Friends                                                   | count(v2) |\n+-----------------------------------------------------------+-----------+\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) | 1         |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        | 4         |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       | 3         |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     | 3         |\n+-----------------------------------------------------------+-----------+\n</code></pre> <p>If <code>minHop</code> is <code>0</code>, the pattern will match the source vertex of the path. Compared to the preceding statement, the following example uses <code>0</code> as the <code>minHop</code>. So in the following result set, <code>\"Tim Duncan\"</code> is counted one more time than it is in the preceding result set because it is the source vertex.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*0..3]-&gt;(v2:player) \\\n        RETURN DISTINCT v2 AS Friends, count(v2);\n+-----------------------------------------------------------+-----------+\n| Friends                                                   | count(v2) |\n+-----------------------------------------------------------+-----------+\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) | 1         |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        | 5         |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     | 3         |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       | 3         |\n+-----------------------------------------------------------+-----------+\n</code></pre> <p>Note</p> <p>When using the variable <code>e</code> to match fixed-length or variable-length paths in a pattern, such as <code>-[e:follow*0..3]-&gt;</code>, it is not supported to reference <code>e</code> in other patterns. For example, the following statement is not supported.</p> <pre><code>nebula&gt; MATCH (v:player)-[e:like*1..3]-&gt;(n) \\\n        WHERE (n)-[e*1..4]-&gt;(:player) \\\n        RETURN v;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_variable-length_paths_with_multiple_edge_types","title":"Match variable-length paths with multiple edge types","text":"<p>You can specify multiple edge types in a fixed-length or variable-length pattern. In this case, <code>hop</code>, <code>minHop</code>, and <code>maxHop</code> take effect on all edge types.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow|serve*2]-&gt;(v2) \\\n        RETURN DISTINCT v2;\n+-----------------------------------------------------------+\n| v2                                                        |\n+-----------------------------------------------------------+\n| (\"team204\" :team{name: \"Spurs\"})                          |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n| (\"team215\" :team{name: \"Hornets\"})                        |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n+-----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_multiple_patterns","title":"Match multiple patterns","text":"<p>You can separate multiple patterns with commas (,).</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS team_index ON team(name(20));\nnebula&gt; REBUILD TAG INDEX team_index;\nnebula&gt; MATCH (v1:player{name:\"Tim Duncan\"}), (v2:team{name:\"Spurs\"}) \\\n        RETURN v1,v2;\n+----------------------------------------------------+----------------------------------+\n| v1                                                 | v2                               |\n+----------------------------------------------------+----------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"team204\" :team{name: \"Spurs\"}) |\n+----------------------------------------------------+----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_shortest_paths","title":"Match shortest paths","text":"<p>The <code>allShortestPaths</code> function can be used to find all shortest paths between two vertices.</p> <pre><code>nebula&gt; MATCH p = allShortestPaths((a:player{name:\"Tim Duncan\"})-[e*..5]-(b:player{name:\"Tony Parker\"})) \\\n        RETURN p;\n+------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                  |\n+------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&lt;-[:follow@0 {degree: 95}]-(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt; |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt; |\n+------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <p>The <code>shortestPath</code> function can be used to find a single shortest path between two vertices.</p> <pre><code>nebula&gt; MATCH p = shortestPath((a:player{name:\"Tim Duncan\"})-[e*..5]-(b:player{name:\"Tony Parker\"})) \\\n        RETURN p;\n+------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                  |\n+------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&lt;-[:follow@0 {degree: 95}]-(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt; |\n+------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#retrieve_with_multiple_match","title":"Retrieve with multiple match","text":"<p>Multiple <code>MATCH</code> can be used when different patterns have different filtering criteria and return the rows that exactly match the pattern.</p> <pre><code>nebula&gt; MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" \\\n        MATCH (n)-[]-&gt;(l) WHERE id(n)==\"player125\" \\\n        RETURN id(m),id(n),id(l);\n+-------------+-------------+-------------+\n| id(m)       | id(n)       | id(l)       |\n+-------------+-------------+-------------+\n| \"player100\" | \"player125\" | \"team204\"   |\n| \"player100\" | \"player125\" | \"player100\" |\n+-------------+-------------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#retrieve_with_optional_match","title":"Retrieve with optional match","text":"<p>See OPTIONAL MATCH.</p> <p>Performance</p> <p>In NebulaGraph, the performance and resource usage of the <code>MATCH</code> statement have been optimized. But we still recommend to use <code>GO</code>, <code>LOOKUP</code>, <code>|</code>, and <code>FETCH</code> instead of <code>MATCH</code> when high performance is required.</p>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/","title":"GO","text":"<p>The <code>GO</code> statement is used in the NebulaGraph database to traverse the graph starting from a given starting vertex with specified filters and return results.</p>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#syntax","title":"Syntax","text":"<pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS}] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt;\u00a0]\nYIELD\u00a0[DISTINCT] &lt;return_list&gt;\n[{SAMPLE &lt;sample_list&gt; | &lt;limit_by_list_clause&gt;}]\n[| GROUP BY {col_name | expr | position} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;];\n\n&lt;vertex_list&gt; ::=\n    &lt;vid&gt; [, &lt;vid&gt; ...]\n\n&lt;edge_type_list&gt; ::=\n   edge_type [, edge_type ...]\n   | *\n\n&lt;return_list&gt; ::=\n    &lt;col_name&gt; [AS &lt;col_alias&gt;] [, &lt;col_name&gt; [AS &lt;col_alias&gt;] ...]\n</code></pre> <ul> <li> <p><code>&lt;N&gt; {STEP|STEPS}</code>: specifies the hop number. If not specified, the default value for <code>N</code> is <code>one</code>. When <code>N</code> is <code>zero</code>, NebulaGraph does not traverse any edges and returns nothing.</p> <p>Note</p> <p>The path type of the <code>GO</code> statement is <code>walk</code>, which means both vertices and edges can be repeatedly visited in graph traversal. For more information, see Path.</p> </li> </ul> <ul> <li><code>M TO N {STEP|STEPS}</code>: traverses <code>from M to N</code> hops. When <code>M</code> is <code>zero</code>, the output is the same as that of <code>M</code> is <code>one</code>. That is, the output of <code>GO 0 TO 2</code> and <code>GO 1 TO 2</code> are the same.</li> </ul> <ul> <li><code>&lt;vertex_list&gt;</code>: represents a list of vertex IDs separated by commas.</li> </ul> <ul> <li><code>&lt;edge_type_list&gt;</code>: represents a list of edge types which the traversal can go through.</li> </ul> <ul> <li><code>REVERSELY | BIDIRECT</code>: defines the direction of the query. By default, the <code>GO</code> statement searches for outgoing edges of <code>&lt;vertex_list&gt;</code>. If <code>REVERSELY</code> is set, <code>GO</code> searches for incoming edges. If <code>BIDIRECT</code> is set, <code>GO</code> searches for edges of both directions. The direction of the query can be checked by returning the <code>&lt;edge_type&gt;._type</code> field using <code>YIELD</code>. A positive value indicates an outgoing edge, while a negative value indicates an incoming edge.</li> </ul> <ul> <li> <p><code>WHERE &lt;expression&gt;</code>: specifies the traversal filters. You can use the <code>WHERE</code> clause for the source vertices, the edges, and the destination vertices. You can use it together with <code>AND</code>, <code>OR</code>, <code>NOT</code>, and <code>XOR</code>. For more information, see WHERE.</p> <p>Note</p> <ul> <li>There are some restrictions for the <code>WHERE</code> clause when you traverse along with multiple edge types. For example, <code>WHERE edge1.prop1 &gt; edge2.prop2</code> is not supported.</li> <li>The GO statement is executed by traversing all the vertices and then filtering according to the filter condition.</li> </ul> </li> </ul> <ul> <li><code>YIELD [DISTINCT] &lt;return_list&gt;</code>: defines the output to be returned. It is recommended to use the Schema-related functions to fill in <code>&lt;return_list&gt;</code>. <code>src(edge)</code>, <code>dst(edge)</code>, <code>type(edge) )</code>, <code>rank(edge)</code>, etc., are currently supported, while nested functions are not. For more information, see YIELD.</li> </ul> <ul> <li><code>SAMPLE &lt;sample_list&gt;</code>: takes samples from the result set. For more information, see SAMPLE.</li> </ul> <ul> <li><code>&lt;limit_by_list_clause&gt;</code>: limits the number of outputs during the traversal process. For more information, see LIMIT.</li> </ul> <ul> <li><code>GROUP BY</code>: groups the output into subgroups based on the value of the specified property. For more information, see GROUP BY. After grouping, you need to use <code>YIELD</code> again to define the output that needs to be returned.</li> </ul> <ul> <li> <p><code>ORDER BY</code>: sorts outputs with specified orders. For more information, see ORDER BY.</p> <p>Note</p> <p>When the sorting method is not specified, the output orders can be different for the same query.</p> </li> </ul> <ul> <li><code>LIMIT  [&lt;offset&gt;,] &lt;number_rows&gt;]</code>: limits the number of rows of the output. For more information, see LIMIT.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#notes","title":"Notes","text":"<ul> <li>The <code>WHERE</code> and <code>YIELD</code> clauses in <code>GO</code> statements usually utilize property reference symbols (<code>$^</code> and <code>$$</code>) or the <code>properties($^)</code> and <code>properties($$)</code> functions to specify the properties of a vertex; use the <code>properties(edge)</code> function to specify the properties of an edge. For details, see Property Reference Symbols and Schema-related Functions.</li> </ul> <ul> <li>When referring to the result of a subquery in a compound <code>GO</code> statement, you need to set a name for the result and pass it to the next subquery using the pipe symbol <code>|</code>, and reference the name of the result in the next subquery using <code>$-</code>. See the Pipe Operator for details.</li> </ul> <ul> <li>When the queried property has no value, the returned result displays <code>NULL</code>.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#cases_and_examples","title":"Cases and examples","text":""},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_the_immediate_neighbors_of_a_vertex","title":"To query the immediate neighbors of a vertex","text":"<p>For example, to query the team that a person belongs to, assuming that the person is connected to the team by the <code>serve</code> edge and the person's ID is <code>player102</code>.</p> <pre><code>nebula&gt;\u00a0GO FROM \"player102\" OVER serve YIELD dst(edge);\n+-----------+\n| dst(EDGE) |\n+-----------+\n| \"team203\" |\n| \"team204\" |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_all_vertices_within_a_specified_number_of_hops_from_a_starting_vertex","title":"To query all vertices within a specified number of hops from a starting vertex","text":"<p>For example, to query all vertices within two hops of a person vertex, assuming that the person is connected to other people by the <code>follow</code> edge and the person's ID is <code>player102</code>.</p> <pre><code># Return all vertices that are 2 hops away from the player102 vertex.\nnebula&gt; GO 2 STEPS FROM \"player102\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n+-------------+\n</code></pre> <pre><code># Return all vertices within 1 or 2 hops away from the player102 vertex.\nnebula&gt; GO 1 TO 2 STEPS FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n...\n\n# The following MATCH query has the same semantics as the previous GO query.\nnebula&gt; MATCH (v) -[e:follow*1..2]-&gt;(v2) \\\n        WHERE id(v) == \"player100\" \\\n        RETURN id(v2) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_add_filtering_conditions","title":"To add filtering conditions","text":"<p>Case: To query the vertices and edges that meet specific conditions.</p> <p>For example, use the <code>WHERE</code> clause to query the edges with specific properties between the starting vertex and the destination vertex.</p> <pre><code>nebula&gt;\u00a0GO FROM \"player100\", \"player102\" OVER serve \\\n        WHERE properties(edge).start_year &gt; 1995 \\\n        YIELD DISTINCT properties($$).name AS team_name, properties(edge).start_year AS start_year, properties($^).name AS player_name;\n\n+-----------------+------------+---------------------+\n| team_name       | start_year | player_name         |\n+-----------------+------------+---------------------+\n| \"Spurs\"         | 1997       | \"Tim Duncan\"        |\n| \"Trail Blazers\" | 2006       | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | 2015       | \"LaMarcus Aldridge\" |\n+-----------------+------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_multiple_edge_types","title":"To query multiple edge types","text":"<p>Case: To query multiple edge types that are connected to the starting vertex. You can specify multiple edge types or the <code>*</code> symbol to query multiple edge types.</p> <p>For example, to query the <code>follow</code> and <code>serve</code> edges that are connected to the starting vertex.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow, serve \\\n        YIELD properties(edge).degree, properties(edge).start_year;\n+-------------------------+-----------------------------+\n| properties(EDGE).degree | properties(EDGE).start_year |\n+-------------------------+-----------------------------+\n| 95                      | __NULL__                    |\n| 95                      | __NULL__                    |\n| __NULL__                | 1997                        |\n+-------------------------+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_incoming_vertices_using_the_reversely_keyword","title":"To query incoming vertices using the REVERSELY keyword","text":"<pre><code># Return the vertices that follow the player100 vertex.\nnebula&gt; GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD src(edge) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player101\" |\n| \"player102\" |\n...\n\n# The following MATCH query has the same semantics as the previous GO query.\nnebula&gt; MATCH (v)&lt;-[e:follow]- (v2) WHERE id(v) == 'player100' \\\n        RETURN id(v2) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player101\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_use_subqueries_as_the_starting_vertice_of_a_graph_traversal","title":"To use subqueries as the starting vertice of a graph traversal","text":"<pre><code># Return the friends of the player100 vertex and the teams that the friends belong to.\nnebula&gt; GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD src(edge) AS id | \\\n        GO FROM $-.id OVER serve \\\n        WHERE properties($^).age &gt; 20 \\\n        YIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n+---------------------+-----------------+\n| FriendOf            | Team            |\n+---------------------+-----------------+\n| \"Boris Diaw\"        | \"Spurs\"         |\n| \"Boris Diaw\"        | \"Jazz\"          |\n| \"Boris Diaw\"        | \"Suns\"          |\n...\n\n# The following MATCH query has the same semantics as the previous GO query.\nnebula&gt; MATCH (v)&lt;-[e:follow]- (v2)-[e2:serve]-&gt;(v3)  \\\n        WHERE id(v) == 'player100' \\\n        RETURN v2.player.name AS FriendOf, v3.team.name AS Team;\n+---------------------+-----------------+\n| FriendOf            | Team            |\n+---------------------+-----------------+\n| \"Boris Diaw\"        | \"Spurs\"         |\n| \"Boris Diaw\"        | \"Jazz\"          |\n| \"Boris Diaw\"        | \"Suns\"          |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_use_group_by_to_group_the_output","title":"To use <code>GROUP BY</code> to group the output","text":"<p>You need to use <code>YIELD</code> to define the output that needs to be returned after grouping.</p> <pre><code># The following example collects the outputs according to age.\nnebula&gt; GO 2 STEPS FROM \"player100\" OVER follow \\\n        YIELD src(edge) AS src, dst(edge) AS dst, properties($$).age AS age \\\n        | GROUP BY $-.dst \\\n        YIELD $-.dst AS dst, collect_set($-.src) AS src, collect($-.age) AS age;\n+-------------+----------------------------+----------+\n| dst         | src                        | age      |\n+-------------+----------------------------+----------+\n| \"player125\" | {\"player101\"}              | [41]     |\n| \"player100\" | {\"player125\", \"player101\"} | [42, 42] |\n| \"player102\" | {\"player101\"}              | [33]     |\n+-------------+----------------------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_use_order_by_and_limit_to_sort_and_limit_the_output","title":"To use <code>ORDER BY</code> and <code>LIMIT</code> to sort and limit the output","text":"<pre><code># The following example groups the outputs and restricts the number of rows of the outputs.\nnebula&gt; $a = GO FROM \"player100\" OVER follow YIELD src(edge) AS src, dst(edge) AS dst; \\\n        GO 2 STEPS FROM $a.dst OVER follow \\\n        YIELD $a.src AS src, $a.dst, src(edge), dst(edge) \\\n        | ORDER BY $-.src | OFFSET 1 LIMIT 2;\n+-------------+-------------+-------------+-------------+\n| src         | $a.dst      | src(EDGE)   | dst(EDGE)   |\n+-------------+-------------+-------------+-------------+\n| \"player100\" | \"player101\" | \"player100\" | \"player101\" |\n| \"player100\" | \"player125\" | \"player100\" | \"player125\" |\n+-------------+-------------+-------------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#other_examples","title":"Other examples","text":"<pre><code># The following example determines if $$.player.name IS NOT EMPTY.\nnebula&gt; GO FROM \"player100\" OVER follow WHERE properties($$).name IS NOT EMPTY YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player125\" |\n| \"player101\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/","title":"FETCH","text":"<p>The <code>FETCH</code> statement retrieves the properties of the specified vertices or edges.</p>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties","title":"Fetch vertex properties","text":""},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#syntax","title":"Syntax","text":"<pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *}\n&lt;vid&gt; [, vid ...]\nYIELD [DISTINCT] &lt;return_list&gt; [AS &lt;alias&gt;];\n</code></pre> Parameter Description <code>tag_name</code> The name of the tag. <code>*</code> Represents all the tags in the current graph space. <code>vid</code> The vertex ID. <code>YIELD</code> Define the output to be returned. For details, see <code>YIELD</code>. <code>AS</code> Set an alias."},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties_by_one_tag","title":"Fetch vertex properties by one tag","text":"<p>Specify a tag in the <code>FETCH</code> statement to fetch the vertex properties by that tag.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+-------------------------------+\n| properties(VERTEX)            |\n+-------------------------------+\n| {age: 42, name: \"Tim Duncan\"} |\n+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_specific_properties_of_a_vertex","title":"Fetch specific properties of a vertex","text":"<p>Use a <code>YIELD</code> clause to specify the properties to be returned.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player100\" \\\n        YIELD properties(vertex).name AS name;\n+--------------+\n| name         |\n+--------------+\n| \"Tim Duncan\" |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_properties_of_multiple_vertices","title":"Fetch properties of multiple vertices","text":"<p>Specify multiple VIDs (vertex IDs) to fetch properties of multiple vertices. Separate the VIDs with commas.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player101\", \"player102\", \"player103\" YIELD properties(vertex);\n+--------------------------------------+\n| properties(VERTEX)                   |\n+--------------------------------------+\n| {age: 33, name: \"LaMarcus Aldridge\"} |\n| {age: 36, name: \"Tony Parker\"}       |\n| {age: 32, name: \"Rudy Gay\"}          |\n+--------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties_by_multiple_tags","title":"Fetch vertex properties by multiple tags","text":"<p>Specify multiple tags in the <code>FETCH</code> statement to fetch the vertex properties by the tags. Separate the tags with commas.</p> <pre><code># The following example creates a new tag t1.\nnebula&gt; CREATE TAG IF NOT EXISTS t1(a string, b int);\n\n# The following example attaches t1 to the vertex \"player100\".\nnebula&gt; INSERT VERTEX t1(a, b) VALUES \"player100\":(\"Hello\", 100);\n\n# The following example fetches the properties of vertex \"player100\" by the tags player and t1.\nnebula&gt; FETCH PROP ON player, t1 \"player100\" YIELD vertex AS v;\n+----------------------------------------------------------------------------+\n| v                                                                          |\n+----------------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :t1{a: \"Hello\", b: 100}) |\n+----------------------------------------------------------------------------+\n</code></pre> <p>You can combine multiple tags with multiple VIDs in a <code>FETCH</code> statement.</p> <pre><code>nebula&gt; FETCH PROP ON player, t1 \"player100\", \"player103\" YIELD vertex AS v;\n+----------------------------------------------------------------------------+\n| v                                                                          |\n+----------------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :t1{a: \"Hello\", b: 100}) |\n| (\"player103\" :player{age: 32, name: \"Rudy Gay\"})                           |\n+----------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties_by_all_tags","title":"Fetch vertex properties by all tags","text":"<p>Set an asterisk symbol <code>*</code> to fetch properties by all tags in the current graph space.</p> <pre><code>nebula&gt; FETCH PROP ON * \"player100\", \"player106\", \"team200\" YIELD vertex AS v;\n+----------------------------------------------------------------------------+\n| v                                                                          |\n+----------------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :t1{a: \"Hello\", b: 100}) |\n| (\"player106\" :player{age: 25, name: \"Kyle Anderson\"})                      |\n| (\"team200\" :team{name: \"Warriors\"})                                        |\n+----------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_edge_properties","title":"Fetch edge properties","text":""},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#syntax_1","title":"Syntax","text":"<pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> Parameter Description <code>edge_type</code> The name of the edge type. <code>src_vid</code> The VID of the source vertex. It specifies the start of an edge. <code>dst_vid</code> The VID of the destination vertex. It specifies the end of an edge. <code>rank</code> The rank of the edge. It is optional and defaults to <code>0</code>. It distinguishes an edge from other edges with the same edge type, source vertex, destination vertex, and rank. <code>YIELD</code> Define the output to be returned. For details, see <code>YIELD</code>."},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_all_properties_of_an_edge","title":"Fetch all properties of an edge","text":"<p>The following statement fetches all the properties of the <code>serve</code> edge that connects vertex <code>\"player100\"</code> and vertex <code>\"team204\"</code>.</p> <pre><code>nebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD properties(edge);\n+------------------------------------+\n| properties(EDGE)                   |\n+------------------------------------+\n| {end_year: 2016, start_year: 1997} |\n+------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_specific_properties_of_an_edge","title":"Fetch specific properties of an edge","text":"<p>Use a <code>YIELD</code> clause to fetch specific properties of an edge.</p> <pre><code>nebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\"    \\\n        YIELD properties(edge).start_year;\n+-----------------------------+\n| properties(EDGE).start_year |\n+-----------------------------+\n| 1997                        |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_properties_of_multiple_edges","title":"Fetch properties of multiple edges","text":"<p>Specify multiple edge patterns (<code>&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]</code>) to fetch properties of multiple edges. Separate the edge patterns with commas.</p> <pre><code>nebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\", \"player133\" -&gt; \"team202\" YIELD edge AS e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}] |\n| [:serve \"player133\"-&gt;\"team202\" @0 {end_year: 2011, start_year: 2002}] |\n+-----------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_properties_based_on_edge_rank","title":"Fetch properties based on edge rank","text":"<p>If there are multiple edges with the same edge type, source vertex, and destination vertex, you can specify the rank to fetch the properties on the correct edge.</p> <pre><code># The following example inserts edges with different ranks and property values.\nnebula&gt; insert edge serve(start_year,end_year) \\\n        values \"player100\"-&gt;\"team204\"@1:(1998, 2017);\n\nnebula&gt; insert edge serve(start_year,end_year) \\\n        values \"player100\"-&gt;\"team204\"@2:(1990, 2018);\n\n# By default, the FETCH statement returns the edge whose rank is 0.\nnebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD edge AS e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}] |\n+-----------------------------------------------------------------------+\n\n# To fetch on an edge whose rank is not 0, set its rank in the FETCH statement.\nnebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\"@1 YIELD edge AS e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @1 {end_year: 2017, start_year: 1998}] |\n+-----------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#use_fetch_in_composite_queries","title":"Use FETCH in composite queries","text":"<p>A common way to use <code>FETCH</code> is to combine it with native nGQL such as <code>GO</code>.</p> <p>The following statement returns the <code>degree</code> values of the <code>follow</code> edges that start from vertex <code>\"player101\"</code>.</p> <pre><code>nebula&gt; GO FROM \"player101\" OVER follow \\\n        YIELD src(edge) AS s, dst(edge) AS d \\\n        | FETCH PROP ON follow $-.s -&gt; $-.d \\\n        YIELD properties(edge).degree;\n+-------------------------+\n| properties(EDGE).degree |\n+-------------------------+\n| 95                      |\n| 90                      |\n| 95                      |\n+-------------------------+\n</code></pre> <p>Or you can use user-defined variables to construct similar queries.</p> <pre><code>nebula&gt; $var = GO FROM \"player101\" OVER follow \\\n        YIELD src(edge) AS s, dst(edge) AS d; \\\n        FETCH PROP ON follow $var.s -&gt; $var.d \\\n        YIELD properties(edge).degree;\n+-------------------------+\n| properties(EDGE).degree |\n+-------------------------+\n| 95                      |\n| 90                      |\n| 95                      |\n+-------------------------+\n</code></pre> <p>For more information about composite queries, see Composite queries (clause structure).</p>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/","title":"LOOKUP","text":"<p>The <code>LOOKUP</code> statement traverses data based on indexes. You can use <code>LOOKUP</code> for the following purposes:</p> <ul> <li>Search for the specific data based on conditions defined by the <code>WHERE</code> clause.</li> </ul> <ul> <li>List vertices with a tag: retrieve the VID of all vertices with a tag.</li> </ul> <ul> <li>List edges with an edge type: retrieve the source vertex IDs, destination vertex IDs, and ranks of all edges with an edge type.</li> </ul> <ul> <li>Count the number of vertices or edges with a tag or an edge type.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#precautions","title":"Precautions","text":"<ul> <li>Correct use of indexes can speed up queries, but indexes can dramatically reduce the write performance. The performance can be greatly reduced. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.</li> </ul> <ul> <li> <p>If the specified property is not indexed when using the <code>LOOKUP</code> statement, NebulaGraph randomly selects one of the available indexes.</p> <p>For example, the tag <code>player</code> has two properties, <code>name</code> and <code>age</code>. Both the tag <code>player</code> itself and the property <code>name</code> have indexes, but the property <code>age</code> has no indexes. When running <code>LOOKUP ON player WHERE player.age == 36 YIELD player.name;</code>, NebulaGraph randomly uses one of the indexes of the tag <code>player</code> and the property <code>name</code>. You can use the <code>EXPLAIN</code> statement to check the selected index.</p> <p>Legacy version compatibility</p> <p>Before the release 2.5.0, if the specified property is not indexed when using the <code>LOOKUP</code> statement, NebulaGraph reports an error and does not use other indexes.</p> </li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#prerequisites","title":"Prerequisites","text":"<p>Before using the <code>LOOKUP</code> statement, make sure that at least one index is created. If there are already related vertices, edges, or properties before an index is created, the user must rebuild the index after creating the index to make it valid.</p>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#syntax","title":"Syntax","text":"<pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;}\n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]]\nYIELD [DISTINCT] &lt;return_list&gt; [AS &lt;alias&gt;];\n\n&lt;return_list&gt;\n    &lt;prop_name&gt; [AS &lt;col_alias&gt;] [, &lt;prop_name&gt; [AS &lt;prop_alias&gt;] ...];\n</code></pre> <ul> <li><code>WHERE &lt;expression&gt;</code>: filters data with specified conditions. Both <code>AND</code> and <code>OR</code> are supported between different expressions. For more information, see WHERE.</li> </ul> <ul> <li><code>YIELD</code>: Define the output to be returned. For details, see <code>YIELD</code>.</li> </ul> <ul> <li><code>DISTINCT</code>: Aggregate the output results and return the de-duplicated result set.</li> </ul> <ul> <li><code>AS</code>: Set an alias.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#limitations_of_using_where_in_lookup","title":"Limitations of using <code>WHERE</code> in <code>LOOKUP</code>","text":"<p>The <code>WHERE</code> clause in a <code>LOOKUP</code> statement does not support the following operations:</p> <ul> <li><code>$-</code> and <code>$^</code>.</li> <li>Filter <code>rank()</code>.</li> <li>In relational expressions, operators are not supported to have field names on both sides, such as <code>tagName.prop1&gt; tagName.prop2</code>.</li> <li>Nested AliasProp expressions in operation expressions and function expressions are not supported.</li> <li>The <code>XOR</code> operation is not supported.</li> <li>String operations other than <code>STARTS WITH</code> are not supported.</li> <li>Graph patterns.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#retrieve_vertices","title":"Retrieve vertices","text":"<p>The following example returns vertices whose <code>name</code> is <code>Tony Parker</code> and the tag is <code>player</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS index_player ON player(name(30), age);\n\nnebula&gt; REBUILD TAG INDEX index_player;\n+------------+\n| New Job Id |\n+------------+\n| 15         |\n+------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name == \"Tony Parker\" \\\n        YIELD id(vertex);\n+---------------+\n| id(VERTEX)    |\n+---------------+\n| \"player101\"   |\n+---------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name AS name, properties(vertex).age AS age;\n+---------------+-----+\n| name          | age |\n+---------------+-----+\n| \"Tony Parker\" | 36  |\n+---------------+-----+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.age  &gt; 45 \\\n        YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player144\" |\n| \"player140\" |\n+-------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name STARTS WITH \"B\" \\\n        AND player.age IN [22,30] \\\n        YIELD properties(vertex).name, properties(vertex).age;\n+-------------------------+------------------------+\n| properties(VERTEX).name | properties(VERTEX).age |\n+-------------------------+------------------------+\n| \"Ben Simmons\"           | 22                     |\n| \"Blake Griffin\"         | 30                     |\n+-------------------------+------------------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name == \"Kobe Bryant\"\\\n        YIELD id(vertex) AS VertexID, properties(vertex).name AS name |\\\n        GO FROM $-.VertexID OVER serve \\\n        YIELD $-.name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+---------------+-----------------------------+---------------------------+---------------------+\n| $-.name       | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+---------------+-----------------------------+---------------------------+---------------------+\n| \"Kobe Bryant\" | 1996                        | 2016                      | \"Lakers\"            |\n+---------------+-----------------------------+---------------------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#retrieve_edges","title":"Retrieve edges","text":"<p>The following example returns edges whose <code>degree</code> is <code>90</code> and the edge type is <code>follow</code>.</p> <pre><code>nebula&gt; CREATE EDGE INDEX IF NOT EXISTS index_follow ON follow(degree);\n\nnebula&gt; REBUILD EDGE INDEX index_follow;\n+------------+\n| New Job Id |\n+------------+\n| 62         |\n+------------+\n\nnebula&gt; LOOKUP ON follow \\\n        WHERE follow.degree == 90 YIELD edge AS e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player109\"-&gt;\"player125\" @0 {degree: 90}] |\n| [:follow \"player118\"-&gt;\"player120\" @0 {degree: 90}] |\n| [:follow \"player118\"-&gt;\"player131\" @0 {degree: 90}] |\n...\n\nnebula&gt; LOOKUP ON follow \\\n        WHERE follow.degree == 90 \\\n        YIELD properties(edge).degree;\n+-------------+-------------+---------+-------------------------+\n| SrcVID      | DstVID      | Ranking | properties(EDGE).degree |\n+-------------+-------------+---------+-------------------------+\n| \"player150\" | \"player143\" | 0       | 90                      |\n| \"player150\" | \"player137\" | 0       | 90                      |\n| \"player148\" | \"player136\" | 0       | 90                      |\n...\n\nnebula&gt; LOOKUP ON follow \\\n        WHERE follow.degree == 60 \\\n        YIELD dst(edge) AS DstVID, properties(edge).degree AS Degree |\\\n        GO FROM $-.DstVID OVER serve \\\n        YIELD $-.DstVID, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+-------------+-----------------------------+---------------------------+---------------------+\n| $-.DstVID   | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+-------------+-----------------------------+---------------------------+---------------------+\n| \"player105\" | 2010                        | 2018                      | \"Spurs\"             |\n| \"player105\" | 2009                        | 2010                      | \"Cavaliers\"         |\n| \"player105\" | 2018                        | 2019                      | \"Raptors\"           |\n+-------------+-----------------------------+---------------------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#list_vertices_or_edges_with_a_tag_or_an_edge_type","title":"List vertices or edges with a tag or an edge type","text":"<p>To list vertices or edges with a tag or an edge type, at least one index must exist on the tag, the edge type, or its property.</p> <p>For example, if there is a <code>player</code> tag with a <code>name</code> property and an <code>age</code> property, to retrieve the VID of all vertices tagged with <code>player</code>, there has to be an index on the <code>player</code> tag itself, the <code>name</code> property, or the <code>age</code> property.</p> <ul> <li>The following example shows how to retrieve the VID of all vertices tagged with <code>player</code>.<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string,age int);\n\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index on player();\n\nnebula&gt; REBUILD TAG INDEX player_index;\n+------------+\n| New Job Id |\n+------------+\n| 66         |\n+------------+\n\nnebula&gt; INSERT VERTEX player(name,age) \\\n        VALUES \"player100\":(\"Tim Duncan\", 42), \"player101\":(\"Tony Parker\", 36);\n\nThe following statement retrieves the VID of all vertices with the tag `player`. It is similar to `MATCH (n:player) RETURN id(n) /*, n */`.\n\nnebula&gt; LOOKUP ON player YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n...\n</code></pre> </li> </ul> <ul> <li>The following example shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the <code>follow</code> edge type.<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS follow(degree int);\n\nnebula&gt; CREATE EDGE INDEX IF NOT EXISTS follow_index on follow();\n\nnebula&gt; REBUILD EDGE INDEX follow_index;\n+------------+\n| New Job Id |\n+------------+\n| 88         |\n+------------+\n\nnebula&gt; INSERT EDGE follow(degree) \\\n        VALUES \"player100\"-&gt;\"player101\":(95);\n\nThe following statement retrieves all edges with the edge type `follow`. It is similar to `MATCH (s)-[e:follow]-&gt;(d) RETURN id(s), rank(e), id(d) /*, type(e) */`.\n\nnebula)&gt; LOOKUP ON follow YIELD edge AS e;\n+-----------------------------------------------------+\n| e                                                   |\n+-----------------------------------------------------+\n| [:follow \"player105\"-&gt;\"player100\" @0 {degree: 70}]  |\n| [:follow \"player105\"-&gt;\"player116\" @0 {degree: 80}]  |\n| [:follow \"player109\"-&gt;\"player100\" @0 {degree: 80}]  |\n...\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#count_the_numbers_of_vertices_or_edges","title":"Count the numbers of vertices or edges","text":"<p>The following example shows how to count the number of vertices tagged with <code>player</code> and edges of the <code>follow</code> edge type.</p> <pre><code>nebula&gt; LOOKUP ON player YIELD id(vertex)|\\\n        YIELD COUNT(*) AS Player_Number;\n+---------------+\n| Player_Number |\n+---------------+\n| 51            |\n+---------------+\n\nnebula&gt; LOOKUP ON follow YIELD edge AS e| \\\n        YIELD COUNT(*) AS Follow_Number;\n+---------------+\n| Follow_Number |\n+---------------+\n| 81            |\n+---------------+\n</code></pre> <p>Note</p> <p>You can also use <code>SHOW STATS</code> to count the numbers of vertices or edges.</p>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/","title":"OPTIONAL MATCH","text":"<p>Caution</p> <p>The feature is still in beta. It will continue to be optimized.</p> <p>The <code>OPTIONAL MATCH</code> clause is used to search for the pattern described in it. <code>OPTIONAL MATCH</code> matches patterns against your graph database, just like <code>MATCH</code> does. The difference is that if no matches are found, <code>OPTIONAL MATCH</code> will use a null for missing parts of the pattern.</p>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to the openCypher syntax in nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/#limitations","title":"Limitations","text":"<p>The <code>WHERE</code> clause cannot be used in an <code>OPTIONAL MATCH</code> clause.</p>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/#example","title":"Example","text":"<p>The example of the use of <code>OPTIONAL MATCH</code> in the <code>MATCH</code> statement is as follows:</p> <pre><code>nebula&gt; MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" \\\n        OPTIONAL MATCH (n)-[]-&gt;(l) \\\n        RETURN id(m),id(n),id(l);\n+-------------+-------------+-------------+\n| id(m)       | id(n)       | id(l)       |\n+-------------+-------------+-------------+\n| \"player100\" | \"team204\"   | __NULL__    |\n| \"player100\" | \"player101\" | \"team204\"   |\n| \"player100\" | \"player101\" | \"team215\"   |\n| \"player100\" | \"player101\" | \"player100\" |\n| \"player100\" | \"player101\" | \"player102\" |\n| \"player100\" | \"player101\" | \"player125\" |\n| \"player100\" | \"player125\" | \"team204\"   |\n| \"player100\" | \"player125\" | \"player100\" |\n+-------------+-------------+-------------+\n</code></pre> <p>Using multiple <code>MATCH</code> instead of <code>OPTIONAL MATCH</code> returns rows that match the pattern exactly. The example is as follows:</p> <pre><code>nebula&gt; MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" \\\n        MATCH (n)-[]-&gt;(l) \\\n        RETURN id(m),id(n),id(l);\n+-------------+-------------+-------------+\n| id(m)       | id(n)       | id(l)       |\n+-------------+-------------+-------------+\n| \"player100\" | \"player101\" | \"team204\"   |\n| \"player100\" | \"player101\" | \"team215\"   |\n| \"player100\" | \"player101\" | \"player100\" |\n| \"player100\" | \"player101\" | \"player102\" |\n| \"player100\" | \"player101\" | \"player125\" |\n| \"player100\" | \"player125\" | \"team204\"   |\n| \"player100\" | \"player125\" | \"player100\" |\n+-------------+-------------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/1.show-charset/","title":"SHOW CHARSET","text":"<p>The <code>SHOW CHARSET</code> statement shows the available character sets.</p> <p>Currently available types are <code>utf8</code> and <code>utf8mb4</code>. The default charset type is <code>utf8</code>. NebulaGraph extends the <code>uft8</code> to support four-byte characters. Therefore <code>utf8</code> and <code>utf8mb4</code> are equivalent.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/1.show-charset/#syntax","title":"Syntax","text":"<pre><code>SHOW CHARSET;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/1.show-charset/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW CHARSET;\n+---------+-----------------+-------------------+--------+\n| Charset | Description     | Default collation | Maxlen |\n+---------+-----------------+-------------------+--------+\n| \"utf8\"  | \"UTF-8 Unicode\" | \"utf8_bin\"        | 4      |\n+---------+-----------------+-------------------+--------+\n</code></pre> Parameter Description <code>Charset</code> The name of the character set. <code>Description</code> The description of the character set. <code>Default collation</code> The default collation of the character set. <code>Maxlen</code> The maximum number of bytes required to store one character."},{"location":"3.ngql-guide/7.general-query-statements/6.show/10.show-roles/","title":"SHOW ROLES","text":"<p>The <code>SHOW ROLES</code> statement shows the roles that are assigned to a user account.</p> <p>The return message differs according to the role of the user who is running this statement:</p> <ul> <li>If the user is a <code>GOD</code> or <code>ADMIN</code> and is granted access to the specified graph space, NebulaGraph shows all roles in this graph space except for <code>GOD</code>.</li> </ul> <ul> <li>If the user is a <code>DBA</code>, <code>USER</code>, or <code>GUEST</code> and is granted access to the specified graph space, NebulaGraph shows the user's own role in this graph space.</li> </ul> <ul> <li>If the user does not have access to the specified graph space, NebulaGraph returns <code>PermissionError</code>.</li> </ul> <p>For more information about roles, see Roles and privileges.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/10.show-roles/#syntax","title":"Syntax","text":"<pre><code>SHOW ROLES IN &lt;space_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/10.show-roles/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW ROLES in basketballplayer;\n+---------+-----------+\n| Account | Role Type |\n+---------+-----------+\n| \"user1\" | \"ADMIN\"   |\n+---------+-----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/","title":"SHOW SNAPSHOTS","text":"<p>The <code>SHOW SNAPSHOTS</code> statement shows the information of all the snapshots.</p> <p>For how to create a snapshot and backup data, see Snapshot.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/#role_requirement","title":"Role requirement","text":"<p>Only the <code>root</code> user who has the <code>GOD</code> role can use the <code>SHOW SNAPSHOTS</code> statement.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/#syntax","title":"Syntax","text":"<pre><code>SHOW SNAPSHOTS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW SNAPSHOTS;\n+--------------------------------+---------+-----------------------------------------------------+\n| Name                           | Status  | Hosts                                               |\n+--------------------------------+---------+-----------------------------------------------------+\n| \"SNAPSHOT_2020_12_16_11_13_55\" | \"VALID\" | \"storaged0:9779, storaged1:9779, storaged2:9779\"    |\n| \"SNAPSHOT_2020_12_16_11_14_10\" | \"VALID\" | \"storaged0:9779, storaged1:9779, storaged2:9779\"    |\n+--------------------------------+---------+-----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/12.show-spaces/","title":"SHOW SPACES","text":"<p>The <code>SHOW SPACES</code> statement shows existing graph spaces in NebulaGraph.</p> <p>For how to create a graph space, see CREATE SPACE.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/12.show-spaces/#syntax","title":"Syntax","text":"<pre><code>SHOW SPACES;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/12.show-spaces/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW SPACES;\n+---------------------+\n| Name                |\n+---------------------+\n| \"docs\"              |\n| \"basketballplayer\"  |\n+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/","title":"SHOW STATS","text":"<p>The <code>SHOW STATS</code> statement shows the statistics of the graph space collected by the latest <code>SUBMIT JOB STATS</code> job.</p> <p>The statistics include the following information:</p> <ul> <li>The number of vertices in the graph space</li> <li>The number of edges in the graph space</li> <li>The number of vertices of each tag</li> <li>The number of edges of each edge type</li> </ul> <p>Warning</p> <p>The data returned by <code>SHOW STATS</code> is not real-time. The returned data is collected by the latest SUBMIT JOB STATS job and may include TTL-expired data. The expired data will be deleted and not included in the statistics the next time the Compaction operation  is performed.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#prerequisites","title":"Prerequisites","text":"<p>You have to run the <code>SUBMIT JOB STATS</code> statement in the graph space where you want to collect statistics. For more information, see SUBMIT JOB STATS.</p> <p>Caution</p> <p>The result of the <code>SHOW STATS</code> statement is based on the last executed <code>SUBMIT JOB STATS</code> statement. If you want to update the result, run <code>SUBMIT JOB STATS</code> again. Otherwise the statistics will be wrong.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#syntax","title":"Syntax","text":"<pre><code>SHOW STATS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#examples","title":"Examples","text":"<pre><code># Choose a graph space.\nnebula&gt; USE basketballplayer;\n\n# Start SUBMIT JOB STATS.\nnebula&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 98         |\n+------------+\n\n# Make sure the job executes successfully.\nnebula&gt; SHOW JOB 98;\n+----------------+---------------+------------+----------------------------+----------------------------+-------------+\n| Job Id(TaskId) | Command(Dest) | Status     | Start Time                 | Stop Time                  | Error Code  |\n+----------------+---------------+------------+----------------------------+----------------------------+-------------+\n| 98             | \"STATS\"       | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| 0              | \"storaged2\"   | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| 1              | \"storaged0\"   | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| 2              | \"storaged1\"   | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| \"Total:3\"      | \"Succeeded:3\" | \"Failed:0\" | \"In Progress:0\"            | \"\"                         | \"\"          |\n+----------------+---------------+------------+----------------------------+----------------------------+-------------+\n\n# Show the statistics of the graph space.\nnebula&gt; SHOW STATS;\n+---------+------------+-------+\n| Type    | Name       | Count |\n+---------+------------+-------+\n| \"Tag\"   | \"player\"   | 51    |\n| \"Tag\"   | \"team\"     | 30    |\n| \"Edge\"  | \"follow\"   | 81    |\n| \"Edge\"  | \"serve\"    | 152   |\n| \"Space\" | \"vertices\" | 81    |\n| \"Space\" | \"edges\"    | 233   |\n+---------+------------+-------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/15.show-tags-edges/","title":"SHOW TAGS/EDGES","text":"<p>The <code>SHOW TAGS</code> statement shows all the tags in the current graph space.</p> <p>The <code>SHOW EDGES</code> statement shows all the edge types in the current graph space.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/15.show-tags-edges/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAGS | EDGES};\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/15.show-tags-edges/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAGS;\n+----------+\n| Name     |\n+----------+\n| \"player\" |\n| \"star\"   |\n| \"team\"   |\n+----------+\n\nnebula&gt; SHOW EDGES;\n+----------+\n| Name     |\n+----------+\n| \"follow\" |\n| \"serve\"  |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/","title":"SHOW USERS","text":"<p>The <code>SHOW USERS</code> statement shows the user information.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/#role_requirement","title":"Role requirement","text":"<p>Only the <code>root</code> user who has the <code>GOD</code> role can use the <code>SHOW USERS</code> statement.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/#syntax","title":"Syntax","text":"<pre><code>SHOW USERS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW USERS;\n+---------+-----------------+\n| Account | IP Whitelist    |\n+---------+-----------------+\n| \"root\"  | \"\"              |\n| \"user1\" | \"\"              |\n| \"user2\" | \"192.168.10.10\" |\n+---------+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/","title":"SHOW SESSIONS","text":"<p>When a user logs in to the database, a corresponding session will be created and users can query for session information.</p> <p>The <code>SHOW SESSIONS</code> statement shows the information of all the sessions. It can also show a specified session with its ID.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/#precautions","title":"Precautions","text":"<ul> <li>The client will call the API <code>release</code> to release the session and clear the session information when you run <code>exit</code> after the operation ends. If you exit the database in an unexpected way and the session timeout duration is not set via <code>session_idle_timeout_secs</code> in nebula-graphd.conf, the session will not be released automatically. For those sessions that are not automatically released, you need to delete them manually. For details, see KILL SESSIONS.</li> </ul> <ul> <li><code>SHOW SESSIONS</code> queries the session information of all the Graph services.</li> </ul> <ul> <li><code>SHOW LOCAL SESSIONS</code> queries the session information of the currently connected Graph service and does not query the session information of other Graph services.</li> </ul> <ul> <li><code>SHOW SESSION &lt;Session_Id&gt;</code> queries the session information with a specific session id.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/#syntax","title":"Syntax","text":"<pre><code>SHOW [LOCAL] SESSIONS;\nSHOW SESSION &lt;Session_Id&gt;;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW SESSIONS;\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| SessionId        | UserName | SpaceName          | CreateTime                 | UpdateTime                 | GraphAddr        | Timezone | ClientIp           |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| 1651220858102296 | \"root\"   | \"basketballplayer\" | 2022-04-29T08:27:38.102296 | 2022-04-29T08:50:46.282921 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1651199330300991 | \"root\"   | \"basketballplayer\" | 2022-04-29T02:28:50.300991 | 2022-04-29T08:16:28.339038 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1651112899847744 | \"root\"   | \"basketballplayer\" | 2022-04-28T02:28:19.847744 | 2022-04-28T08:17:44.470210 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1651041092662100 | \"root\"   | \"basketballplayer\" | 2022-04-27T06:31:32.662100 | 2022-04-27T07:01:25.200978 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1650959429593975 | \"root\"   | \"basketballplayer\" | 2022-04-26T07:50:29.593975 | 2022-04-26T07:51:47.184810 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1650958897679595 | \"root\"   | \"\"                 | 2022-04-26T07:41:37.679595 | 2022-04-26T07:41:37.683802 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n\nnebula&gt; SHOW SESSION 1635254859271703;\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| SessionId        | UserName | SpaceName          | CreateTime                 | UpdateTime                 | GraphAddr        | Timezone | ClientIp           |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| 1651220858102296 | \"root\"   | \"basketballplayer\" | 2022-04-29T08:27:38.102296 | 2022-04-29T08:50:54.254384 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n</code></pre> Parameter Description <code>SessionId</code> The session ID, namely the identifier of a session. <code>UserName</code> The username in a session. <code>SpaceName</code> The name of the graph space that the user uses currently. It is null (<code>\"\"</code>) when you first log in because there is no specified graph space. <code>CreateTime</code> The time when the session is created, namely the time when the user logs in. The time zone is specified by <code>timezone_name</code> in the configuration file. <code>UpdateTime</code> The system will update the time when there is an operation. The time zone is specified by <code>timezone_name</code> in the configuration file. <code>GraphAddr</code> The IP address and port of the Graph server that hosts the session. <code>Timezone</code> A reserved parameter that has no specified meaning for now. <code>ClientIp</code> The IP address of the client."},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/","title":"SHOW QUERIES","text":"<p>The <code>SHOW QUERIES</code> statement shows the information of working queries in the current session.</p> <p>Note</p> <p>To terminate queries, see Kill Query.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/#precautions","title":"Precautions","text":"<ul> <li>The <code>SHOW LOCAL QUERIES</code> statement gets the status of queries in the current session from the local cache with almost no latency.</li> </ul> <ul> <li>The <code>SHOW QUERIES</code> statement gets the information of queries in all the sessions from the Meta Service. The information will be synchronized to the Meta Service according to the interval defined by <code>session_reclaim_interval_secs</code>. Therefore the information that you get from the client may belong to the last synchronization interval.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/#syntax","title":"Syntax","text":"<pre><code>SHOW [LOCAL] QUERIES;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW LOCAL QUERIES;\n+------------------+-----------------+--------+----------------------+----------------------------+----------------+-----------+-----------------------+\n| SessionID        | ExecutionPlanID | User   | Host                 | StartTime                  | DurationInUSec | Status    | Query                 |\n+------------------+-----------------+--------+----------------------+----------------------------+----------------+-----------+-----------------------+\n| 1625463842921750 | 46              | \"root\" | \"\"192.168.x.x\":9669\" | 2021-07-05T05:44:19.502903 | 0              | \"RUNNING\" | \"SHOW LOCAL QUERIES;\" |\n+------------------+-----------------+--------+----------------------+----------------------------+----------------+-----------+-----------------------+\n\nnebula&gt; SHOW QUERIES;\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+---------------------------------------------------------+\n| SessionID        | ExecutionPlanID | User    | Host                 | StartTime                  | DurationInUSec | Status    | Query                                                   |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+---------------------------------------------------------+\n| 1625456037718757 | 54              | \"user1\" | \"\"192.168.x.x\":9669\" | 2021-07-05T05:51:08.691318 | 1504502        | \"RUNNING\" | \"MATCH p=(v:player)-[*1..4]-(v2) RETURN v2 AS Friends;\" |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+---------------------------------------------------------+\n\n# The following statement returns the top 10 queries that have the longest duration.\nnebula&gt; SHOW QUERIES | ORDER BY $-.DurationInUSec DESC | LIMIT 10;\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+-------------------------------------------------------+\n| SessionID        | ExecutionPlanID | User    | Host                 | StartTime                  | DurationInUSec | Status    | Query                                                 |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+-------------------------------------------------------+\n| 1625471375320831 | 98              | \"user2\" | \"\"192.168.x.x\":9669\" | 2021-07-05T07:50:24.461779 | 2608176        | \"RUNNING\" | \"MATCH (v:player)-[*1..4]-(v2) RETURN v2 AS Friends;\" |\n| 1625456037718757 | 99              | \"user1\" | \"\"192.168.x.x\":9669\" | 2021-07-05T07:50:24.910616 | 2159333        | \"RUNNING\" | \"MATCH (v:player)-[*1..4]-(v2) RETURN v2 AS Friends;\" |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+-------------------------------------------------------+\n</code></pre> <p>The descriptions are as follows.</p> Parameter Description <code>SessionID</code> The session ID. <code>ExecutionPlanID</code> The ID of the execution plan. <code>User</code> The username that executes the query. <code>Host</code> The IP address and port of the Graph server that hosts the session. <code>StartTime</code> The time when the query starts. <code>DurationInUSec</code> The duration of the query. The unit is microsecond. <code>Status</code> The current status of the query. <code>Query</code> The query statement."},{"location":"3.ngql-guide/7.general-query-statements/6.show/19.show-meta-leader/","title":"SHOW META LEADER","text":"<p>The <code>SHOW META LEADER</code> statement shows the information of the leader in the current Meta cluster.</p> <p>For more information about the Meta service, see Meta service.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/19.show-meta-leader/#syntax","title":"Syntax","text":"<pre><code>SHOW META LEADER;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/19.show-meta-leader/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW META LEADER;\n+------------------+---------------------------+\n| Meta Leader      | secs from last heart beat |\n+------------------+---------------------------+\n| \"127.0.0.1:9559\" | 3                         |\n+------------------+---------------------------+\n</code></pre> Parameter Description <code>Meta Leader</code> Shows the information of the leader in the Meta cluster, including the IP address and port of the server where the leader is located. <code>secs from last heart beat</code> Indicates the time interval since the last heartbeat. This parameter is measured in seconds."},{"location":"3.ngql-guide/7.general-query-statements/6.show/2.show-collation/","title":"SHOW COLLATION","text":"<p>The <code>SHOW COLLATION</code> statement shows the collations supported by NebulaGraph.</p> <p>Currently available types are: <code>utf8_bin</code> and <code>utf8mb4_bin</code>.</p> <ul> <li>When the character set is <code>utf8</code>, the default collate is <code>utf8_bin</code>.</li> </ul> <ul> <li>When the character set is <code>utf8mb4</code>, the default collate is <code>utf8mb4_bin</code>.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/2.show-collation/#syntax","title":"Syntax","text":"<pre><code>SHOW COLLATION;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/2.show-collation/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW COLLATION;\n+------------+---------+\n| Collation  | Charset |\n+------------+---------+\n| \"utf8_bin\" | \"utf8\"  |\n+------------+---------+\n</code></pre> Parameter Description <code>Collation</code> The name of the collation. <code>Charset</code> The name of the character set with which the collation is associated."},{"location":"3.ngql-guide/7.general-query-statements/6.show/4.show-create-space/","title":"SHOW CREATE SPACE","text":"<p>The <code>SHOW CREATE SPACE</code> statement shows the creating statement of the specified graph space.</p> <p>For details about the graph space information, see CREATE SPACE.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/4.show-create-space/#syntax","title":"Syntax","text":"<pre><code>SHOW CREATE SPACE &lt;space_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/4.show-create-space/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW CREATE SPACE basketballplayer;\n+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------+\n| Space              | Create Space                                                                                                                                |\n+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------+\n| \"basketballplayer\" | \"CREATE SPACE `basketballplayer` (partition_num = 10, replica_factor = 1, charset = utf8, collate = utf8_bin, vid_type = FIXED_STRING(32))\" |\n+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/5.show-create-tag-edge/","title":"SHOW CREATE TAG/EDGE","text":"<p>The <code>SHOW CREATE TAG</code> statement shows the basic information of the specified tag. For details about the tag, see CREATE TAG.</p> <p>The <code>SHOW CREATE EDGE</code> statement shows the basic information of the specified edge type. For details about the edge type, see CREATE EDGE.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/5.show-create-tag-edge/#syntax","title":"Syntax","text":"<pre><code>SHOW CREATE {TAG &lt;tag_name&gt; | EDGE &lt;edge_name&gt;};\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/5.show-create-tag-edge/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW CREATE TAG player;\n+----------+-----------------------------------+\n| Tag      | Create Tag                        |\n+----------+-----------------------------------+\n| \"player\" | \"CREATE TAG `player` (            |\n|          |  `name` string NULL,              |\n|          |  `age` int64 NULL                 |\n|          | ) ttl_duration = 0, ttl_col = \"\"\" |\n+----------+-----------------------------------+\n\nnebula&gt; SHOW CREATE EDGE follow;\n+----------+-----------------------------------+\n| Edge     | Create Edge                       |\n+----------+-----------------------------------+\n| \"follow\" | \"CREATE EDGE `follow` (           |\n|          |  `degree` int64 NULL              |\n|          | ) ttl_duration = 0, ttl_col = \"\"\" |\n+----------+-----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/6.show-hosts/","title":"SHOW HOSTS","text":"<p>The <code>SHOW HOSTS</code> statement shows the cluster information, including the port, status, leader, partition, and version information. You can also add the service type in the statement to view the information of the specific service.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/6.show-hosts/#syntax","title":"Syntax","text":"<pre><code>SHOW HOSTS [GRAPH | STORAGE | META];\n</code></pre> <p>Note</p> <p>For a NebulaGraph cluster installed with the source code, the version of the cluster will not be displayed in the output after executing the command <code>SHOW HOSTS (GRAPH | STORAGE | META)</code> with the service name.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/6.show-hosts/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW HOSTS;\n+-------------+-------+----------+--------------+----------------------------------+------------------------------+---------+\n| Host        | Port  | Status   | Leader count | Leader distribution              | Partition distribution       | Version |\n+-------------+-------+----------+--------------+----------------------------------+------------------------------+---------+\n| \"storaged0\" | 9779  | \"ONLINE\" | 8            | \"docs:5, basketballplayer:3\"     | \"docs:5, basketballplayer:3\" | \"2.0.0\" |\n| \"storaged1\" | 9779  | \"ONLINE\" | 9            | \"basketballplayer:4, docs:5\"     | \"docs:5, basketballplayer:4\" | \"2.0.0\" |\n| \"storaged2\" | 9779  | \"ONLINE\" | 8            | \"basketballplayer:3, docs:5\"     | \"docs:5, basketballplayer:3\" | \"2.0.0\" |\n+-------------+-------+----------+--------------+----------------------------------+------------------------------+---------+\n\nnebula&gt; SHOW HOSTS GRAPH;\n+-----------+------+----------+---------+--------------+---------+\n| Host      | Port | Status   | Role    | Git Info Sha | Version |\n+-----------+------+----------+---------+--------------+---------+\n| \"graphd\"  | 9669 | \"ONLINE\" | \"GRAPH\" | \"3ba41bd\"    | \"2.0.0\" |\n| \"graphd1\" | 9669 | \"ONLINE\" | \"GRAPH\" | \"3ba41bd\"    | \"2.0.0\" |\n| \"graphd2\" | 9669 | \"ONLINE\" | \"GRAPH\" | \"3ba41bd\"    | \"2.0.0\" |\n+-----------+------+----------+---------+--------------+---------+\n\nnebula&gt; SHOW HOSTS STORAGE;\n+-------------+------+----------+-----------+--------------+---------+\n| Host        | Port | Status   | Role      | Git Info Sha | Version |\n+-------------+------+----------+-----------+--------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"2.0.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"2.0.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"2.0.0\" |\n+-------------+------+----------+-----------+--------------+---------+\n\nnebula&gt; SHOW HOSTS META;\n+----------+------+----------+--------+--------------+---------+\n| Host     | Port | Status   | Role   | Git Info Sha | Version |\n+----------+------+----------+--------+--------------+---------+\n| \"metad2\" | 9559 | \"ONLINE\" | \"META\" | \"3ba41bd\"    | \"2.0.0\" |\n| \"metad0\" | 9559 | \"ONLINE\" | \"META\" | \"3ba41bd\"    | \"2.0.0\" |\n| \"metad1\" | 9559 | \"ONLINE\" | \"META\" | \"3ba41bd\"    | \"2.0.0\" |\n+----------+------+----------+--------+--------------+---------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/","title":"SHOW INDEX STATUS","text":"<p>The <code>SHOW INDEX STATUS</code> statement shows the status of jobs that rebuild native indexes, which helps check whether a native index is successfully rebuilt or not.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEX STATUS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAG INDEX STATUS;\n+------------------------------------+--------------+\n| Name                               | Index Status |\n+------------------------------------+--------------+\n| \"date1_index\"                      | \"FINISHED\"   |\n| \"basketballplayer_all_tag_indexes\" | \"FINISHED\"   |\n| \"any_shape_geo_index\"              | \"FINISHED\"   |\n+------------------------------------+--------------+\n\nnebula&gt; SHOW EDGE INDEX STATUS;\n+----------------+--------------+\n| Name           | Index Status |\n+----------------+--------------+\n| \"follow_index\" | \"FINISHED\"   |\n+----------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/#related_topics","title":"Related topics","text":"<ul> <li>Job manager and the JOB statements</li> <li>REBUILD NATIVE INDEX</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/8.show-indexes/","title":"SHOW INDEXES","text":"<p>The <code>SHOW INDEXES</code> statement shows the names of existing native indexes.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/8.show-indexes/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEXES;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/8.show-indexes/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\n\nnebula&gt; SHOW EDGE INDEXES;\n+----------------+----------+---------+\n| Index Name     | By Edge  | Columns |\n+----------------+----------+---------+\n| \"follow_index\" | \"follow\" | []      |\n+----------------+----------+---------+\n</code></pre> <p>Legacy version compatibility</p> <p>In NebulaGraph 2.x, <code>SHOW TAG/EDGE INDEXES</code> only returns <code>Names</code>.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/9.show-parts/","title":"SHOW PARTS","text":"<p>The <code>SHOW PARTS</code> statement shows the information of a specified partition or all partitions in a graph space.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/9.show-parts/#syntax","title":"Syntax","text":"<pre><code>SHOW PARTS [&lt;part_id&gt;];\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/9.show-parts/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW PARTS;\n+--------------+--------------------+--------------------+-------+\n| Partition ID | Leader             | Peers              | Losts |\n+--------------+--------------------+--------------------+-------+\n| 1            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n| 2            | \"192.168.2.2:9779\" | \"192.168.2.2:9779\" | \"\"    |\n| 3            | \"192.168.2.3:9779\" | \"192.168.2.3:9779\" | \"\"    |\n| 4            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n| 5            | \"192.168.2.2:9779\" | \"192.168.2.2:9779\" | \"\"    |\n| 6            | \"192.168.2.3:9779\" | \"192.168.2.3:9779\" | \"\"    |\n| 7            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n| 8            | \"192.168.2.2:9779\" | \"192.168.2.2:9779\" | \"\"    |\n| 9            | \"192.168.2.3:9779\" | \"192.168.2.3:9779\" | \"\"    |\n| 10           | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n+--------------+--------------------+--------------------+-------+\n\nnebula&gt; SHOW PARTS 1;\n+--------------+--------------------+--------------------+-------+\n| Partition ID | Leader             | Peers              | Losts |\n+--------------+--------------------+--------------------+-------+\n| 1            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n+--------------+--------------------+--------------------+-------+\n</code></pre> <p>The descriptions are as follows.</p> Parameter Description <code>Partition ID</code> The ID of the partition. <code>Leader</code> The IP address and the port of the leader. <code>Peers</code> The IP addresses and the ports of all the replicas. <code>Losts</code> The IP addresses and the ports of replicas at fault."},{"location":"3.ngql-guide/8.clauses-and-options/group-by/","title":"GROUP BY","text":"<p>The <code>GROUP BY</code> clause can be used to aggregate data.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to native nGQL only.</p> <p>You can also use the count() function to aggregate data.</p> <pre><code>nebula&gt;  MATCH (v:player)&lt;-[:follow]-(:player) RETURN v.player.name AS Name, count(*) as cnt ORDER BY cnt DESC;\n+----------------------+-----+\n| Name                 | cnt |\n+----------------------+-----+\n| \"Tim Duncan\"         | 10  |\n| \"LeBron James\"       | 6   |\n| \"Tony Parker\"        | 5   |\n| \"Chris Paul\"         | 4   |\n| \"Manu Ginobili\"      | 4   |\n+----------------------+-----+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#syntax","title":"Syntax","text":"<p>The <code>GROUP BY</code> clause groups the rows with the same value. Then operations such as counting, sorting, and calculation can be applied.</p> <p>The <code>GROUP BY</code> clause works after the pipe symbol (|) and before a <code>YIELD</code> clause.</p> <pre><code>| GROUP BY &lt;var&gt; YIELD &lt;var&gt;, &lt;aggregation_function(var)&gt;\n</code></pre> <p>The <code>aggregation_function()</code> function supports <code>avg()</code>, <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>count()</code>, <code>collect()</code>, and <code>std()</code>.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#examples","title":"Examples","text":"<p>The following statement finds all the vertices connected directly to vertex <code>\"player100\"</code>, groups the result set by player names, and counts how many times the name shows up in the result set.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow BIDIRECT \\\n        YIELD properties($$).name as Name \\\n        | GROUP BY $-.Name \\\n        YIELD $-.Name as Player, count(*) AS Name_Count;\n+---------------------+------------+\n| Player              | Name_Count |\n+---------------------+------------+\n| \"Shaquille O'Neal\"  | 1          |\n| \"Tiago Splitter\"    | 1          |\n| \"Manu Ginobili\"     | 2          |\n| \"Boris Diaw\"        | 1          |\n| \"LaMarcus Aldridge\" | 1          |\n| \"Tony Parker\"       | 2          |\n| \"Marco Belinelli\"   | 1          |\n| \"Dejounte Murray\"   | 1          |\n| \"Danny Green\"       | 1          |\n| \"Aron Baynes\"       | 1          |\n+---------------------+------------+\n</code></pre> <p>The following statement finds all the vertices connected directly to vertex <code>\"player100\"</code>, groups the result set by source vertices, and returns the sum of degree values.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge) AS player, properties(edge).degree AS degree \\\n        | GROUP BY $-.player \\\n        YIELD sum($-.degree);\n+----------------+\n| sum($-.degree) |\n+----------------+\n| 190            |\n+----------------+\n</code></pre> <p>For more information about the <code>sum()</code> function, see Built-in math functions.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#implicit_group_by","title":"Implicit GROUP BY","text":"<p>The usage of <code>GROUP BY</code> in the above nGQL statements that explicitly write <code>GROUP BY</code> and act as grouping fields is called explicit <code>GROUP BY</code>, while in openCypher, the <code>GROUP BY</code> is implicit, i.e., <code>GROUP BY</code> groups fields without explicitly writing <code>GROUP BY</code>. The explicit <code>GROUP BY</code> in nGQL is the same as the implicit <code>GROUP BY</code> in openCypher, and nGQL also supports the implicit <code>GROUP BY</code>. For the implicit usage of <code>GROUP BY</code>, see how-to-make-group-by-in-a-cypher-query.</p> <p>For example, to look up the players over 34 years old with the same length of service, you can use the following statement:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age &gt; 34 YIELD id(vertex) AS v | \\\n        GO FROM $-.v OVER serve YIELD serve.start_year AS start_year, serve.end_year AS end_year | \\\n        YIELD $-.start_year, $-.end_year, count(*) AS count | \\\n        ORDER BY $-.count DESC | LIMIT 5;\n+---------------+-------------+-------+\n| $-.start_year | $-.end_year | count |\n+---------------+-------------+-------+\n| 2018          | 2019        | 3     |\n| 2007          | 2012        | 2     |\n| 1998          | 2004        | 2     |\n| 2017          | 2018        | 2     |\n| 2010          | 2011        | 2     |\n+---------------+-------------+-------+ \n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/","title":"INNER JOIN","text":"<p><code>INNER JOIN</code> is a type of join query that matches records based on common column values between two tables. It is commonly used to create a result set that includes two tables based on values in their associated columns. In NebulaGraph, the <code>INNER JOIN</code> clause can be explicitly used to conduct join queries between two tables, leading to more complex query results.</p> <p>Note</p> <p>In nGQL statements, the multi-hop query of <code>GO</code> implicitly utilizes the <code>INNER JOIN</code> clause. For example, in the statement <code>GO 1 TO 2 STEPS FROM \"player101\" OVER follow YIELD $$.player.name AS name, $$.player.age AS age</code>, the <code>GO</code> clause implicitly utilizes the <code>INNER JOIN</code> clause, matching the result columns of the first-hop query starting from <code>player101</code> along the <code>follow</code> edge with the starting columns of the second-hop query. Then, based on the matching results, it returns <code>name</code> and <code>age</code>. </p>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#opencypher_compatibility","title":"openCypher compatibility","text":"<p>The <code>INNER JOIN</code> clause is only applicable to the native nGQL syntax.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#syntax","title":"Syntax","text":"<pre><code>YIELD &lt;column_name_list&gt;\nFROM &lt;first_table&gt; INNER JOIN &lt;second_table&gt; ON &lt;join_condition&gt;\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#notes","title":"Notes","text":"<p>To conduct an <code>INNER JOIN</code> query, you need to follow these rules:</p> <ul> <li>Use the <code>YIELD</code> clause to specify the returned columns, and place it before the <code>INNER JOIN</code> clause.</li> <li>Use the <code>FROM</code> clause to specify the two tables to be joined.</li> <li>The <code>INNER JOIN</code> clause must contain the <code>ON</code> clause, which specifies the join condition. The join condition only supports equi-join (i.e., <code>==</code>).</li> <li><code>&lt;first_table&gt;</code> and <code>&lt;second_table&gt;</code> are the two tables to be joined, and the two table names cannot be the same.</li> <li>Use user-defined variables to specify the table names. For more information, see User-defined variables.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#examples","title":"Examples","text":"<p>The following examples show how to use the <code>INNER JOIN</code> clause to join the results of two queries in nGQL statements.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#example_1","title":"Example 1","text":"<p>Firstly, the <code>dst</code> column obtained from the initial <code>LOOK UP</code> operation (whose value for Tony Parker has an ID of <code>player101</code>) is connected with the <code>src</code> column obtained from the second <code>GO</code> query (which has IDs <code>player101</code> and <code>player125</code>). By matching the two columns where <code>player101</code> appears on both sides, we obtain the resulting data set. The final request then uses a <code>YIELD</code> statement <code>YIELD $b.vid AS vid, $a.v AS v, $b.e2 AS e2</code> to display the information.</p> <pre><code>nebula&gt; $a = LOOKUP ON player WHERE player.name == 'Tony Parker' YIELD id(vertex) as dst, vertex AS v; \\\n        $b = GO FROM 'player101', 'player125' OVER follow YIELD id($^) as src, id($$) as vid, edge AS e2; \\\n        YIELD $b.vid AS vid, $a.v AS v, $b.e2 AS e2 FROM $a INNER JOIN $b ON $a.dst == $b.src;\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| vid         | v                                                   | e2                                                 |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| \"player100\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}] |\n| \"player102\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player102\" @0 {degree: 90}] |\n| \"player125\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player125\" @0 {degree: 95}] |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#example_2","title":"Example 2","text":"<p>The following nGQL example utilizes the <code>INNER JOIN</code> clause to combine the <code>src</code> column from the first <code>LOOKUP</code> query (with <code>player101</code> as ID for <code>Tony Parker</code>) and the <code>src</code> column from the second <code>FETCH</code> query (with <code>player101</code> being the starting point to <code>player100</code>). By matching <code>player101</code> in both source columns, we obtain the resulting data set. The final request then utilizes a <code>YIELD</code> clause <code>YIELD $a.src AS src, $a.v AS v, $b.e AS e</code> to display the information.</p> <pre><code>nebula&gt; $a = LOOKUP ON player WHERE player.name == 'Tony Parker' YIELD id(vertex) as src, vertex AS v; \\\n        $b = FETCH PROP ON follow 'player101'-&gt;'player100' YIELD src(edge) as src, edge as e; \\\n        YIELD $a.src AS src, $a.v AS v, $b.e AS e FROM $a INNER JOIN $b ON $a.src == $b.src;\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| src         | v                                                   | e                                                  |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| \"player101\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}] |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#example_3","title":"Example 3","text":"<p>The following example shows the process of using the <code>INNER JOIN</code> clause to join the results of the <code>LOOKUP</code>, <code>GO</code>, and <code>FIND PATH</code> clauses.</p> <ol> <li>Query the <code>player</code> table using the <code>LOOKUP ON</code> statement to find the vertex for player <code>Tony Parker</code>, storing the ID and properties in the <code>$a.src</code> and <code>$a.v</code> columns, respectively.</li> <li>Then use the <code>GO</code> statement to find player nodes that are reachable in 2-5 steps through the <code>follow</code> edges from the node <code>$a.src</code>. It also requires that the players corresponding to these nodes have an age greater than 30 years old. We store the IDs of these nodes in the <code>$b.dst</code> column.</li> <li>Use the <code>FIND ALL PATH</code> statement to find all the paths that traverse the <code>follow</code> edges from <code>$a.src</code> to <code>$b.dst</code>. We also return the paths themselves as <code>$c.p</code> and the destination of each path as <code>$c.dst</code>.</li> <li>Using the <code>FIND SHORTEST PATH</code> statement, find the shortest path from <code>$c.dst</code> back to <code>$a.src</code>, storing the path in <code>$d.p</code> and the starting point in <code>$d.src</code>.</li> <li>Finally, we utilize the <code>INNER JOIN</code> clause to join the results of steps 3 and 4 by matching the <code>$c.dst</code> column with the <code>$d.src</code> column. Then use the <code>YIELD</code> statement <code>YIELD $c.forward AS forwardPath, $c.dst AS end, $d.p AS backwardPath</code> to return the matched records of the join.</li> </ol> <pre><code>nebula&gt; $a = LOOKUP ON player WHERE player.name == 'Tony Parker' YIELD id(vertex) as src, vertex AS v; \\\n        $b = GO 2 TO 5 STEPS FROM $a.src OVER follow WHERE $$.player.age &gt; 30 YIELD id($$) AS dst; \\\n        $c = (FIND ALL PATH FROM $a.src TO $b.dst OVER follow YIELD path AS p | YIELD $-.p AS forward, id(endNode($-.p)) AS dst); \\\n        $d = (FIND SHORTEST PATH FROM $c.dst TO $a.src OVER follow YIELD path AS p | YIELD $-.p AS p, id(startNode($-.p)) AS src); \\\n        YIELD $c.forward AS forwardPath, $c.dst AS end, $d.p AS backwordPath FROM $c INNER JOIN $d ON $c.dst == $d.src;\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+-----------------------------------------------------------------------------+\n| forwardPath                                                                                                                                                           | end         | backwordPath                                                                |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+-----------------------------------------------------------------------------+\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")&gt;                                                                                                                         | \"player102\" | &lt;(\"player102\")-[:follow@0 {}]-&gt;(\"player101\")&gt;                               |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")&gt;                                                             | \"player102\" | &lt;(\"player102\")-[:follow@0 {}]-&gt;(\"player101\")&gt;                               |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                                                                                         | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                                                           | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                             | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                             | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                             | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n...\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+-----------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/","title":"LIMIT AND SKIP","text":"<p>The <code>LIMIT</code> clause constrains the number of rows in the output. The usage of <code>LIMIT</code> in native nGQL statements and openCypher compatible statements is different.</p> <ul> <li>Native nGQL: Generally, a pipe <code>|</code> needs to be used before the <code>LIMIT</code> clause. The offset parameter can be set or omitted directly after the <code>LIMIT</code> statement.</li> </ul> <ul> <li>OpenCypher compatible statements: No pipes are permitted before the <code>LIMIT</code> clause. And you can use <code>SKIP</code> to indicate an offset.</li> </ul> <p>Note</p> <pre><code>When using `LIMIT` in either syntax above, it is important to use an `ORDER BY` clause that constrains the output into a unique order. Otherwise, you will get an unpredictable subset of the output.\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#limit_in_native_ngql_statements","title":"LIMIT in native nGQL statements","text":"<p>In native nGQL, <code>LIMIT</code> has general syntax and exclusive syntax in <code>GO</code> statements.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#general_limit_syntax_in_native_ngql_statements","title":"General LIMIT syntax in native nGQL statements","text":"<p>In native nGQL,  the general <code>LIMIT</code> syntax works the same as in <code>SQL</code>. The <code>LIMIT</code> clause accepts one or two parameters. The values of both parameters must be non-negative integers and be used after a pipe. The syntax and description are as follows:</p> <pre><code>... | LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;;\n</code></pre> Parameter Description <code>offset</code> The offset value. It defines the row from which to start returning. The offset starts from <code>0</code>. The default value is <code>0</code>, which returns from the first row. <code>number_rows</code> It constrains the total number of returned rows. <p>For example:</p> <pre><code># The following example returns the top 3 rows of data from the result.\nnebula&gt; LOOKUP ON player YIELD id(vertex)|\\\n        LIMIT 3;\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player102\" |\n+-------------+\n\n# The following example returns the 3 rows of data starting from the second row of the sorted output.\nnebula&gt; GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD properties($$).name AS Friend, properties($$).age AS Age \\\n        | ORDER BY $-.Age, $-.Friend \\\n        | LIMIT 1, 3;\n+-------------------+-----+\n| Friend            | Age |\n+-------------------+-----+\n| \"Danny Green\"     | 31  |\n| \"Aron Baynes\"     | 32  |\n| \"Marco Belinelli\" | 32  |\n+-------------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#limit_in_go_statements","title":"LIMIT in GO statements","text":"<p>In addition to the general syntax in the native nGQL, the <code>LIMIT</code> in the <code>GO</code> statement also supports limiting the number of output results based on edges.</p> <p>Syntax:</p> <pre><code>&lt;go_statement&gt; LIMIT &lt;limit_list&gt;;\n</code></pre> <p><code>limit_list</code> is a list. Elements in the list must be natural numbers, and the number of elements must be the same as the maximum number of <code>STEPS</code> in the <code>GO</code> statement. The following takes <code>GO 1 TO 3 STEPS FROM \"A\" OVER * LIMIT &lt;limit_list&gt;</code> as an example to introduce this usage of <code>LIMIT</code> in detail.</p> <ul> <li>The list <code>limit_list</code> must contain 3 natural numbers, such as <code>GO 1 TO 3 STEPS FROM \"A\" OVER * LIMIT [1,2,4]</code>.</li> <li><code>1</code> in <code>LIMIT [1,2,4]</code> means that the system automatically selects 1 edge to continue traversal in the first step. <code>2</code> means to select 2 edges to continue traversal in the second step. <code>4</code> indicates that 4 edges are selected to continue traversal in the third step.</li> <li>Because <code>GO 1 TO 3 STEPS</code> means to return all the traversal results from the first to third steps, all the red edges and their source and destination vertices in the figure below will be matched by this <code>GO</code> statement. And the yellow edges represent there is no path selected when the GO statement traverses. If it is not <code>GO 1 TO 3 STEPS</code> but <code>GO 3 STEPS</code>, it will only match the red edges of the third step and the vertices at both ends.</li> </ul> <p></p> <p>In the basketballplayer dataset, the example is as follows:</p> <pre><code>nebula&gt; GO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        LIMIT [3,3,3];\n+-----------------+----------+\n| NAME            | Age      |\n+-----------------+----------+\n| \"Tony Parker\"   | 36       |\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n+-----------------+----------+\n\nnebula&gt; GO 3 STEPS FROM \"player102\" OVER * BIDIRECT\\\n        YIELD dst(edge) \\\n        LIMIT [rand32(5),rand32(5),rand32(5)];\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player100\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#limit_in_opencypher_compatible_statements","title":"LIMIT in openCypher compatible statements","text":"<p>In openCypher compatible statements such as <code>MATCH</code>, there is no need to use a pipe when <code>LIMIT</code> is used. The syntax and description are as follows:</p> <pre><code>... [SKIP &lt;offset&gt;] [LIMIT &lt;number_rows&gt;];\n</code></pre> Parameter Description <code>offset</code> The offset value. It defines the row from which to start returning. The offset starts from <code>0</code>. The default value is <code>0</code>, which returns from the first row. <code>number_rows</code> It constrains the total number of returned rows. <p>Both <code>offset</code> and <code>number_rows</code> accept expressions, but the result of the expression must be a non-negative integer.</p> <p>Note</p> <p>Fraction expressions composed of two integers are automatically floored to integers. For example, <code>8/6</code> is floored to 1.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#examples_of_limit","title":"Examples of LIMIT","text":"<p><code>LIMIT</code> can be used alone to return a specified number of results.</p> <pre><code>nebula&gt; MATCH (v:player) RETURN v.player.name AS Name, v.player.age AS Age \\\n        ORDER BY Age LIMIT 5;\n+-------------------------+-----+\n| Name                    | Age |\n+-------------------------+-----+\n| \"Luka Doncic\"           | 20  |\n| \"Ben Simmons\"           | 22  |\n| \"Kristaps Porzingis\"    | 23  |\n| \"Giannis Antetokounmpo\" | 24  |\n| \"Kyle Anderson\"         | 25  |\n+-------------------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#examples_of_skip","title":"Examples of SKIP","text":"<p><code>SKIP</code> can be used alone to set the offset and return the data after the specified position.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1;\n+-----------------+-----+\n| Name            | Age |\n+-----------------+-----+\n| \"Manu Ginobili\" | 41  |\n| \"Tony Parker\"   | 36  |\n+-----------------+-----+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1+1;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 36  |\n+---------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#example_of_skip_and_limit","title":"Example of SKIP and LIMIT","text":"<p><code>SKIP</code> and <code>LIMIT</code> can be used together to return the specified amount of data starting from the specified position.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1 LIMIT 1;\n+-----------------+-----+\n| Name            | Age |\n+-----------------+-----+\n| \"Manu Ginobili\" | 41  |\n+-----------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/","title":"ORDER BY","text":"<p>The <code>ORDER BY</code> clause specifies the order of the rows in the output.</p> <ul> <li>Native nGQL: You must use a pipe (<code>|</code>) and an <code>ORDER BY</code> clause after <code>YIELD</code> clause.</li> </ul> <ul> <li>OpenCypher style: No pipes are permitted. The <code>ORDER BY</code> clause follows a <code>RETURN</code> clause.</li> </ul> <p>There are two order options:</p> <ul> <li><code>ASC</code>: Ascending. <code>ASC</code> is the default order.</li> <li><code>DESC</code>: Descending.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#native_ngql_syntax","title":"Native nGQL Syntax","text":"<pre><code>&lt;YIELD clause&gt;\n| ORDER BY &lt;expression&gt; [ASC | DESC] [, &lt;expression&gt; [ASC | DESC] ...];\n</code></pre> <p>Compatibility</p> <p>In the native nGQL syntax, <code>$-.</code> must be used after <code>ORDER BY</code>. But it is not required in releases prior to 2.5.0.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#examples","title":"Examples","text":"<pre><code>nebula&gt; FETCH PROP ON player \"player100\", \"player101\", \"player102\", \"player103\" \\\n        YIELD player.age AS age, player.name AS name \\\n        | ORDER BY $-.age ASC, $-.name DESC;\n+-----+---------------------+\n| age | name                |\n+-----+---------------------+\n| 32  | \"Rudy Gay\"          |\n| 33  | \"LaMarcus Aldridge\" |\n| 36  | \"Tony Parker\"       |\n| 42  | \"Tim Duncan\"        |\n+-----+---------------------+\n\nnebula&gt; $var = GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS dst; \\\n        ORDER BY $var.dst DESC;\n+-------------+\n| dst         |\n+-------------+\n| \"player125\" |\n| \"player101\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#opencypher_syntax","title":"OpenCypher Syntax","text":"<pre><code>&lt;RETURN clause&gt;\nORDER BY &lt;expression&gt; [ASC | DESC] [, &lt;expression&gt; [ASC | DESC] ...];\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#examples_1","title":"Examples","text":"<pre><code>nebula&gt; MATCH (v:player) RETURN v.player.name AS Name, v.player.age AS Age  \\\n        ORDER BY Name DESC;\n+-----------------+-----+\n| Name            | Age |\n+-----------------+-----+\n| \"Yao Ming\"      | 38  |\n| \"Vince Carter\"  | 42  |\n| \"Tracy McGrady\" | 39  |\n| \"Tony Parker\"   | 36  |\n| \"Tim Duncan\"    | 42  |\n+-----------------+-----+\n...\n\n# In the following example, nGQL sorts the rows by age first. If multiple people are of the same age, nGQL will then sort them by name.\nnebula&gt; MATCH (v:player) RETURN v.player.age AS Age, v.player.name AS Name  \\\n        ORDER BY Age DESC, Name ASC;\n+-----+-------------------+\n| Age | Name              |\n+-----+-------------------+\n| 47  | \"Shaquille O'Neal\" |\n| 46  | \"Grant Hill\"      |\n| 45  | \"Jason Kidd\"      |\n| 45  | \"Steve Nash\"      |\n+-----+-------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#order_of_null_values","title":"Order of NULL values","text":"<p>nGQL lists NULL values at the end of the output for ascending sorting, and at the start for descending sorting.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age  \\\n        ORDER BY Age;\n+-----------------+----------+\n| Name            | Age      |\n+-----------------+----------+\n| \"Tony Parker\"   | 36       |\n| \"Manu Ginobili\" | 41       |\n| __NULL__        | __NULL__ |\n+-----------------+----------+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age  \\\n        ORDER BY Age DESC;\n+-----------------+----------+\n| Name            | Age      |\n+-----------------+----------+\n| __NULL__        | __NULL__ |\n| \"Manu Ginobili\" | 41       |\n| \"Tony Parker\"   | 36       |\n+-----------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/","title":"RETURN","text":"<p>The <code>RETURN</code> clause defines the output of an nGQL query. To return multiple fields, separate them with commas.</p> <p><code>RETURN</code> can lead a clause or a statement:</p> <ul> <li>A <code>RETURN</code> clause can work in openCypher statements in nGQL, such as <code>MATCH</code> or <code>UNWIND</code>.</li> </ul> <ul> <li>A <code>RETURN</code> statement can work independently to output the result of an expression.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to the openCypher syntax in nGQL only. For native nGQL, use <code>YIELD</code>.</p> <p><code>RETURN</code> does not support the following openCypher features yet.</p> <ul> <li> <p>Return variables with uncommon characters, for example:</p> <pre><code>MATCH (`non-english_characters`:player) \\\nRETURN `non-english_characters`;\n</code></pre> </li> </ul> <ul> <li> <p>Set a pattern in the <code>RETURN</code> clause and return all elements that this pattern matches, for example:</p> <pre><code>MATCH (v:player) \\\nRETURN (v)-[e]-&gt;(v2);\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#map_order_description","title":"Map order description","text":"<p>When <code>RETURN</code> returns the map data structure, the order of key-value pairs is undefined.</p> <pre><code>nebula&gt; RETURN {age: 32, name: \"Marco Belinelli\"};\n+------------------------------------+\n| {age:32,name:\"Marco Belinelli\"}    |\n+------------------------------------+\n| {age: 32, name: \"Marco Belinelli\"} |\n+------------------------------------+\n\nnebula&gt; RETURN {zage: 32, name: \"Marco Belinelli\"};\n+-------------------------------------+\n| {zage:32,name:\"Marco Belinelli\"}    |\n+-------------------------------------+\n| {name: \"Marco Belinelli\", zage: 32} |\n+-------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_vertices_or_edges","title":"Return vertices or edges","text":"<p>Use the <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}</code> to return vertices and edges all information.</p> <pre><code>// Return vertices\nnebula&gt; MATCH (v:player) \\\n        RETURN v;\n+---------------------------------------------------------------+\n| v                                                             |\n+---------------------------------------------------------------+\n| (\"player104\" :player{age: 32, name: \"Marco Belinelli\"})       |\n| (\"player107\" :player{age: 32, name: \"Aron Baynes\"})           |\n| (\"player116\" :player{age: 34, name: \"LeBron James\"})          |\n| (\"player120\" :player{age: 29, name: \"James Harden\"})          |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})         |\n+---------------------------------------------------------------+\n...\n\n// Return edges\nnebula&gt; MATCH (v:player)-[e]-&gt;() \\\n        RETURN e;\n+------------------------------------------------------------------------------+\n| e                                                                            |\n+------------------------------------------------------------------------------+\n| [:follow \"player104\"-&gt;\"player100\" @0 {degree: 55}]                           |\n| [:follow \"player104\"-&gt;\"player101\" @0 {degree: 50}]                           |\n| [:follow \"player104\"-&gt;\"player105\" @0 {degree: 60}]                           |\n| [:serve \"player104\"-&gt;\"team200\" @0 {end_year: 2009, start_year: 2007}]        |\n| [:serve \"player104\"-&gt;\"team208\" @0 {end_year: 2016, start_year: 2015}]        |\n+------------------------------------------------------------------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_vids","title":"Return VIDs","text":"<p>Use the <code>id()</code> function to retrieve VIDs.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN id(v);\n+-------------+\n| id(v)       |\n+-------------+\n| \"player100\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_tag","title":"Return Tag","text":"<p>Use the <code>labels()</code> function to return the list of tags on a vertex.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN labels(v);\n+------------+\n| labels(v)  |\n+------------+\n| [\"player\"] |\n+------------+\n</code></pre> <p>To retrieve the nth element in the <code>labels(v)</code> list, use <code>labels(v)[n-1]</code>. The following example shows how to use <code>labels(v)[0]</code> to return the first tag in the list.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN labels(v)[0];\n+--------------+\n| labels(v)[0] |\n+--------------+\n| \"player\"     |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_properties","title":"Return properties","text":"<p>When returning properties of a vertex, it is necessary to specify the tag to which the properties belong because a vertex can have multiple tags and the same property name can appear on different tags.</p> <p>It is possible to specify the tag of a vertex to return all properties of that tag, or to specify both the tag and a property name to return only that property of the tag.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        RETURN v.player, v.player.name, v.player.age \\\n        LIMIT 3;\n+--------------------------------------+---------------------+--------------+\n| v.player                             | v.player.name       | v.player.age |\n+--------------------------------------+---------------------+--------------+\n| {age: 33, name: \"LaMarcus Aldridge\"} | \"LaMarcus Aldridge\" | 33           |\n| {age: 25, name: \"Kyle Anderson\"}     | \"Kyle Anderson\"     | 25           |\n| {age: 40, name: \"Kobe Bryant\"}       | \"Kobe Bryant\"       | 40           |\n+--------------------------------------+---------------------+--------------+\n</code></pre> <p>When returning edge properties, it is not necessary to specify the edge type to which the properties belong, because an edge can only have one edge type.</p> <pre><code>// Return the property of a vertex\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) \\\n        RETURN properties(v2);\n+----------------------------------+\n| properties(v2)                   |\n+----------------------------------+\n| {name: \"Spurs\"}                  |\n| {age: 36, name: \"Tony Parker\"}   |\n| {age: 41, name: \"Manu Ginobili\"} |\n+----------------------------------+\n</code></pre> <pre><code>// Return the property of an edge\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN e.start_year, e.degree \\\n+--------------+----------+\n| e.start_year | e.degree |\n+--------------+----------+\n| __NULL__     | 95       |\n| __NULL__     | 95       |\n| 1997         | __NULL__ |\n+--------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_edge_type","title":"Return edge type","text":"<p>Use the <code>type()</code> function to return the matched edge types.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN DISTINCT type(e);\n+----------+\n| type(e)  |\n+----------+\n| \"serve\"  |\n| \"follow\" |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_paths","title":"Return paths","text":"<p>Use <code>RETURN &lt;path_name&gt;</code> to return all the information of the matched paths.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[*3]-&gt;() \\\n        RETURN p;\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                                                                                                                                                                                              |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})-[:serve@0 {end_year: 2019, start_year: 2015}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;         |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})-[:serve@0 {end_year: 2015, start_year: 2006}]-&gt;(\"team203\" :team{name: \"Trail Blazers\"})&gt; |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})-[:follow@0 {degree: 75}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;           |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_vertices_in_a_path","title":"Return vertices in a path","text":"<p>Use the <code>nodes()</code> function to return all vertices in a path.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) \\\n        RETURN nodes(p);\n+-------------------------------------------------------------------------------------------------------------+\n| nodes(p)                                                                                                    |\n+-------------------------------------------------------------------------------------------------------------+\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"team204\" :team{name: \"Spurs\"})]                      |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player101\" :player{age: 36, name: \"Tony Parker\"})]   |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})] |\n+-------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_edges_in_a_path","title":"Return edges in a path","text":"<p>Use the <code>relationships()</code> function to return all edges in a path.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) \\\n        RETURN relationships(p);\n+-------------------------------------------------------------------------+\n| relationships(p)                                                        |\n+-------------------------------------------------------------------------+\n| [[:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}]] |\n| [[:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]]                    |\n| [[:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]]                    |\n+-------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_path_length","title":"Return path length","text":"<p>Use the <code>length()</code> function to return the length of a path.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[*..2]-&gt;(v2) \\\n        RETURN p AS Paths, length(p) AS Length;\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+\n| Paths                                                                                                                                                                                                                  | Length |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;                                                                                   | 1      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;                                                                                     | 1      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;                                                                                   | 1      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:serve@0 {end_year: 2018, start_year: 1999}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;     | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:serve@0 {end_year: 2019, start_year: 2018}]-&gt;(\"team215\" :team{name: \"Hornets\"})&gt;   | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 95}]-&gt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&gt;        | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})&gt; | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;     | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})-[:serve@0 {end_year: 2018, start_year: 2002}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;   | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})-[:follow@0 {degree: 90}]-&gt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&gt;      | 2      |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_all_elements","title":"Return all elements","text":"<p>To return all the elements that this pattern matches, use an asterisk (*).</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN *;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\n        RETURN *;\n+----------------------------------------------------+-----------------------------------------------------------------------+-------------------------------------------------------+\n| v                                                  | e                                                                     | v2                                                    |\n+----------------------------------------------------+-----------------------------------------------------------------------+-------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]                    | (\"player101\" :player{age: 36, name: \"Tony Parker\"})   |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]                    | (\"player125\" :player{age: 41, name: \"Manu Ginobili\"}) |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}] | (\"team204\" :team{name: \"Spurs\"})                      |\n+----------------------------------------------------+-----------------------------------------------------------------------+-------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#rename_a_field","title":"Rename a field","text":"<p>Use the <code>AS &lt;alias&gt;</code> syntax to rename a field in the output.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[:serve]-&gt;(v2) \\\n        RETURN v2.team.name AS Team;\n+---------+\n| Team    |\n+---------+\n| \"Spurs\" |\n+---------+\n\nnebula&gt; RETURN \"Amber\" AS Name;\n+---------+\n| Name    |\n+---------+\n| \"Amber\" |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_a_non-existing_property","title":"Return a non-existing property","text":"<p>If a property matched does not exist, <code>NULL</code> is returned.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\n        RETURN v2.player.name, type(e), v2.player.age;\n+-----------------+----------+---------------+\n| v2.player.name  | type(e)  | v2.player.age |\n+-----------------+----------+---------------+\n| \"Manu Ginobili\" | \"follow\" | 41            |\n| __NULL__        | \"serve\"  | __NULL__      |\n| \"Tony Parker\"   | \"follow\" | 36            |\n+-----------------+----------+---------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_expression_results","title":"Return expression results","text":"<p>To return the results of expressions such as literals, functions, or predicates, set them in a <code>RETURN</code> clause.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tony Parker\"})--&gt;(v2:player) \\\n        RETURN DISTINCT v2.player.name, \"Hello\"+\" graphs!\", v2.player.age &gt; 35;\n+---------------------+----------------------+--------------------+\n| v2.player.name      | (\"Hello\"+\" graphs!\") | (v2.player.age&gt;35) |\n+---------------------+----------------------+--------------------+\n| \"LaMarcus Aldridge\" | \"Hello graphs!\"      | false              |\n| \"Tim Duncan\"        | \"Hello graphs!\"      | true               |\n| \"Manu Ginobili\"     | \"Hello graphs!\"      | true               |\n+---------------------+----------------------+--------------------+\n\nnebula&gt; RETURN 1+1;\n+-------+\n| (1+1) |\n+-------+\n| 2     |\n+-------+\n\nnebula&gt; RETURN 1- -1;\n+----------+\n| (1--(1)) |\n+----------+\n| 2        |\n+----------+\n\nnebula&gt; RETURN 3 &gt; 1;\n+-------+\n| (3&gt;1) |\n+-------+\n| true  |\n+-------+\n\nnebula&gt; RETURN 1+1, rand32(1, 5);\n+-------+-------------+\n| (1+1) | rand32(1,5) |\n+-------+-------------+\n| 2     | 1           |\n+-------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_unique_fields","title":"Return unique fields","text":"<p>Use <code>DISTINCT</code> to remove duplicate fields in the result set.</p> <pre><code># Before using DISTINCT.\nnebula&gt; MATCH (v:player{name:\"Tony Parker\"})--(v2:player) \\\n        RETURN v2.player.name, v2.player.age;\n+---------------------+---------------+\n| v2.player.name      | v2.player.age |\n+---------------------+---------------+\n| \"Manu Ginobili\"     | 41            |\n| \"Boris Diaw\"        | 36            |\n| \"Marco Belinelli\"   | 32            |\n| \"Dejounte Murray\"   | 29            |\n| \"Tim Duncan\"        | 42            |\n| \"Tim Duncan\"        | 42            |\n| \"LaMarcus Aldridge\" | 33            |\n| \"LaMarcus Aldridge\" | 33            |\n+---------------------+---------------+\n\n# After using DISTINCT.\nnebula&gt; MATCH (v:player{name:\"Tony Parker\"})--(v2:player) \\\n        RETURN DISTINCT v2.player.name, v2.player.age;\n+---------------------+---------------+\n| v2.player.name      | v2.player.age |\n+---------------------+---------------+\n| \"Manu Ginobili\"     | 41            |\n| \"Boris Diaw\"        | 36            |\n| \"Marco Belinelli\"   | 32            |\n| \"Dejounte Murray\"   | 29            |\n| \"Tim Duncan\"        | 42            |\n| \"LaMarcus Aldridge\" | 33            |\n+---------------------+---------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/sample/","title":"SAMPLE","text":"<p>The <code>SAMPLE</code> clause takes samples evenly in the result set and returns the specified amount of data.</p> <p><code>SAMPLE</code> can be used in <code>GO</code> statements only. The syntax is as follows:</p> <pre><code>&lt;go_statement&gt; SAMPLE &lt;sample_list&gt;;\n</code></pre> <p><code>sample_list</code> is a list. Elements in the list must be natural numbers, and the number of elements must be the same as the maximum number of <code>STEPS</code> in the <code>GO</code> statement. The following takes <code>GO 1 TO 3 STEPS FROM \"A\" OVER * SAMPLE &lt;sample_list&gt;</code> as an example to introduce this usage of <code>SAMPLE</code> in detail.</p> <ul> <li>The list <code>sample_list</code> must contain 3 natural numbers, such as <code>GO 1 TO 3 STEPS FROM \"A\" OVER * SAMPLE [1,2,4]</code>.</li> <li><code>1</code> in <code>SAMPLE [1,2,4]</code> means that the system automatically selects 1 edge to continue traversal in the first step. <code>2</code> means to select 2 edges to continue traversal in the second step. <code>4</code> indicates that 4 edges are selected to continue traversal in the third step. If there is no matched edge in a certain step or the number of matched edges is less than the specified number, the actual number will be returned.</li> <li>Because <code>GO 1 TO 3 STEPS</code> means to return all the traversal results from the first to third steps, all the red edges and their source and destination vertices in the figure below will be matched by this <code>GO</code> statement. And the yellow edges represent there is no path selected when the GO statement traverses. If it is not <code>GO 1 TO 3 STEPS</code> but <code>GO 3 STEPS</code>, it will only match the red edges of the third step and the vertices at both ends.</li> </ul> <p></p> <p>In the basketballplayer dataset, the example is as follows:</p> <pre><code>nebula&gt; GO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        SAMPLE [1,2,3];\n+-----------------+----------+\n| NAME            | Age      |\n+-----------------+----------+\n| \"Tony Parker\"   | 36       |\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n+-----------------+----------+\n\nnebula&gt; GO 1 TO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        SAMPLE [2,2,2];\n+-----------------+----------+\n| NAME            | Age      |\n+-----------------+----------+\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n| \"Tim Duncan\"    | 42       |\n| \"Spurs\"         | __NULL__ |\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n+-----------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/","title":"TTL","text":"<p>TTL (Time To Live) is a mechanism in NebulaGraph that defines the lifespan of data. Once the data reaches its predefined lifespan, it is automatically deleted from the database. This feature is particularly suitable for data that only needs temporary storage, such as temporary sessions or cached data.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#precautions","title":"Precautions","text":"<ul> <li>You CANNOT modify a property schema with TTL options on it.</li> </ul> <ul> <li> <p>TTL options and indexes have coexistence issues.</p> <ul> <li>TTL options and indexes CANNOT coexist on a tag or an edge type. If there is an index on a property, you cannot set TTL options on other properties.</li> </ul> <ul> <li>If there are TTL options on a tag, an edge type, or a property, you can still add an index on them.</li> </ul> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#ttl_options","title":"TTL options","text":"<p>The native nGQL TTL feature has the following options.</p> Option Description <code>ttl_col</code> Specifies an existing property to set a lifespan on. The data type of the property must be <code>int</code> or <code>timestamp</code>. <code>ttl_duration</code> Specifies the timeout adds-on value in seconds. The value must be a non-negative int64 number. A property expires if the sum of its value and the <code>ttl_duration</code> value is smaller than the current timestamp. If the <code>ttl_duration</code> value is <code>0</code>, the property never expires.You can set <code>ttl_use_ms</code> to <code>true</code> in the configuration file <code>nebula-storaged.conf</code> (default path: <code>/usr/local/nightly/etc/</code>) to set the default unit to milliseconds. <p>Caution</p> <ul> <li>Before setting <code>ttl_use_ms</code> to <code>true</code>, make sure that no TTL has been set for any property, as shortening the expiration time may cause data to be erroneously deleted.</li> </ul> <ul> <li>After setting <code>ttl_use_ms</code> to <code>true</code>, which sets the default TTL unit to milliseconds, the data type of the property specified by <code>ttl_col</code> must be <code>int</code>, and the property value needs to be manually converted to milliseconds. For example, when setting <code>ttl_col</code> to <code>a</code>, you need to convert the value of <code>a</code> to milliseconds, such as when the value of <code>a</code> is <code>now()</code>, you need to set the value of <code>a</code> to <code>now() * 1000</code>.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#use_ttl_options","title":"Use TTL options","text":"<p>You must use the TTL options together to set a lifespan on a property.</p> <p>Before using the TTL feature, you must first create a timestamp or integer property and specify it in the TTL options. NebulaGraph will not automatically create or manage this timestamp property for you.</p> <p>When inserting the value of the timestamp or integer property, it is recommended to use the <code>now()</code> function or the current timestamp to represent the present time.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#set_a_timeout_if_a_tag_or_an_edge_type_exists","title":"Set a timeout if a tag or an edge type exists","text":"<p>If a tag or an edge type is already created, to set a timeout on a property bound to the tag or edge type, use <code>ALTER</code> to update the tag or edge type.</p> <pre><code># Create a tag.\nnebula&gt; CREATE TAG IF NOT EXISTS t1 (a timestamp);\n\n# Use ALTER to update the tag and set the TTL options.\nnebula&gt; ALTER TAG t1 TTL_COL = \"a\", TTL_DURATION = 5;\n\n# Insert a vertex with tag t1. The vertex expires 5 seconds after the insertion.\nnebula&gt; INSERT VERTEX t1(a) VALUES \"101\":(now());\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#set_a_timeout_when_creating_a_tag_or_an_edge_type","title":"Set a timeout when creating a tag or an edge type","text":"<p>Use TTL options in the <code>CREATE</code> statement to set a timeout when creating a tag or an edge type. For more information, see CREATE TAG and CREATE EDGE.</p> <pre><code># Create a tag and set the TTL options.\nnebula&gt; CREATE TAG IF NOT EXISTS t2(a int, b int, c string) TTL_DURATION= 100, TTL_COL = \"a\";\n\n# Insert a vertex with tag t2. The timeout timestamp is 1648197238 (1648197138 + 100).\nnebula&gt; INSERT VERTEX t2(a, b, c) VALUES \"102\":(1648197138, 30, \"Hello\");\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#data_expiration_and_deletion","title":"Data expiration and deletion","text":"<p>Caution</p> <ul> <li>When the TTL options are set for a property of a tag or an edge type and the property's value is <code>NULL</code>, the property never expires. </li> <li>If a property with a default value of <code>now()</code> is added to a tag or an edge type and the TTL options are set for the property, the history data related to the tag or the edge type will never expire because the value of that property for the history data is the current timestamp.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#vertex_property_expiration","title":"Vertex property expiration","text":"<p>Vertex property expiration has the following impact.</p> <ul> <li>If a vertex has only one tag, once a property of the vertex expires, the vertex expires.</li> </ul> <ul> <li>If a vertex has multiple tags, once a property of the vertex expires, properties bound to the same tag with the expired property also expire, but the vertex does not expire and other properties of it remain untouched.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#edge_property_expiration","title":"Edge property expiration","text":"<p>Since an edge can have only one edge type, once an edge property expires, the edge expires.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#data_deletion","title":"Data deletion","text":"<p>The expired data are still stored on the disk, but queries will filter them out.</p> <p>NebulaGraph automatically deletes the expired data and reclaims the disk space during the next compaction.</p> <p>Note</p> <p>If TTL is disabled, the corresponding data deleted after the last compaction can be queried again.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#remove_a_timeout","title":"Remove a timeout","text":"<p>To disable TTL and remove the timeout on a property, you can use the following approaches.</p> <ul> <li>Drop the property with the timeout.<pre><code>nebula&gt; ALTER TAG t1 DROP (a);\n</code></pre> </li> </ul> <ul> <li>Set <code>ttl_col</code> to an empty string.<pre><code>nebula&gt; ALTER TAG t1 TTL_COL = \"\";\n</code></pre> </li> </ul> <ul> <li>Set <code>ttl_duration</code> to <code>0</code>. This operation keeps the TTL options and prevents the property from expiring and the property schema from being modified.<pre><code>nebula&gt; ALTER TAG t1 TTL_DURATION = 0;\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/","title":"UNWIND","text":"<p><code>UNWIND</code> transform a list into a sequence of rows.</p> <p><code>UNWIND</code> can be used as an individual statement or as a clause within a statement.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#unwind_statement","title":"UNWIND statement","text":""},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#syntax","title":"Syntax","text":"<pre><code>UNWIND &lt;list&gt; AS &lt;alias&gt; &lt;RETURN clause&gt;;\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#examples","title":"Examples","text":"<ul> <li> <p>To transform a list.</p> <pre><code>nebula&gt; UNWIND [1,2,3] AS n RETURN n;\n+---+\n| n |\n+---+\n| 1 |\n| 2 |\n| 3 |\n+---+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#unwind_clause","title":"UNWIND clause","text":""},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#syntax_1","title":"Syntax","text":"<ul> <li> <p>The <code>UNWIND</code> clause in native nGQL statements.</p> <p>Note</p> <p>To use a <code>UNWIND</code> clause in a native nGQL statement, use it after the <code>|</code> operator and use the <code>$-</code> prefix for variables. If you use a statement or clause after the <code>UNWIND</code> clause, use the <code>|</code> operator and use the <code>$-</code> prefix for variables.</p> <pre><code>&lt;statement&gt; | UNWIND $-.&lt;var&gt; AS &lt;alias&gt; &lt;|&gt; &lt;clause&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>The <code>UNWIND</code> clause in openCypher statements.</p> <pre><code>&lt;statement&gt; UNWIND &lt;list&gt; AS &lt;alias&gt; &lt;RETURN clause&gt;\uff1b\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#examples_1","title":"Examples","text":"<ul> <li> <p>To transform a list of duplicates into a unique set of rows using <code>WITH DISTINCT</code> in a <code>UNWIND</code> clause.</p> <p>Note</p> <p><code>WITH DISTINCT</code> is not available in native nGQL statements.  </p> <pre><code>// Transform the list `[1,1,2,2,3,3]` into a unique set of rows, sort the rows, and then transform the rows into a list of unique values.\n\nnebula&gt; WITH [1,1,2,2,3,3] AS n \\\n        UNWIND n AS r \\\n        WITH DISTINCT r AS r \\\n        ORDER BY r \\\n        RETURN collect(r);\n+------------+\n| collect(r) |\n+------------+\n| [1, 2, 3]  |\n+------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>MATCH</code> statement.</p> <pre><code>// Get a list of the vertices in the matched path, transform the list into a unique set of rows, and then transform the rows into a list. \n\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--(v2) \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS r \\\n        WITH DISTINCT r AS r \\\n        RETURN collect(r);\n+----------------------------------------------------------------------------------------------------------------------+\n| collect(r)                                                                                                           |\n+----------------------------------------------------------------------------------------------------------------------+\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player101\" :player{age: 36, name: \"Tony Parker\"}),            |\n|(\"team204\" :team{name: \"Spurs\"}), (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}),                          |\n|(\"player125\" :player{age: 41, name: \"Manu Ginobili\"}), (\"player104\" :player{age: 32, name: \"Marco Belinelli\"}),       |\n|(\"player144\" :player{age: 47, name: \"Shaquile O'Neal\"}), (\"player105\" :player{age: 31, name: \"Danny Green\"}),         |\n|(\"player113\" :player{age: 29, name: \"Dejounte Murray\"}), (\"player107\" :player{age: 32, name: \"Aron Baynes\"}),         |\n|(\"player109\" :player{age: 34, name: \"Tiago Splitter\"}), (\"player108\" :player{age: 36, name: \"Boris Diaw\"})]           |  \n+----------------------------------------------------------------------------------------------------------------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>GO</code> statement.</p> <pre><code>// Query the vertices in a list for the corresponding edges with a specified statement.\n\nnebula&gt; YIELD ['player101', 'player100'] AS a | UNWIND $-.a AS  b | GO FROM $-.b OVER follow YIELD edge AS e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}] |\n| [:follow \"player101\"-&gt;\"player102\" @0 {degree: 90}] |\n| [:follow \"player101\"-&gt;\"player125\" @0 {degree: 95}] |\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}] |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}] |\n+----------------------------------------------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>LOOKUP</code> statement.</p> <pre><code>// Find all the properties of players whose age is greater than 46, get a list of unique properties, and then transform the list into rows. \n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.age &gt; 46 \\\n        YIELD DISTINCT keys(vertex) as p | UNWIND $-.p as a | YIELD $-.a AS a;\n+--------+\n| a      |\n+--------+\n| \"age\"  |\n| \"name\" |\n+--------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>FETCH</code> statement. </p> <pre><code>// Query player101 for all tags related to player101, get a list of the tags and then transform the list into rows.\n\nnebula&gt; CREATE TAG hero(like string, height int);\n        INSERT VERTEX hero(like, height) VALUES \"player101\":(\"deep\", 182);\n        FETCH PROP ON * \"player101\" \\\n        YIELD tags(vertex) as t | UNWIND $-.t as a | YIELD $-.a AS a;\n+----------+\n| a        |\n+----------+\n| \"hero\"   |\n| \"player\" |\n+----------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>GET SUBGRAPH</code> statement. </p> <pre><code>// Get the subgraph including outgoing and incoming serve edges within 0~2 hops from/to player100, and transform the result into rows.\n\nnebula&gt; GET SUBGRAPH 2 STEPS FROM \"player100\" BOTH serve \\\n        YIELD edges as e | UNWIND $-.e as a | YIELD $-.a AS a;\n+----------------------------------------------+\n| a                                            |\n+----------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player101\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player102\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player103\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player105\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player106\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player107\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player108\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player109\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player110\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player111\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player112\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player113\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player114\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player125\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player138\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player104\"-&gt;\"team204\" @20132015 {}] |\n| [:serve \"player104\"-&gt;\"team204\" @20182019 {}] |\n+----------------------------------------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>FIND PATH</code> statement.</p> <pre><code>// Find all the vertices in the shortest path from player101 to team204 along the serve edge, and transform the result into rows. \n\nnebula&gt; FIND SHORTEST PATH FROM \"player101\" TO \"team204\" OVER serve \\\n        YIELD path as p | YIELD nodes($-.p) AS nodes | UNWIND $-.nodes AS a | YIELD $-.a AS a;\n+---------------+\n| a             |\n+---------------+\n| (\"player101\") |\n| (\"team204\")   |\n+---------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/where/","title":"WHERE","text":"<p>The <code>WHERE</code> clause filters the output by conditions.</p> <p>The <code>WHERE</code> clause usually works in the following queries:</p> <ul> <li>Native nGQL: such as <code>GO</code> and <code>LOOKUP</code>.</li> </ul> <ul> <li>OpenCypher syntax: such as <code>MATCH</code> and <code>WITH</code>.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Filtering on edge rank is a native nGQL feature. To retrieve the rank value in openCypher statements, use the rank() function, such as <code>MATCH (:player)-[e:follow]-&gt;() RETURN rank(e);</code>.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#basic_usage","title":"Basic usage","text":"<p>Note</p> <p>In the following examples, <code>$$</code> and <code>$^</code> are reference operators. For more information, see Operators.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#define_conditions_with_boolean_operators","title":"Define conditions with boolean operators","text":"<p>Use the boolean operators <code>NOT</code>, <code>AND</code>, <code>OR</code>, and <code>XOR</code> to define conditions in <code>WHERE</code> clauses. For the precedence of the operators, see Precedence.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name == \"Tim Duncan\" \\\n        XOR (v.player.age &lt; 30 AND v.player.name == \"Yao Ming\") \\\n        OR NOT (v.player.name == \"Yao Ming\" OR v.player.name == \"Tim Duncan\") \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Danny Green\"           | 31           |\n| \"Tiago Splitter\"        | 34           |\n| \"David West\"            | 38           |\n...\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" \\\n        OVER follow \\\n        WHERE properties(edge).degree &gt; 90 \\\n        OR properties($$).age != 33 \\\n        AND properties($$).name != \"Tony Parker\" \\\n        YIELD properties($$);\n+----------------------------------+\n| properties($$)                   |\n+----------------------------------+\n| {age: 41, name: \"Manu Ginobili\"} |\n+----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_properties","title":"Filter on properties","text":"<p>Use vertex or edge properties to define conditions in <code>WHERE</code> clauses.</p> <ul> <li>Filter on a vertex property:<pre><code>nebula&gt; MATCH (v:player)-[e]-&gt;(v2) \\\n        WHERE v2.player.age &lt; 25 \\\n        RETURN v2.player.name, v2.player.age;\n+----------------------+---------------+\n| v2.player.name       | v2.player.age |\n+----------------------+---------------+\n| \"Ben Simmons\"        | 22            |\n| \"Luka Doncic\"        | 20            |\n| \"Kristaps Porzingis\" | 23            |\n+----------------------+---------------+\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        WHERE $^.player.age &gt;= 42 \\\n        YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n+-------------+\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre> </li> </ul> <ul> <li>Filter on an edge property:<pre><code>nebula&gt; MATCH (v:player)-[e]-&gt;() \\\n        WHERE e.start_year &lt; 2000 \\\n        RETURN DISTINCT v.player.name, v.player.age;\n+--------------------+--------------+\n| v.player.name      | v.player.age |\n+--------------------+--------------+\n| \"Tony Parker\"      | 36           |\n| \"Tim Duncan\"       | 42           |\n| \"Grant Hill\"       | 46           |\n...\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        WHERE follow.degree &gt; 90 \\\n        YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_dynamically-calculated_properties","title":"Filter on dynamically-calculated properties","text":"<pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v[toLower(\"AGE\")] &lt; 21 \\\n        RETURN v.player.name, v.player.age;\n+---------------+-------+\n| v.name        | v.age |\n+---------------+-------+\n| \"Luka Doncic\" | 20    |\n+---------------+-------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_existing_properties","title":"Filter on existing properties","text":"<pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE exists(v.player.age) \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Danny Green\"           | 31           |\n| \"Tiago Splitter\"        | 34           |\n| \"David West\"            | 38           |\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_edge_rank","title":"Filter on edge rank","text":"<p>In nGQL, if a group of edges has the same source vertex, destination vertex, and properties, the only thing that distinguishes them is the rank. Use rank conditions in <code>WHERE</code> clauses to filter such edges.</p> <pre><code># The following example creates test data.\nnebula&gt; CREATE SPACE IF NOT EXISTS test (vid_type=FIXED_STRING(30));\nnebula&gt; USE test;\nnebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 int);\nnebula&gt; CREATE TAG IF NOT EXISTS person(p1 int);\nnebula&gt; INSERT VERTEX person(p1) VALUES \"1\":(1);\nnebula&gt; INSERT VERTEX person(p1) VALUES \"2\":(2);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@0:(10);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@1:(11);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@2:(12);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@3:(13);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@4:(14);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@5:(15);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@6:(16);\n\n# The following example use rank to filter edges and retrieves edges with a rank greater than 2.\nnebula&gt; GO FROM \"1\" \\\n        OVER e1 \\\n        WHERE rank(edge) &gt; 2 \\\n        YIELD src(edge), dst(edge), rank(edge) AS Rank, properties(edge).p1 | \\\n        ORDER BY $-.Rank DESC;\n+-----------+-----------+------+---------------------+\n| src(EDGE) | dst(EDGE) | Rank | properties(EDGE).p1 |\n+-----------+-----------+------+---------------------+\n| \"1\"       | \"2\"       | 6    | 16                  |\n| \"1\"       | \"2\"       | 5    | 15                  |\n| \"1\"       | \"2\"       | 4    | 14                  |\n| \"1\"       | \"2\"       | 3    | 13                  |\n+-----------+-----------+------+---------------------+\n\n# Filter edges by rank. Find follow edges with rank equal to 0.\nnebula&gt; MATCH (v)-[e:follow]-&gt;() \\\n         WHERE rank(e)==0 \\\n         RETURN *;\n+------------------------------------------------------------+-----------------------------------------------------+\n| v                                                          | e                                                   |\n+------------------------------------------------------------+-----------------------------------------------------+\n| (\"player142\" :player{age: 29, name: \"Klay Thompson\"})      | [:follow \"player142\"-&gt;\"player117\" @0 {degree: 90}]  |\n| (\"player139\" :player{age: 34, name: \"Marc Gasol\"})         | [:follow \"player139\"-&gt;\"player138\" @0 {degree: 99}]  |\n| (\"player108\" :player{age: 36, name: \"Boris Diaw\"})         | [:follow \"player108\"-&gt;\"player100\" @0 {degree: 80}]  |\n| (\"player108\" :player{age: 36, name: \"Boris Diaw\"})         | [:follow \"player108\"-&gt;\"player101\" @0 {degree: 80}]  |\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_pattern","title":"Filter on pattern","text":"<pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(t) \\\n        WHERE (v)-[e]-&gt;(t:team) \\\n        RETURN (v)--&gt;();\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| (v)--&gt;() = (v)--&gt;()                                                                                                                                                                                                                                                                                                                                                                                              |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [&lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;] |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(t) \\\n        WHERE NOT (v)-[e]-&gt;(t:team) \\\n        RETURN (v)--&gt;();\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| (v)--&gt;() = (v)--&gt;()                                                                                                                                                                                                                                                                                                                                                                                              |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [&lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;] |\n| [&lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;] |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_strings","title":"Filter on strings","text":"<p>Use <code>STARTS WITH</code>, <code>ENDS WITH</code>, or <code>CONTAINS</code> in <code>WHERE</code> clauses to match a specific part of a string. String matching is case-sensitive.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#starts_with","title":"<code>STARTS WITH</code>","text":"<p><code>STARTS WITH</code> will match the beginning of a string.</p> <p>The following example uses <code>STARTS WITH \"T\"</code> to retrieve the information of players whose name starts with <code>T</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name STARTS WITH \"T\" \\\n        RETURN v.player.name, v.player.age;\n+------------------+--------------+\n| v.player.name    | v.player.age |\n+------------------+--------------+\n| \"Tony Parker\"    | 36           |\n| \"Tiago Splitter\" | 34           |\n| \"Tim Duncan\"     | 42           |\n| \"Tracy McGrady\"  | 39           |\n+------------------+--------------+\n</code></pre> <p>If you use <code>STARTS WITH \"t\"</code> in the preceding statement, an empty set is returned because no name in the dataset starts with the lowercase <code>t</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name STARTS WITH \"t\" \\\n        RETURN v.player.name, v.player.age;\n+---------------+--------------+\n| v.player.name | v.player.age |\n+---------------+--------------+\n+---------------+--------------+\nEmpty set (time spent 5080/6474 us)\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#ends_with","title":"<code>ENDS WITH</code>","text":"<p><code>ENDS WITH</code> will match the ending of a string.</p> <p>The following example uses <code>ENDS WITH \"r\"</code> to retrieve the information of players whose name ends with <code>r</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name ENDS WITH \"r\" \\\n        RETURN v.player.name, v.player.age;\n+------------------+--------------+\n| v.player.name    | v.player.age |\n+------------------+--------------+\n| \"Tony Parker\"    | 36           |\n| \"Tiago Splitter\" | 34           |\n| \"Vince Carter\"   | 42           |\n+------------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#contains","title":"<code>CONTAINS</code>","text":"<p><code>CONTAINS</code> will match a certain part of a string.</p> <p>The following example uses <code>CONTAINS \"Pa\"</code> to match the information of players whose name contains <code>Pa</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name CONTAINS \"Pa\" \\\n        RETURN v.player.name, v.player.age;\n+---------------+--------------+\n| v.player.name | v.player.age |\n+---------------+--------------+\n| \"Paul George\" | 28           |\n| \"Tony Parker\" | 36           |\n| \"Paul Gasol\"  | 38           |\n| \"Chris Paul\"  | 33           |\n+---------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#negative_string_matching","title":"Negative string matching","text":"<p>You can use the boolean operator <code>NOT</code> to negate a string matching condition.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE NOT v.player.name ENDS WITH \"R\" \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Danny Green\"           | 31           |\n| \"Tiago Splitter\"        | 34           |\n| \"David West\"            | 38           |\n| \"Russell Westbrook\"     | 30           |\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_lists","title":"Filter on lists","text":""},{"location":"3.ngql-guide/8.clauses-and-options/where/#match_values_in_a_list","title":"Match values in a list","text":"<p>Use the <code>IN</code> operator to check if a value is in a specific list.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.age IN range(20,25) \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Ben Simmons\"           | 22           |\n| \"Giannis Antetokounmpo\" | 24           |\n| \"Kyle Anderson\"         | 25           |\n| \"Joel Embiid\"           | 25           |\n| \"Kristaps Porzingis\"    | 23           |\n| \"Luka Doncic\"           | 20           |\n+-------------------------+--------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.age IN [25,28]  \\\n        YIELD properties(vertex).name, properties(vertex).age;\n+-------------------------+------------------------+\n| properties(VERTEX).name | properties(VERTEX).age |\n+-------------------------+------------------------+\n| \"Kyle Anderson\"         | 25                     |\n| \"Damian Lillard\"        | 28                     |\n| \"Joel Embiid\"           | 25                     |\n| \"Paul George\"           | 28                     |\n| \"Ricky Rubio\"           | 28                     |\n+-------------------------+------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#match_values_not_in_a_list","title":"Match values not in a list","text":"<p>Use <code>NOT</code> before <code>IN</code> to rule out the values in a list.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.age NOT IN range(20,25) \\\n        RETURN v.player.name AS Name, v.player.age AS Age \\\n        ORDER BY Age;\n+---------------------+-----+\n| Name                | Age |\n+---------------------+-----+\n| \"Kyrie Irving\"      | 26  |\n| \"Cory Joseph\"       | 27  |\n| \"Damian Lillard\"    | 28  |\n| \"Paul George\"       | 28  |\n| \"Ricky Rubio\"       | 28  |\n+---------------------+-----+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/","title":"WITH","text":"<p>The <code>WITH</code> clause can retrieve the output from a query part, process it, and pass it to the next query part as the input.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to openCypher syntax only.</p> <p>Note</p> <p><code>WITH</code> has a similar function with the Pipe symbol in native nGQL, but they work in different ways. DO NOT use pipe symbols in the openCypher syntax or use <code>WITH</code> in native nGQL statements.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#combine_statements_and_form_a_composite_query","title":"Combine statements and form a composite query","text":"<p>Use a <code>WITH</code> clause to combine statements and transfer the output of a statement as the input of another statement.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#example_1","title":"Example 1","text":"<p>The following statement:</p> <ol> <li>Matches a path.</li> <li>Outputs all the vertices on the path to a list with the <code>nodes()</code> function.</li> <li>Unwinds the list into rows.</li> <li>Removes duplicated vertices and returns a set of distinct vertices.</li> </ol> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--() \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS n1 \\\n        RETURN DISTINCT n1;\n+-----------------------------------------------------------+\n| n1                                                        |\n+-----------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"team204\" :team{name: \"Spurs\"})                          |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player104\" :player{age: 32, name: \"Marco Belinelli\"})   |\n| (\"player144\" :player{age: 47, name: \"Shaquille O'Neal\"})  |\n| (\"player105\" :player{age: 31, name: \"Danny Green\"})       |\n| (\"player113\" :player{age: 29, name: \"Dejounte Murray\"})   |\n| (\"player107\" :player{age: 32, name: \"Aron Baynes\"})       |\n| (\"player109\" :player{age: 34, name: \"Tiago Splitter\"})    |\n| (\"player108\" :player{age: 36, name: \"Boris Diaw\"})        |\n+-----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#example_2","title":"Example 2","text":"<p>The following statement:</p> <ol> <li>Matches the vertex with the VID <code>player100</code>.</li> <li>Outputs all the tags of the vertex into a list with the <code>labels()</code> function.</li> <li>Unwinds the list into rows.</li> <li>Returns the output.</li> </ol> <pre><code>nebula&gt; MATCH (v) \\\n        WHERE id(v)==\"player100\" \\\n        WITH labels(v) AS tags_unf \\\n        UNWIND tags_unf AS tags_f \\\n        RETURN tags_f;\n+----------+\n| tags_f   |\n+----------+\n| \"player\" |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#filter_composite_queries","title":"Filter composite queries","text":"<p><code>WITH</code> can work as a filter in the middle of a composite query.</p> <pre><code>nebula&gt; MATCH (v:player)--&gt;(v2:player) \\\n        WITH DISTINCT v2 AS v2, v2.player.age AS Age \\\n        ORDER BY Age \\\n        WHERE Age&lt;25 \\\n        RETURN v2.player.name AS Name, Age;\n+----------------------+-----+\n| Name                 | Age |\n+----------------------+-----+\n| \"Luka Doncic\"        | 20  |\n| \"Ben Simmons\"        | 22  |\n| \"Kristaps Porzingis\" | 23  |\n+----------------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#process_the_output_before_using_collect","title":"Process the output before using collect()","text":"<p>Use a <code>WITH</code> clause to sort and limit the output before using <code>collect()</code> to transform the output into a list.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WITH v.player.name AS Name \\\n        ORDER BY Name DESC \\\n        LIMIT 3 \\\n        RETURN collect(Name);\n+-----------------------------------------------+\n| collect(Name)                                 |\n+-----------------------------------------------+\n| [\"Yao Ming\", \"Vince Carter\", \"Tracy McGrady\"] |\n+-----------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#use_with_return","title":"Use with RETURN","text":"<p>Set an alias using a <code>WITH</code> clause, and then output the result through a <code>RETURN</code> clause.</p> <pre><code>nebula&gt; WITH [1, 2, 3] AS `list` RETURN 3 IN `list` AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; WITH 4 AS one, 3 AS two RETURN one &gt; two AS result;\n+--------+\n| result |\n+--------+\n| true   |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/","title":"YIELD","text":"<p><code>YIELD</code> defines the output of an nGQL query.</p> <p><code>YIELD</code> can lead a clause or a statement:</p> <ul> <li>A <code>YIELD</code> clause works in nGQL statements such as <code>GO</code>, <code>FETCH</code>, or <code>LOOKUP</code> and must be defined to return the result.</li> </ul> <ul> <li>A <code>YIELD</code> statement works in a composite query or independently.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to native nGQL only. For the openCypher syntax, use <code>RETURN</code>.</p> <p><code>YIELD</code> has different functions in openCypher and nGQL.</p> <ul> <li> <p>In openCypher, <code>YIELD</code> is used in the <code>CALL[\u2026YIELD]</code> clause to specify the output of the procedure call.</p> <p>Note</p> <p>NGQL does not support <code>CALL[\u2026YIELD]</code> yet.</p> </li> </ul> <ul> <li>In nGQL, <code>YIELD</code> works like <code>RETURN</code> in openCypher.</li> </ul> <p>Note</p> <p>In the following examples, <code>$$</code> and <code>$-</code> are reference operators. For more information, see Operators.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#yield_clauses","title":"YIELD clauses","text":""},{"location":"3.ngql-guide/8.clauses-and-options/yield/#syntax","title":"Syntax","text":"<pre><code>YIELD [DISTINCT] &lt;col&gt; [AS &lt;alias&gt;] [, &lt;col&gt; [AS &lt;alias&gt;] ...];\n</code></pre> Parameter Description <code>DISTINCT</code> Aggregates the output and makes the statement return a distinct result set. <code>col</code> A field to be returned. If no alias is set, <code>col</code> will be a column name in the output. <code>alias</code> An alias for <code>col</code>. It is set after the keyword <code>AS</code> and will be a column name in the output."},{"location":"3.ngql-guide/8.clauses-and-options/yield/#use_a_yield_clause_in_a_statement","title":"Use a YIELD clause in a statement","text":"<ul> <li>Use <code>YIELD</code> with <code>GO</code>:<pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Friend, properties($$).age AS Age;\n+-----------------+-----+\n| Friend          | Age |\n+-----------------+-----+\n| \"Tony Parker\"   | 36  |\n| \"Manu Ginobili\" | 41  |\n+-----------------+-----+\n</code></pre> </li> </ul> <ul> <li>Use <code>YIELD</code> with <code>FETCH</code>:<pre><code>nebula&gt; FETCH PROP ON player \"player100\" \\\n        YIELD properties(vertex).name;\n+-------------------------+\n| properties(VERTEX).name |\n+-------------------------+\n| \"Tim Duncan\"            |\n+-------------------------+\n</code></pre> </li> </ul> <ul> <li>Use <code>YIELD</code> with <code>LOOKUP</code>:<pre><code>nebula&gt; LOOKUP ON player WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name, properties(vertex).age;\n+-------------------------+------------------------+\n| properties(VERTEX).name | properties(VERTEX).age |\n+-------------------------+------------------------+\n| \"Tony Parker\"           | 36                     |\n+-------------------------+------------------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#yield_statements","title":"YIELD statements","text":""},{"location":"3.ngql-guide/8.clauses-and-options/yield/#syntax_1","title":"Syntax","text":"<pre><code>YIELD [DISTINCT] &lt;col&gt; [AS &lt;alias&gt;] [, &lt;col&gt; [AS &lt;alias&gt;] ...]\n[WHERE &lt;conditions&gt;];\n</code></pre> Parameter Description <code>DISTINCT</code> Aggregates the output and makes the statement return a distinct result set. <code>col</code> A field to be returned. If no alias is set, <code>col</code> will be a column name in the output. <code>alias</code> An alias for <code>col</code>. It is set after the keyword <code>AS</code> and will be a column name in the output. <code>conditions</code> Conditions set in a <code>WHERE</code> clause to filter the output. For more information, see <code>WHERE</code>."},{"location":"3.ngql-guide/8.clauses-and-options/yield/#use_a_yield_statement_in_a_composite_query","title":"Use a YIELD statement in a composite query","text":"<p>In a composite query, a <code>YIELD</code> statement accepts, filters, and modifies the result set of the preceding statement, and then outputs it.</p> <p>The following query finds the players that \"player100\" follows and calculates their average age.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS ID \\\n        | FETCH PROP ON player $-.ID \\\n        YIELD properties(vertex).age AS Age \\\n        | YIELD AVG($-.Age) as Avg_age, count(*)as Num_friends;\n+---------+-------------+\n| Avg_age | Num_friends |\n+---------+-------------+\n| 38.5    | 2           |\n+---------+-------------+\n</code></pre> <p>The following query finds the players that \"player101\" follows with the follow degrees greater than 90.</p> <pre><code>nebula&gt; $var1 = GO FROM \"player101\" OVER follow \\\n        YIELD properties(edge).degree AS Degree, dst(edge) as ID; \\\n        YIELD $var1.ID AS ID WHERE $var1.Degree &gt; 90;\n+-------------+\n| ID          |\n+-------------+\n| \"player100\" |\n| \"player125\" |\n+-------------+\n</code></pre> <p>The following query finds the vertices in the player that are older than 30 and younger than 32, and returns the de-duplicate results.</p> <pre><code>nebula&gt; LOOKUP ON player  \\\n        WHERE player.age &lt; 32 and player.age &gt;30  \\\n        YIELD DISTINCT properties(vertex).age as v;\n+--------+\n| v      |\n+--------+\n| 31     |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#use_a_standalone_yield_statement","title":"Use a standalone YIELD statement","text":"<p>A <code>YIELD</code> statement can calculate a valid expression and output the result.</p> <pre><code>nebula&gt; YIELD rand32(1, 6);\n+-------------+\n| rand32(1,6) |\n+-------------+\n| 3           |\n+-------------+\n\nnebula&gt; YIELD \"Hel\" + \"\\tlo\" AS string1, \", World!\" AS string2;\n+-------------+------------+\n| string1     | string2    |\n+-------------+------------+\n| \"Hel    lo\" | \", World!\" |\n+-------------+------------+\n\nnebula&gt; YIELD hash(\"Tim\") % 100;\n+-----------------+\n| (hash(Tim)%100) |\n+-----------------+\n| 42              |\n+-----------------+\n\nnebula&gt; YIELD \\\n      CASE 2+3 \\\n      WHEN 4 THEN 0 \\\n      WHEN 5 THEN 1 \\\n      ELSE -1 \\\n      END \\\n      AS result;\n+--------+\n| result |\n+--------+\n| 1      |\n+--------+\n\nnebula&gt; YIELD 1- -1;\n+----------+\n| (1--(1)) |\n+----------+\n| 2        |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/","title":"CREATE SPACE","text":"<p>Graph spaces are used to store data in a physically isolated way in NebulaGraph, which is similar to the database concept in MySQL. The <code>CREATE SPACE</code> statement can create a new graph space or clone the schema of an existing graph space.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#prerequisites","title":"Prerequisites","text":"<p>Only the God role can use the <code>CREATE SPACE</code> statement. For more information, see AUTHENTICATION.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#syntax","title":"Syntax","text":""},{"location":"3.ngql-guide/9.space-statements/1.create-space/#create_graph_spaces","title":"Create graph spaces","text":"<pre><code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; (\n    [partition_num = &lt;partition_number&gt;,]\n    [replica_factor = &lt;replica_number&gt;,]\n    vid_type = {FIXED_STRING(&lt;N&gt;) | INT[64]}\n    )\n    [COMMENT = '&lt;comment&gt;']\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the related graph space exists. If it does not exist, a new one will be created. The graph space existence detection here only compares the graph space name (excluding properties). <code>&lt;graph_space_name&gt;</code> 1. Uniquely identifies a graph space in a NebulaGraph instance. 2. Space names cannot be modified after they are set. 3. Space names cannot start with a number; they support 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc., but do not include special characters other than underscores. To use special characters, reserved keywords or starting with a number, quote them with backticks (`) and cannot use periods (<code>.</code>). For more information, see Keywords and reserved words. Note: If you name a space in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). <code>partition_num</code> Specifies the number of partitions in each replica. The suggested value is 20 times (2 times for HDD) the number of the hard disks in the cluster. For example, if you have three hard disks in the cluster, we recommend that you set 60 partitions. The default value is 100. <code>replica_factor</code> Specifies the number of replicas in the cluster. The suggested number is 3 in a production environment and 1 in a test environment. The replica number must be an odd number for the need of quorum-based voting. The default value is 1. <code>vid_type</code> A required parameter. Specifies the VID type in a graph space. Available values are <code>FIXED_STRING(N)</code> and <code>INT64</code>. <code>INT</code> equals to <code>INT64</code>. <code>`FIXED_STRING(&lt;N&gt;)</code> specifies the VID as a string, while <code>INT64</code> specifies it as an integer. <code>N</code> represents the maximum length of the VIDs. If you set a VID that is longer than <code>N</code> bytes, NebulaGraph throws an error. Note, for UTF-8 chars, the length may vary in different cases, i.e. a UTF-8 Chinese char is 3 byte, this means 11 Chinese chars(length-33) will exeed a FIXED_STRING(32) vid defination. <code>COMMENT</code> The remarks of the graph space. The maximum length is 256 bytes. By default, there is no comments on a space. <p>Caution</p> <ul> <li>If the replica number is set to one, you will not be able to load balance or scale out the NebulaGraph Storage Service with the SUBMIT JOB BALANCE statement.</li> </ul> <ul> <li> <p>Restrictions on VID type change and VID length:</p> <ul> <li>For NebulaGraph v1.x, the type of VIDs can only be <code>INT64</code>, and the String type is not allowed. For NebulaGraph v2.x, both <code>INT64</code> and <code>FIXED_STRING(&lt;N&gt;)</code> VID types are allowed. You must specify the VID type when creating a graph space, and use the same VID type in <code>INSERT</code> statements, otherwise, an error message <code>Wrong vertex id type: 1001</code> occurs.</li> </ul> <ul> <li>The length of the VID should not be longer than <code>N</code> characters. If it exceeds <code>N</code>, NebulaGraph throws <code>The VID must be a 64-bit integer or a string fitting space vertex id length limit.</code>.</li> </ul> </li> </ul> <ul> <li> <p>If the <code>Host not enough!</code> error appears, the immediate cause is that the number of online storage hosts is less than the value of <code>replica_factor</code> specified when creating a graph space. In this case, you can use the <code>SHOW HOSTS</code> command to see if the following situations occur:</p> <ul> <li>For the case where there is only one storage host in a cluster, the value of <code>replica_factor</code> can only be specified to <code>1</code>. Or create a graph space after storage hosts are scaled out. </li> </ul> <ul> <li>A new storage host is found, but <code>ADD HOSTS</code> is not executed to activate it. In this case, run <code>SHOW HOSTS</code> to locate the new storage host information and then run <code>ADD HOSTS</code> to activate it. A graph space can be created after there are enough storage hosts.</li> </ul> <ul> <li>For offline storage hosts after running <code>SHOW HOSTS</code>, troubleshooting is needed.</li> </ul> </li> </ul> <p>Legacy version compatibility</p> <p>For NebulaGraph v2.x before v2.5.0, <code>vid_type</code> is optional and defaults to <code>FIXED_STRING(8)</code>.</p> <p>Note</p> <p><code>graph_space_name</code>, <code>partition_num</code>, <code>replica_factor</code>, <code>vid_type</code>, and <code>comment</code> cannot be modified once set. To modify them, drop the current working graph space with <code>DROP SPACE</code> and create a new one with <code>CREATE SPACE</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#clone_graph_spaces","title":"Clone graph spaces","text":"<pre><code>CREATE SPACE [IF NOT EXISTS] &lt;new_graph_space_name&gt; AS &lt;old_graph_space_name&gt;;\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the new graph space exists. If it does not exist, the new one will be created. The graph space existence detection here only compares the graph space name (excluding properties). <code>&lt;new_graph_space_name&gt;</code> The name of the graph space that is newly created. The name of the graph space starts with a letter, supports 1 to 4 bytes UTF-8 encoded characters, such as English letters (case-sensitive), digits, and Chinese characters, but does not support special characters except underscores. For more information, see Keywords and reserved words. When a new graph space is created, the schema of the old graph space <code>&lt;old_graph_space_name&gt;</code> will be cloned, including its parameters (the number of partitions and replicas, etc.), Tag, Edge type and native indexes. <code>&lt;old_graph_space_name&gt;</code> The name of the graph space that already exists."},{"location":"3.ngql-guide/9.space-statements/1.create-space/#examples","title":"Examples","text":"<pre><code># The following example creates a graph space with a specified VID type and the maximum length. Other fields still use the default values.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_1 (vid_type=FIXED_STRING(30));\n\n# The following example creates a graph space with a specified partition number, replica number, and VID type.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_2 (partition_num=15, replica_factor=1, vid_type=FIXED_STRING(30));\n\n#  The following example creates a graph space with a specified partition number, replica number, and VID type, and adds a comment on it.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_3 (partition_num=15, replica_factor=1, vid_type=FIXED_STRING(30)) comment=\"Test the graph space\";\n\n# Clone a graph space.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_4 as my_space_3;\nnebula&gt; SHOW CREATE SPACE my_space_4;\n+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Space        | Create Space                                                                                                                                                 |\n+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| \"my_space_4\" | \"CREATE SPACE `my_space_4` (partition_num = 15, replica_factor = 1, charset = utf8, collate = utf8_bin, vid_type = FIXED_STRING(30)) comment = '\u6d4b\u8bd5\u56fe\u7a7a\u95f4'\" |\n+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Caution</p> <p>Trying to use a newly created graph space may fail because the creation is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds. To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services. If the heartbeat interval is too short (i.e., less than 5 seconds), disconnection between peers may happen because of the misjudgment of machines in the distributed system.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#check_partition_distribution","title":"Check partition distribution","text":"<p>On some large clusters, the partition distribution is possibly unbalanced because of the different startup times. You can run the following command to do a check of the machine distribution.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n| Host        | Port | Status   | Leader count | Leader distribution            | Partition distribution         | Version |\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | 8            | \"basketballplayer:3, test:5\"   | \"basketballplayer:10, test:10\" | \"2.0.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | 9            | \"basketballplayer:4, test:5\"   | \"basketballplayer:10, test:10\" | \"2.0.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | 3            | \"basketballplayer:3\"           | \"basketballplayer:10, test:10\" | \"2.0.0\" |\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n</code></pre> <p>To balance the request loads, use the following command.</p> <pre><code>nebula&gt; BALANCE LEADER;\nnebula&gt; SHOW HOSTS;\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n| Host        | Port | HTTP port | Status   | Leader count | Leader distribution            | Partition distribution         | Version |\n+-------------+------+-----------+----------+--------------+--------------------------------+--------------------------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | 7            | \"basketballplayer:3, test:4\"   | \"basketballplayer:10, test:10\" | \"2.0.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | 7            | \"basketballplayer:4, test:3\"   | \"basketballplayer:10, test:10\" | \"2.0.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | 6            | \"basketballplayer:3, test:3\"   | \"basketballplayer:10, test:10\" | \"2.0.0\" |\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/","title":"USE","text":"<p><code>USE</code> specifies a graph space as the current working graph space for subsequent queries.</p>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>USE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/#syntax","title":"Syntax","text":"<pre><code>USE &lt;graph_space_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/#examples","title":"Examples","text":"<pre><code># The following example creates two sample spaces.\nnebula&gt; CREATE SPACE IF NOT EXISTS space1 (vid_type=FIXED_STRING(30));\nnebula&gt; CREATE SPACE IF NOT EXISTS space2 (vid_type=FIXED_STRING(30));\n\n# The following example specifies space1 as the current working graph space.\nnebula&gt; USE space1;\n\n# The following example specifies space2 as the current working graph space. Hereafter, you cannot read any data from space1, because these vertices and edges being traversed have no relevance with space1.\nnebula&gt; USE space2;\n</code></pre> <p>Caution</p> <p>You cannot use two graph spaces in one statement.</p> <p>Different from Fabric Cypher, graph spaces in NebulaGraph are fully isolated from each other. Making a graph space as the working graph space prevents you from accessing other spaces. The only way to traverse in a new graph space is to switch by the <code>USE</code> statement. In Fabric Cypher, you can use two graph spaces in one statement (using the <code>USE + CALL</code> syntax). But in NebulaGraph, you can only use one graph space in one statement.</p>"},{"location":"3.ngql-guide/9.space-statements/3.show-spaces/","title":"SHOW SPACES","text":"<p><code>SHOW SPACES</code> lists all the graph spaces in the NebulaGraph examples.</p>"},{"location":"3.ngql-guide/9.space-statements/3.show-spaces/#syntax","title":"Syntax","text":"<pre><code>SHOW SPACES;\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/3.show-spaces/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW SPACES;\n+--------------------+\n| Name               |\n+--------------------+\n| \"cba\"              |\n| \"basketballplayer\" |\n+--------------------+\n</code></pre> <p>To create graph spaces, see CREATE SPACE.</p>"},{"location":"3.ngql-guide/9.space-statements/4.describe-space/","title":"DESCRIBE SPACE","text":"<p><code>DESCRIBE SPACE</code> returns the information about the specified graph space.</p>"},{"location":"3.ngql-guide/9.space-statements/4.describe-space/#syntax","title":"Syntax","text":"<p>You can use <code>DESC</code> instead of <code>DESCRIBE</code> for short.</p> <pre><code>DESC[RIBE] SPACE &lt;graph_space_name&gt;;\n</code></pre> <p>The <code>DESCRIBE SPACE</code> statement is different from the <code>SHOW SPACES</code> statement. For details about <code>SHOW SPACES</code>, see SHOW SPACES.</p>"},{"location":"3.ngql-guide/9.space-statements/4.describe-space/#example","title":"Example","text":"<pre><code>nebula&gt; DESCRIBE SPACE basketballplayer;\n+----+--------------------+------------------+----------------+---------+------------+--------------------+---------+\n| ID | Name               | Partition Number | Replica Factor | Charset | Collate    | Vid Type           | Comment |\n+----+--------------------+------------------+----------------+---------+------------+--------------------+---------+\n| 1  | \"basketballplayer\" | 10               | 1              | \"utf8\"  | \"utf8_bin\" | \"FIXED_STRING(32)\" |         |\n+----+--------------------+------------------+----------------+---------+------------+--------------------+---------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/","title":"DROP SPACE","text":"<p><code>DROP SPACE</code> deletes the specified graph space and everything in it.</p> <p>Note</p> <p><code>DROP SPACE</code> can only delete the specified logic graph space while retain all the data on the hard disk by modifying the value of <code>auto_remove_invalid_space</code> to <code>false</code> in the Storage service configuration file. For more information, see Storage configuration.</p> <p>Warning</p> <p>After you execute <code>DROP SPACE</code>, even if the snapshot contains data of the graph space, the data of the graph space cannot be recovered. But if the value of <code>auto_remove_invalid_space</code> is set to <code>false</code>, contact the sales team to recover the data of the graph space. </p>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/#prerequisites","title":"Prerequisites","text":"<p>Only the God role can use the <code>DROP SPACE</code> statement. For more information, see AUTHENTICATION.</p>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/#syntax","title":"Syntax","text":"<pre><code>DROP SPACE [IF EXISTS] &lt;graph_space_name&gt;;\n</code></pre> <p>You can use the <code>IF EXISTS</code> keywords when dropping spaces. These keywords automatically detect if the related graph space exists. If it exists, it will be deleted. Otherwise, no graph space will be deleted.</p> <p>Legacy version compatibility</p> <p>In NebulaGraph versions earlier than 3.1.0, the <code>DROP SPACE</code> statement does not remove all the files and directories from the disk by default.</p> <p>Caution</p> <pre><code>**BE CAUTIOUS** about running the `DROP SPACE` statement.\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/#faq","title":"FAQ","text":"<p>Q: Why is my disk space not freed after executing the 'DROP SPACE' statement and deleting a graph space?</p> <p>A: For NebulaGraph version earlier than 3.1.0, <code>DROP SPACE</code> can only delete the specified logic graph space and does not delete the files and directories on the disk. To delete the files and directories on the disk, manually delete the corresponding file path. The file path is located in <code>&lt;nebula_graph_install_path&gt;/data/storage/nebula/&lt;space_id&gt;</code>. The <code>&lt;space_id&gt;</code> can be viewed via <code>DESCRIBE SPACE {space_name}</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/","title":"CLEAR SPACE","text":"<p><code>CLEAR SPACE</code> deletes the vertices and edges in a graph space, but does not delete the graph space itself and the schema information.</p> <p>Note</p> <p>It is recommended to execute <code>SUBMIT JOB COMPACT</code> immediately after executing the <code>CLEAR SPACE</code> operation improve the query performance. Note that the COMPACT operation may affect query performance, and it is recommended to perform this operation during low business hours (e.g., early morning).</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#permission_requirements","title":"Permission requirements","text":"<p>Only the God role has the permission to run <code>CLEAR SPACE</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#caution","title":"Caution","text":"<ul> <li>Once cleared, the data CANNOT be recovered. Use <code>CLEAR SPACE</code> with caution.</li> <li><code>CLEAR SPACE</code> is not an atomic operation. If an error occurs, re-run <code>CLEAR SPACE</code> to avoid data remaining.</li> <li>The larger the amount of data in the graph space, the longer it takes to clear it. If the execution fails due to client connection timeout, increase the value of the <code>storage_client_timeout_ms</code> parameter in the Graph Service configuration.</li> <li>During the execution of <code>CLEAR SPACE</code>, writing data into the graph space is not automatically prohibited. Such write operations can result in incomplete data clearing, and the residual data can be damaged.</li> </ul> <p>Note</p> <p>The NebulaGraph Community Edition does not support blocking data writing while allowing <code>CLEAR SPACE</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#syntax","title":"Syntax","text":"<pre><code>CLEAR SPACE [IF EXISTS] &lt;space_name&gt;;\n</code></pre> Parameter/Option Description <code>IF EXISTS</code> Check whether the graph space to be cleared exists. If it exists, continue to clear it. If it does not exist, the execution finishes, and a message indicating that the execution succeeded is displayed. If <code>IF EXISTS</code> is not set and the graph space does not exist, the <code>CLEAR SPACE</code> statement fails to execute, and an error occurs. <code>space_name</code> The name of the space to be cleared. <p>Example:</p> <pre><code>CLEAR SPACE basketballplayer;\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#data_reserved","title":"Data reserved","text":"<p><code>CLEAR SPACE</code> does not delete the following data in a graph space:</p> <ul> <li>Tag information.</li> <li>Edge type information.</li> <li>The metadata of native indexes and full-text indexes.</li> </ul> <p>The following example shows what <code>CLEAR SPACE</code> deletes and reserves.</p> <pre><code># Enter the graph space basketballplayer.\nnebula [(none)]&gt; use basketballplayer;\nExecution succeeded\n\n# List tags and Edge types.\nnebula[basketballplayer]&gt; SHOW TAGS;\n+----------+\n| Name     |\n+----------+\n| \"player\" |\n| \"team\"   |\n+----------+\nGot 2 rows\n\nnebula[basketballplayer]&gt; SHOW EDGES;\n+----------+\n| Name     |\n+----------+\n| \"follow\" |\n| \"serve\"  |\n+----------+\nGot 2 rows\n\n# Submit a job to make statistics of the graph space.\nnebula[basketballplayer]&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 4          |\n+------------+\nGot 1 rows\n\n# Check the statistics.\nnebula[basketballplayer]&gt; SHOW STATS;\n+---------+------------+-------+\n| Type    | Name       | Count |\n+---------+------------+-------+\n| \"Tag\"   | \"player\"   | 51    |\n| \"Tag\"   | \"team\"     | 30    |\n| \"Edge\"  | \"follow\"   | 81    |\n| \"Edge\"  | \"serve\"    | 152   |\n| \"Space\" | \"vertices\" | 81    |\n| \"Space\" | \"edges\"    | 233   |\n+---------+------------+-------+\nGot 6 rows\n\n# List tag indexes.\nnebula[basketballplayer]&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\nGot 2 rows\n\n# ----------------------- Dividing line for CLEAR SPACE -----------------------\n# Run CLEAR SPACE to clear the graph space basketballplayer.\nnebula[basketballplayer]&gt; CLEAR SPACE basketballplayer;\nExecution succeeded\n\n# Update the statistics.\nnebula[basketballplayer]&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 5          |\n+------------+\nGot 1 rows\n\n# Check the statistics. The tags and edge types still exist, but all the vertices and edges are gone.\nnebula[basketballplayer]&gt; SHOW STATS;\n+---------+------------+-------+\n| Type    | Name       | Count |\n+---------+------------+-------+\n| \"Tag\"   | \"player\"   | 0     |\n| \"Tag\"   | \"team\"     | 0     |\n| \"Edge\"  | \"follow\"   | 0     |\n| \"Edge\"  | \"serve\"    | 0     |\n| \"Space\" | \"vertices\" | 0     |\n| \"Space\" | \"edges\"    | 0     |\n+---------+------------+-------+\nGot 6 rows\n\n# Try to list the tag indexes. They still exist.\nnebula[basketballplayer]&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\nGot 2 rows (time spent 523/978 us)\n</code></pre>"},{"location":"nebula-dashboard/1.what-is-dashboard/","title":"What is NebulaGraph Dashboard Community Edition","text":"<p>NebulaGraph Dashboard Community Edition (Dashboard for short) is a visualization tool that monitors the status of machines and services in NebulaGraph clusters.</p> <p>Enterpriseonly</p> <p>Dashboard Enterprise Edition adds features such as visual cluster creation, batch import of clusters, fast scaling, etc. For more information, see Pricing.</p>"},{"location":"nebula-dashboard/1.what-is-dashboard/#features","title":"Features","text":"<p>Dashboard monitors:</p> <ul> <li>The status of all the machines in clusters, including CPU, memory, load, disk, and network.</li> </ul> <ul> <li>The information of all the services in clusters, including the IP addresses, versions, and monitoring metrics (such as the number of queries, the latency of queries, the latency of heartbeats, and so on).</li> </ul> <ul> <li>The information of clusters, including the information of services, partitions, configurations, and long-term tasks.</li> </ul> <ul> <li>Set how often the metrics page refreshes.</li> </ul>"},{"location":"nebula-dashboard/1.what-is-dashboard/#scenarios","title":"Scenarios","text":"<p>You can use Dashboard in one of the following scenarios:</p> <ul> <li>You want to monitor key metrics conveniently and quickly, and present multiple key information of the business to ensure the business operates normally.</li> </ul> <ul> <li>You want to monitor clusters from multiple dimensions (such as the time, aggregate rules, and metrics).</li> </ul> <ul> <li>After a failure occurs, you need to review it and confirm its occurrence time and unexpected phenomena.</li> </ul>"},{"location":"nebula-dashboard/1.what-is-dashboard/#precautions","title":"Precautions","text":"<p>The monitoring data will be retained for 14 days by default, that is, only the monitoring data within the last 14 days can be queried.</p> <p>Note</p> <p>The monitoring service is supported by Prometheus. The update frequency and retention intervals can be modified. For details, see Prometheus.</p>"},{"location":"nebula-dashboard/1.what-is-dashboard/#version_compatibility","title":"Version compatibility","text":"<p>The version correspondence between NebulaGraph and Dashboard Community Edition is as follows.</p> NebulaGraph version Dashboard version 3.5.0 3.4.0 3.4.0 ~ 3.4.1 3.4.0\u30013.2.0 3.3.0 3.2.0 2.5.0 ~ 3.2.0 3.1.0 2.5.x ~ 3.1.0 1.1.1 2.0.1~2.5.1 1.0.2 2.0.1~2.5.1 1.0.1"},{"location":"nebula-dashboard/1.what-is-dashboard/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/","title":"Deploy Dashboard Community Edition","text":"<p>This topic will describe how to deploy NebulaGraph Dashboard in detail.</p> <p>To download and compile the latest source code of Dashboard, follow the instructions on the nebula dashboard GitHub page.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#prerequisites","title":"Prerequisites","text":"<p>Before you deploy Dashboard, you must confirm that:</p> <ul> <li>The NebulaGraph services are deployed and started. For more information, see NebulaGraph Database Manual.</li> </ul> <ul> <li> <p>Before the installation starts, the following ports are not occupied.</p> <ul> <li>9200</li> </ul> <ul> <li>9100</li> </ul> <ul> <li>9090</li> </ul> <ul> <li>8090</li> </ul> <ul> <li>7003</li> </ul> </li> </ul> <ul> <li>The node-exporter is installed on the machines to be monitored. For details on installation, see Prometheus document.</li> </ul>"},{"location":"nebula-dashboard/2.deploy-dashboard/#steps","title":"Steps","text":"<ol> <li> <p>Download the tar packagenebula-dashboard-3.4.0.x86_64.tar.gz  as needed.</p> </li> <li> <p>Run <code>tar -xvf nebula-dashboard-3.4.0.x86_64.tar.gz</code> to decompress the installation package.</p> </li> <li> <p>Modify the <code>config.yaml</code> file in <code>nebula-dashboard</code>.</p> <p>The configuration file contains the configurations of four dependent services and configurations of clusters. The descriptions of the dependent services are as follows.</p> Service Default port Description nebula-http-gateway 8090 Provides HTTP ports for cluster services to execute nGQL statements to interact with the NebulaGraph database. nebula-stats-exporter 9200 Collects the performance metrics in the cluster, including the IP addresses, versions, and monitoring metrics (such as the number of queries, the latency of queries, the latency of heartbeats, and so on). node-exporter 9100 Collects the source information of nodes in the cluster, including the CPU, memory, load, disk, and network. prometheus 9090 The time series database that stores monitoring data. <p>The descriptions of the configuration file are as follows.</p> <pre><code>port: 7003   # Web service port.\ngateway:\n  ip: hostIP   # The IP of the machine where the Dashboard is deployed.\n  port: 8090\n  https: false  # Whether to enable HTTPS.\n  runmode: dev  # Program running mode, including dev, test, and prod. It is used to distinguish between different running environments generally.\nstats-exporter:\n  ip: hostIP   # The IP of the machine where the Dashboard is deployed.\n  nebulaPort: 9200\n  https: false  # Whether to enable HTTPS.\nnode-exporter:\n  - ip: nebulaHostIP_1 # The IP of the machine where the NebulaGraph is deployed.\n    port: 9100\n    https: false # Whether to enable HTTPS.\n# - ip: nebulaHostIP_2\n#   port: 9100\n#   https: false\nprometheus:\n  ip: hostIP    # The IP of the machine where the Dashboard is deployed.\n  prometheusPort: 9090\n  https: false  # Whether to enable HTTPS.\n  scrape_interval: 5s  # The interval for collecting the monitoring data, which is 1 minute by default.\n  evaluation_interval: 5s  # The interval for running alert rules, which is 1 minute by default.\n# Cluster node info\nnebula-cluster:\n  name: 'default' # Cluster name\n  metad:\n    - name: metad0\n      endpointIP: nebulaMetadIP  # The IP of the machine where the Meta service is deployed.\n      port: 9559\n      endpointPort: 19559\n  # - name: metad1\n  #   endpointIP: nebulaMetadIP\n  #   port: 9559\n  #   endpointPort: 19559  \n  graphd:\n    - name: graphd0\n      endpointIP: nebulaGraphdIP  # The IP of the machine where the Graph service is deployed.\n      port: 9669\n      endpointPort: 19669\n  # - name: graphd1\n  #   endpointIP: nebulaGraphdIP\n  #   port: 9669\n  #   endpointPort: 19669  \n  storaged:\n    - name: storaged0\n      endpointIP: nebulaStoragedIP  # The IP of the machine where the Storage service is deployed.\n      port: 9779\n      endpointPort: 19779\n  # - name: storaged1\n  #   endpointIP: nebulaStoragedIP\n  #   port: 9779\n  #   endpointPort: 19779  \n</code></pre> </li> <li> <p>Run <code>./dashboard.service start all</code> to start the services.</p> </li> </ol>"},{"location":"nebula-dashboard/2.deploy-dashboard/#deploy_dashboard_with_docker_compose","title":"Deploy Dashboard with Docker Compose","text":"<p>If you are deploying Dashboard using docker, you should also modify the configuration file <code>config.yaml</code>, and then run <code>docker-compose up -d</code> to start the container.</p> <p>Note</p> <p>If you change the port number in <code>config.yaml</code>, the port number in <code>docker-compose.yaml</code> needs to be consistent as well.</p> <p>Run <code>docker-compose stop</code> to stop the container.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#manage_services_in_dashboard","title":"Manage services in Dashboard","text":"<p>You can use the <code>dashboard.service</code> script to start, restart, stop, and check the Dashboard services.</p> <pre><code>sudo &lt;dashboard_path&gt;/dashboard.service\n[-v] [-h]\n&lt;start|restart|stop|status&gt;  &lt;prometheus|webserver|exporter|gateway|all&gt;\n</code></pre> Parameter Description <code>dashboard_path</code> Dashboard installation path. <code>-v</code> Display detailed debugging information. <code>-h</code> Display help information. <code>start</code> Start the target services. <code>restart</code> Restart the target services. <code>stop</code> Stop the target services. <code>status</code> Check the status of the target services. <code>prometheus</code> Set the prometheus service as the target service. <code>webserver</code> Set the webserver Service as the target service. <code>exporter</code> Set the exporter Service as the target service. <code>gateway</code> Set the gateway Service as the target service. <code>all</code> Set all the Dashboard services as the target services. <p>Note</p> <p>To view the Dashboard version, run the command <code>./dashboard.service -version</code>.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#next_to_do","title":"Next to do","text":"<p>Connect to Dashboard</p>"},{"location":"nebula-dashboard/3.connect-dashboard/","title":"Connect Dashboard","text":"<p>After Dashboard is deployed, you can log in and use Dashboard on the browser.</p>"},{"location":"nebula-dashboard/3.connect-dashboard/#prerequisites","title":"Prerequisites","text":"<ul> <li>The Dashboard services are started. For more information, see Deploy Dashboard.</li> </ul> <ul> <li>We recommend you to use the Chrome browser of the version above 89. Otherwise, there may be compatibility issues.</li> </ul>"},{"location":"nebula-dashboard/3.connect-dashboard/#procedures","title":"Procedures","text":"<ol> <li> <p>Confirm the IP address of the machine where the Dashboard service is installed. Enter <code>&lt;IP&gt;:7003</code> in the browser to open the login page.</p> </li> <li> <p>Enter the username and the passwords of the NebulaGraph database.</p> <ul> <li>If authentication is enabled, you can log in with the created accounts.</li> </ul> <ul> <li>If authentication is not enabled, you can only log in using <code>root</code> as the username and random characters as the password.</li> </ul> <p>To enable authentication, see Authentication.</p> </li> <li> <p>Select the NebulaGraph version to be used.</p> </li> <li> <p>Click Login.</p> </li> </ol>"},{"location":"nebula-dashboard/4.use-dashboard/","title":"Dashboard","text":"<p>NebulaGraph Dashboard consists of three parts: Machine, Service, and Management. This topic will describe them in detail.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#overview","title":"Overview","text":""},{"location":"nebula-dashboard/4.use-dashboard/#machine","title":"Machine","text":"<p>Click Machine-&gt;Overview to enter the machine overview page.</p> <p>On this page, you can view the variation of CPU, Memory, Load, Disk, and Network In/Out quickly.</p> <ul> <li>By default, you can view the monitoring data for a maximum of 14 days. You can also select a time range or quickly select the latest 1 hour, 6 hours, 12 hours, 1 day, 3 days, 7 days, or 14 days.</li> <li>By default, you can view the monitoring data of all the instances in clusters. You can select the instances you want to view in the instance box.</li> <li>By default, the monitoring information page will not be updated automatically. You can set the update frequency of the monitoring information page globally or click the  button to update the page manually.</li> <li>To set a base line, click the  button.</li> <li> <p>To view the detailed monitoring information, click the  button. In this example, select <code>Load</code> for details. The figure is as follows.</p> <p></p> <ul> <li>You can set the monitoring time range, instance, update frequency and base line.</li> <li>You can search for or select the target metric. For details about monitoring metrics, see Metrics.</li> <li>You can temporarily hide nodes that you do not need to view.</li> <li>You can click the  button to view the detailed monitoring information.</li> </ul> </li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#service","title":"Service","text":"<p>Click Service-&gt;Overview to enter the service overview page.</p> <p>On this page, you can view the information of Graph, Meta, and Storage services quickly. In the upper right corner, the number of normal services and abnormal services will be displayed.</p> <p>Note</p> <p>In the  Service page, only two monitoring metrics can be set for each service, which can be adjusted by clicking the Set up button.</p> <ul> <li>By default, you can view the monitoring data for a maximum of 14 days. You can also select a time range or quickly select the latest 1 hour, 6 hours, 12 hours, 1 day, 3 days, 7 days, or 14 days.</li> <li>By default, you can view the monitoring data of all the instances in clusters. You can select the instances you want to view in the instance box.</li> <li>By default, the monitoring information page will not be updated automatically. You can set the update frequency of the monitoring information page globally or click the  button to update the page manually.</li> <li>You can view the status of all the services in a cluster.</li> <li> <p>To view the detailed monitoring information, click the  button. In this example, select <code>Graph</code> for details. The figure is as follows.</p> <p></p> <ul> <li>You can set the monitoring time range, instance, update frequency, period, aggregation and base line.</li> <li>You can search for or select the target metric. For details of monitoring metrics, see Monitor parameter.</li> <li>You can temporarily hide nodes that you do not need to view.</li> <li>You can click the  button to view the detailed monitoring information.</li> <li>The Graph service supports a set of space-level metrics. For more information, see the following section Graph space.</li> </ul> </li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Before using graph space metrics, you need to set <code>enable_space_level_metrics</code> to <code>true</code> in the Graph service. For details, see [Graph Service configuration](../5.configurations-and-logs/1.configurations/3.graph-config.md.</p> <p>Space-level metric incompatibility</p> <p>If a graph space name contains special characters, the corresponding metric data of that graph space may not be displayed. </p> <p>The service monitoring page can also monitor graph space level metrics. Only when the behavior of a graph space metric is triggered, you can specify the graph space to view information about the corresponding graph space metric.</p> <p>Space graph metrics record the information of different graph spaces separately. Currently, only the Graph service supports a set of space-level metrics.</p> <p>For information about the space graph metrics, see Graph space.</p> <p></p>"},{"location":"nebula-dashboard/4.use-dashboard/#management","title":"Management","text":""},{"location":"nebula-dashboard/4.use-dashboard/#overview_info","title":"Overview info","text":"<p>On the Overview Info page, you can see the information of the NebulaGraph cluster, including Storage leader distribution, Storage service details, versions and hosts information of each NebulaGraph service, and partition distribution and details.</p> <p></p>"},{"location":"nebula-dashboard/4.use-dashboard/#storage_leader_distribution","title":"Storage Leader Distribution","text":"<p>In this section, the number of Leaders and the Leader distribution will be shown.</p> <ul> <li>Click the Balance Leader button in the upper right corner to distribute Leaders evenly and quickly in the NebulaGraph cluster. For details about the Leader, see Storage Service.</li> </ul> <ul> <li>Click Detail in the upper right corner to view the details of the Leader distribution.</li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#version","title":"Version","text":"<p>In this section, the version and host information of each NebulaGraph service will be shown. Click Detail in the upper right corner to view the details of the version and host information.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#service_information","title":"Service information","text":"<p>In this section, the information on Storage services will be shown. The parameter description is as follows:</p> Parameter Description <code>Host</code> The IP address of the host. <code>Port</code> The port of the host. <code>Status</code> The host status. <code>Git Info Sha</code> The commit ID of the current version. <code>Leader Count</code> The number of Leaders. <code>Partition Distribution</code> The distribution of partitions. <code>Leader Distribution</code> The distribution of Leaders. <p>Click Detail in the upper right corner to view the details of the Storage service information.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#partition_distribution","title":"Partition Distribution","text":"<p>Select the specified graph space in the upper left corner, you can view the distribution of partitions in the specified graph space. You can see the IP addresses and ports of all Storage services in the cluster, and the number of partitions in each Storage service.</p> <p>Click Detail in the upper right corner to view more details.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#partition_information","title":"Partition information","text":"<p>In this section, the information on partitions will be shown. Before viewing the partition information, you need to select a graph space in the upper left corner. The parameter description is as follows:</p> Parameter Description <code>Partition ID</code> The ID of the partition. <code>Leader</code> The IP address and port of the leader. <code>Peers</code> The IP addresses and ports of all the replicas. <code>Losts</code> The IP addresses and ports of faulty replicas. <p>Click Detail in the upper right corner to view details. You can also enter the partition ID into the input box in the upper right corner of the details page to filter the shown data. </p>"},{"location":"nebula-dashboard/4.use-dashboard/#config","title":"Config","text":"<p>It shows the configuration of the NebulaGraph service. NebulaGraph Dashboard Community Edition does not support online modification of configurations for now.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#others","title":"Others","text":"<p>In the lower left corner of the page, you can:</p> <ul> <li>Sign out</li> </ul> <ul> <li>Switch between Chinese and English</li> </ul> <ul> <li>View the current Dashboard release</li> </ul> <ul> <li>View the user manual and forum</li> </ul> <ul> <li>Fold the sidebar</li> </ul>"},{"location":"nebula-dashboard/6.monitor-parameter/","title":"Metrics","text":"<p>This topic will describe the monitoring metrics in NebulaGraph Dashboard.</p>"},{"location":"nebula-dashboard/6.monitor-parameter/#machine","title":"Machine","text":"<p>Note</p> <ul> <li>All the machine metrics listed below are for the Linux operating system.</li> <li>The default unit in Disk and Network is byte. The unit will change with the data magnitude as the page displays. For example, when the flow is less than 1 KB/s, the unit will be Bytes/s.</li> <li>For versions of Dashboard Community Edition greater than v1.0.2, the memory occupied by Buff and Cache will not be counted in the memory usage.</li> </ul>"},{"location":"nebula-dashboard/6.monitor-parameter/#cpu","title":"CPU","text":"Parameter Description <code>cpu_utilization</code> The percentage of used CPU. <code>cpu_idle</code> The percentage of idled CPU. <code>cpu_wait</code> The percentage of CPU waiting for IO operations. <code>cpu_user</code> The percentage of CPU used by users. <code>cpu_system</code> The percentage of CPU used by the system."},{"location":"nebula-dashboard/6.monitor-parameter/#memory","title":"Memory","text":"Parameter Description <code>memory_utilization</code> The percentage of used memory. <code>memory_used</code> The memory space used (not including caches). <code>memory_free</code> The memory space available."},{"location":"nebula-dashboard/6.monitor-parameter/#load","title":"Load","text":"Parameter Description <code>load_1m</code> The average load of the system in the last 1 minute. <code>load_5m</code> The average load of the system in the last 5 minutes. <code>load_15m</code> The average load of the system in the last 15 minutes."},{"location":"nebula-dashboard/6.monitor-parameter/#disk","title":"Disk","text":"Parameter Description <code>disk_used_percentage</code> The disk utilization percentage. <code>disk_used</code> The disk space used. <code>disk_free</code> The disk space available. <code>disk_readbytes</code> The number of bytes that the system reads in the disk per second. <code>disk_writebytes</code> The number of bytes that the system writes in the disk per second. <code>disk_readiops</code> The number of read queries that the disk receives per second. <code>disk_writeiops</code> The number of write queries that the disk receives per second. <code>inode_utilization</code> The percentage of used inode."},{"location":"nebula-dashboard/6.monitor-parameter/#network","title":"Network","text":"Parameter Description <code>network_in_rate</code> The number of bytes that the network card receives per second. <code>network_out_rate</code> The number of bytes that the network card sends out per second. <code>network_in_errs</code> The number of wrong bytes that the network card receives per second. <code>network_out_errs</code> The number of wrong bytes that the network card sends out per second. <code>network_in_packets</code> The number of data packages that the network card receives per second. <code>network_out_packets</code> The number of data packages that the network card sends out per second."},{"location":"nebula-dashboard/6.monitor-parameter/#service","title":"Service","text":""},{"location":"nebula-dashboard/6.monitor-parameter/#period","title":"Period","text":"<p>The period is the time range of counting metrics. It currently supports 5 seconds, 60 seconds, 600 seconds, and 3600 seconds, which respectively represent the last 5 seconds, the last 1 minute, the last 10 minutes, and the last 1 hour.</p>"},{"location":"nebula-dashboard/6.monitor-parameter/#metric_methods","title":"Metric methods","text":"Parameter Description <code>rate</code> The average rate of operations per second in a period. <code>sum</code> The sum of operations in the period. <code>avg</code> The average latency in the cycle. <code>P75</code> The 75th percentile latency. <code>P95</code> The 95th percentile latency. <code>P99</code> The 99th percentile latency. <code>P999</code> The 99.9th percentile latency. <p>Note</p> <p>Dashboard collects the following metrics from the NebulaGraph core, but only shows the metrics that are important to it. </p>"},{"location":"nebula-dashboard/6.monitor-parameter/#graph","title":"Graph","text":"Parameter Description <code>num_active_queries</code> The number of changes in the number of active queries. Formula: The number of started queries minus the number of finished queries within a specified time. <code>num_active_sessions</code> The number of changes in the number of active sessions. Formula: The number of logged in sessions minus the number of logged out sessions within a specified time.For example, when querying <code>num_active_sessions.sum.5</code>, if there were 10 sessions logged in and 30 sessions logged out in the last 5 seconds, the value of this metric is <code>-20</code> (10-30). <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions_out_of_max_allowed</code> The number of sessions that failed to authenticate logins because the value of the parameter <code>FLAG_OUT_OF_MAX_ALLOWED_CONNECTIONS</code> was exceeded. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_killed_queries</code> The number of killed queries. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries</code> The number of queries. <code>num_query_errors_leader_changes</code> The number of the raft leader changes due to query errors. <code>num_query_errors</code> The number of query errors. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>num_sentences</code> The number of statements received by the Graphd service. <code>num_slow_queries</code> The number of slow queries. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>slow_query_latency_us</code> The latency of slow queries. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>resp_part_completeness</code> The completeness of the partial success. You need to set <code>accept_partial_success</code> to <code>true</code> in the graph configuration first."},{"location":"nebula-dashboard/6.monitor-parameter/#meta","title":"Meta","text":"Parameter Description <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>heartbeat_latency_us</code> The latency of heartbeats. <code>num_heartbeats</code> The number of heartbeats. <code>num_raft_votes</code> The number of votes in Raft. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>num_agent_heartbeats</code> The number of heartbeats for the AgentHBProcessor. <code>agent_heartbeat_latency_us</code> The latency of the AgentHBProcessor. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_send_snapshot</code> The number of times that Raft sends snapshots to other nodes. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>num_start_elect</code> The number of times that Raft starts an election."},{"location":"nebula-dashboard/6.monitor-parameter/#storage","title":"Storage","text":"Parameter Description <code>add_edges_latency_us</code> The latency of adding edges. <code>add_vertices_latency_us</code> The latency of adding vertices. <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>delete_edges_latency_us</code> The latency of deleting edges. <code>delete_vertices_latency_us</code> The latency of deleting vertices. <code>get_neighbors_latency_us</code> The latency of querying neighbor vertices. <code>get_dst_by_src_latency_us</code> The latency of querying the destination vertex by the source vertex. <code>num_get_prop</code> The number of executions for the GetPropProcessor. <code>num_get_neighbors_errors</code> The number of execution errors for the GetNeighborsProcessor. <code>num_get_dst_by_src_errors</code> The number of execution errors for the GetDstBySrcProcessor. <code>get_prop_latency_us</code> The latency of executions for the GetPropProcessor. <code>num_edges_deleted</code> The number of deleted edges. <code>num_edges_inserted</code> The number of inserted edges. <code>num_raft_votes</code> The number of votes in Raft. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Storage service sent to the Meta service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Storaged service sent to the Metad service. <code>num_tags_deleted</code> The number of deleted tags. <code>num_vertices_deleted</code> The number of deleted vertices. <code>num_vertices_inserted</code> The number of inserted vertices. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>lookup_latency_us</code> The latency of executions for the LookupProcessor. <code>num_lookup_errors</code> The number of execution errors for the LookupProcessor. <code>num_scan_vertex</code> The number of executions for the ScanVertexProcessor. <code>num_scan_vertex_errors</code> The number of execution errors for the ScanVertexProcessor. <code>update_edge_latency_us</code> The latency of executions for the UpdateEdgeProcessor. <code>num_update_vertex</code> The number of executions for the UpdateVertexProcessor. <code>num_update_vertex_errors</code> The number of execution errors for the UpdateVertexProcessor. <code>kv_get_latency_us</code> The latency of executions for the Getprocessor. <code>kv_put_latency_us</code> The latency of executions for the PutProcessor. <code>kv_remove_latency_us</code> The latency of executions for the RemoveProcessor. <code>num_kv_get_errors</code> The number of execution errors for the GetProcessor. <code>num_kv_get</code> The number of executions for the GetProcessor. <code>num_kv_put_errors</code> The number of execution errors for the PutProcessor. <code>num_kv_put</code> The number of executions for the PutProcessor. <code>num_kv_remove_errors</code> The number of execution errors for the RemoveProcessor. <code>num_kv_remove</code> The number of executions for the RemoveProcessor. <code>forward_tranx_latency_us</code> The latency of transmission. <code>scan_edge_latency_us</code> The latency of executions for the ScanEdgeProcessor. <code>num_scan_edge_errors</code> The number of execution errors for the ScanEdgeProcessor. <code>num_scan_edge</code> The number of executions for the ScanEdgeProcessor. <code>scan_vertex_latency_us</code> The latency of executions for the ScanVertexProcessor. <code>num_add_edges</code> The number of times that edges are added. <code>num_add_edges_errors</code> The number of errors when adding edges. <code>num_add_vertices</code> The number of times that vertices are added. <code>num_start_elect</code> The number of times that Raft starts an election. <code>num_add_vertices_errors</code> The number of errors when adding vertices. <code>num_delete_vertices_errors</code> The number of errors when deleting vertices. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_delete_tags</code> The number of times that tags are deleted. <code>num_delete_tags_errors</code> The number of errors when deleting tags. <code>num_delete_edges</code> The number of edge deletions. <code>num_delete_edges_errors</code> The number of errors when deleting edges <code>num_send_snapshot</code> The number of times that snapshots are sent. <code>update_vertex_latency_us</code> The latency of executions for the UpdateVertexProcessor. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_update_edge</code> The number of executions for the UpdateEdgeProcessor. <code>delete_tags_latency_us</code> The latency of deleting tags. <code>num_update_edge_errors</code> The number of execution errors for the UpdateEdgeProcessor. <code>num_get_neighbors</code> The number of executions for the GetNeighborsProcessor. <code>num_get_dst_by_src</code> The number of executions for the GetDstBySrcProcessor. <code>num_get_prop_errors</code> The number of execution errors for the GetPropProcessor. <code>num_delete_vertices</code> The number of times that vertices are deleted. <code>num_lookup</code> The number of executions for the LookupProcessor. <code>num_sync_data</code> The number of times the Storage service synchronizes data from the Drainer. <code>num_sync_data_errors</code> The number of errors that occur when the Storage service synchronizes data from the Drainer. <code>sync_data_latency_us</code> The latency of the Storage service synchronizing data from the Drainer."},{"location":"nebula-dashboard/6.monitor-parameter/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Space-level metrics are created dynamically, so that only when the behavior is triggered in the graph space, the corresponding metric is created and can be queried by the user.</p> Parameter Description <code>num_active_queries</code> The number of queries currently being executed. <code>num_queries</code> The number of queries. <code>num_sentences</code> The number of statements received by the Graphd service. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>num_slow_queries</code> The number of slow queries. <code>num_query_errors</code> The number of query errors. <code>num_query_errors_leader_changes</code> The number of raft leader changes due to query errors. <code>num_killed_queries</code> The number of killed queries. <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>slow_query_latency_us</code> The latency of slow queries."},{"location":"reuse/source-monitoring-metrics/","title":"Source monitoring metrics","text":""},{"location":"reuse/source-monitoring-metrics/#graph","title":"Graph","text":"Parameter Description <code>num_active_queries</code> The number of changes in the number of active queries. Formula: The number of started queries minus the number of finished queries within a specified time. <code>num_active_sessions</code> The number of changes in the number of active sessions. Formula: The number of logged in sessions minus the number of logged out sessions within a specified time.For example, when querying <code>num_active_sessions.sum.5</code>, if there were 10 sessions logged in and 30 sessions logged out in the last 5 seconds, the value of this metric is <code>-20</code> (10-30). <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions_out_of_max_allowed</code> The number of sessions that failed to authenticate logins because the value of the parameter <code>FLAG_OUT_OF_MAX_ALLOWED_CONNECTIONS</code> was exceeded. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_killed_queries</code> The number of killed queries. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries</code> The number of queries. <code>num_query_errors_leader_changes</code> The number of the raft leader changes due to query errors. <code>num_query_errors</code> The number of query errors. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>num_sentences</code> The number of statements received by the Graphd service. <code>num_slow_queries</code> The number of slow queries. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>slow_query_latency_us</code> The latency of slow queries. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>resp_part_completeness</code> The completeness of the partial success. You need to set <code>accept_partial_success</code> to <code>true</code> in the graph configuration first."},{"location":"reuse/source-monitoring-metrics/#meta","title":"Meta","text":"Parameter Description <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>heartbeat_latency_us</code> The latency of heartbeats. <code>num_heartbeats</code> The number of heartbeats. <code>num_raft_votes</code> The number of votes in Raft. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>num_agent_heartbeats</code> The number of heartbeats for the AgentHBProcessor. <code>agent_heartbeat_latency_us</code> The latency of the AgentHBProcessor. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_send_snapshot</code> The number of times that Raft sends snapshots to other nodes. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>num_start_elect</code> The number of times that Raft starts an election."},{"location":"reuse/source-monitoring-metrics/#storage","title":"Storage","text":"Parameter Description <code>add_edges_latency_us</code> The latency of adding edges. <code>add_vertices_latency_us</code> The latency of adding vertices. <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>delete_edges_latency_us</code> The latency of deleting edges. <code>delete_vertices_latency_us</code> The latency of deleting vertices. <code>get_neighbors_latency_us</code> The latency of querying neighbor vertices. <code>get_dst_by_src_latency_us</code> The latency of querying the destination vertex by the source vertex. <code>num_get_prop</code> The number of executions for the GetPropProcessor. <code>num_get_neighbors_errors</code> The number of execution errors for the GetNeighborsProcessor. <code>num_get_dst_by_src_errors</code> The number of execution errors for the GetDstBySrcProcessor. <code>get_prop_latency_us</code> The latency of executions for the GetPropProcessor. <code>num_edges_deleted</code> The number of deleted edges. <code>num_edges_inserted</code> The number of inserted edges. <code>num_raft_votes</code> The number of votes in Raft. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Storage service sent to the Meta service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Storaged service sent to the Metad service. <code>num_tags_deleted</code> The number of deleted tags. <code>num_vertices_deleted</code> The number of deleted vertices. <code>num_vertices_inserted</code> The number of inserted vertices. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>lookup_latency_us</code> The latency of executions for the LookupProcessor. <code>num_lookup_errors</code> The number of execution errors for the LookupProcessor. <code>num_scan_vertex</code> The number of executions for the ScanVertexProcessor. <code>num_scan_vertex_errors</code> The number of execution errors for the ScanVertexProcessor. <code>update_edge_latency_us</code> The latency of executions for the UpdateEdgeProcessor. <code>num_update_vertex</code> The number of executions for the UpdateVertexProcessor. <code>num_update_vertex_errors</code> The number of execution errors for the UpdateVertexProcessor. <code>kv_get_latency_us</code> The latency of executions for the Getprocessor. <code>kv_put_latency_us</code> The latency of executions for the PutProcessor. <code>kv_remove_latency_us</code> The latency of executions for the RemoveProcessor. <code>num_kv_get_errors</code> The number of execution errors for the GetProcessor. <code>num_kv_get</code> The number of executions for the GetProcessor. <code>num_kv_put_errors</code> The number of execution errors for the PutProcessor. <code>num_kv_put</code> The number of executions for the PutProcessor. <code>num_kv_remove_errors</code> The number of execution errors for the RemoveProcessor. <code>num_kv_remove</code> The number of executions for the RemoveProcessor. <code>forward_tranx_latency_us</code> The latency of transmission. <code>scan_edge_latency_us</code> The latency of executions for the ScanEdgeProcessor. <code>num_scan_edge_errors</code> The number of execution errors for the ScanEdgeProcessor. <code>num_scan_edge</code> The number of executions for the ScanEdgeProcessor. <code>scan_vertex_latency_us</code> The latency of executions for the ScanVertexProcessor. <code>num_add_edges</code> The number of times that edges are added. <code>num_add_edges_errors</code> The number of errors when adding edges. <code>num_add_vertices</code> The number of times that vertices are added. <code>num_start_elect</code> The number of times that Raft starts an election. <code>num_add_vertices_errors</code> The number of errors when adding vertices. <code>num_delete_vertices_errors</code> The number of errors when deleting vertices. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_delete_tags</code> The number of times that tags are deleted. <code>num_delete_tags_errors</code> The number of errors when deleting tags. <code>num_delete_edges</code> The number of edge deletions. <code>num_delete_edges_errors</code> The number of errors when deleting edges <code>num_send_snapshot</code> The number of times that snapshots are sent. <code>update_vertex_latency_us</code> The latency of executions for the UpdateVertexProcessor. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_update_edge</code> The number of executions for the UpdateEdgeProcessor. <code>delete_tags_latency_us</code> The latency of deleting tags. <code>num_update_edge_errors</code> The number of execution errors for the UpdateEdgeProcessor. <code>num_get_neighbors</code> The number of executions for the GetNeighborsProcessor. <code>num_get_dst_by_src</code> The number of executions for the GetDstBySrcProcessor. <code>num_get_prop_errors</code> The number of execution errors for the GetPropProcessor. <code>num_delete_vertices</code> The number of times that vertices are deleted. <code>num_lookup</code> The number of executions for the LookupProcessor. <code>num_sync_data</code> The number of times the Storage service synchronizes data from the Drainer. <code>num_sync_data_errors</code> The number of errors that occur when the Storage service synchronizes data from the Drainer. <code>sync_data_latency_us</code> The latency of the Storage service synchronizing data from the Drainer."},{"location":"reuse/source-monitoring-metrics/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Space-level metrics are created dynamically, so that only when the behavior is triggered in the graph space, the corresponding metric is created and can be queried by the user.</p> Parameter Description <code>num_active_queries</code> The number of queries currently being executed. <code>num_queries</code> The number of queries. <code>num_sentences</code> The number of statements received by the Graphd service. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>num_slow_queries</code> The number of slow queries. <code>num_query_errors</code> The number of query errors. <code>num_query_errors_leader_changes</code> The number of raft leader changes due to query errors. <code>num_killed_queries</code> The number of killed queries. <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>slow_query_latency_us</code> The latency of slow queries."},{"location":"reuse/source_connect-to-nebula-graph/","title":"Source connect to nebula graph","text":"<p>This topic provides basic instruction on how to use the native CLI client NebulaGraph Console to connect to NebulaGraph.</p> <p>Caution</p> <p>When connecting to NebulaGraph for the first time, you must register the Storage Service before querying data.</p> <p>NebulaGraph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. For more information, see the client list.</p>"},{"location":"reuse/source_connect-to-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have started NebulaGraph services.</li> </ul> <ul> <li>The machine on which you plan to run NebulaGraph Console has network access to the Graph Service of NebulaGraph.</li> </ul> <ul> <li> <p>The NebulaGraph Console version is compatible with the NebulaGraph version.</p> <p>Note</p> <p>NebulaGraph Console and NebulaGraph of the same version number are the most compatible. There may be compatibility issues when connecting to NebulaGraph with a different version of NebulaGraph Console. The error message <code>incompatible version between client and server</code> is displayed when there is such an issue.</p> </li> </ul>"},{"location":"reuse/source_connect-to-nebula-graph/#steps","title":"Steps","text":"<ol> <li> <p>On the NebulaGraph Console releases page, select a NebulaGraph Console version and click Assets.</p> <p>Note</p> <p>It is recommended to select the latest version.</p> </li> <li> <p>In the Assets area, find the correct binary file for the machine where you want to run NebulaGraph Console and download the file to the machine.</p> </li> <li> <p>(Optional) Rename the binary file to <code>nebula-console</code> for convenience.</p> <p>Note</p> <p>For Windows, rename the file to <code>nebula-console.exe</code>.</p> </li> <li> <p>On the machine to run NebulaGraph Console, grant the execute permission of the nebula-console binary file to the user.</p> <p>Note</p> <p>For Windows, skip this step.</p> <pre><code>$ chmod 111 nebula-console\n</code></pre> </li> <li> <p>In the command line interface, change the working directory to the one where the nebula-console binary file is stored.</p> </li> <li> <p>Run the following command to connect to NebulaGraph.</p> <ul> <li>For Linux or macOS:</li> </ul> <pre><code>$ ./nebula-console -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <ul> <li>For Windows:</li> </ul> <pre><code>&gt; nebula-console.exe -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP address of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the storage path of the certification authority file. <code>-ssl_cert_path</code> Sets the storage path of the certificate file. <code>-ssl_private_key_path</code> Sets the storage path of the private key file. <p>For information on more parameters, see the project repository.</p> </li> </ol>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/","title":"Source install nebula graph by rpm or deb","text":"<p>RPM and DEB are common package formats on Linux systems. This topic shows how to quickly install NebulaGraph with the RPM or DEB package.</p> <p>Note</p> <p>The console is not complied or packaged with NebulaGraph server binaries. You can install nebula-console by yourself.</p>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#prerequisites","title":"Prerequisites","text":"<ul> <li>The tool <code>wget</code> is installed.</li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#step_1_download_the_package_from_cloud_service","title":"Step 1: Download the package from cloud service","text":"<p>Note</p> <p>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </p> <ul> <li>Download the released version.<p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the release package <code>2.0.0</code> for <code>Centos 7.5</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>Download the release package <code>2.0.0</code> for <code>Ubuntu 1804</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/2.0.0/nebula-graph-2.0.0.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul> <ul> <li> <p>Download the nightly version.</p> <p>Danger</p> <ul> <li>Nightly versions are usually used to test new features. Do not use it in a production environment.</li> <li>Nightly versions may not be built successfully every night. And the names may change from day to day.</li> </ul> <p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the <code>Centos 7.5</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>For example, download the <code>Ubuntu 1804</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#step_2_install_nebulagraph","title":"Step 2: Install NebulaGraph","text":"<ul> <li> <p>Use the following syntax to install with an RPM package.</p> <pre><code>$ sudo rpm -ivh --prefix=&lt;installation_path&gt; &lt;package_name&gt;\n</code></pre> <p>The option <code>--prefix</code> indicates the installation path. The default path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install an RPM package in the default path for the 2.0.0 version, run the following command.</p> <pre><code>sudo rpm -ivh nebula-graph-2.0.0.el7.x86_64.rpm\n</code></pre> </li> </ul> <ul> <li> <p>Use the following syntax to install with a DEB package.</p> <pre><code>$ sudo dpkg -i &lt;package_name&gt;\n</code></pre> <p>Note</p> <p>Customizing the installation path is not supported when installing NebulaGraph with a DEB package. The default installation path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install a DEB package for the 2.0.0 version, run the following command.</p> <pre><code>sudo dpkg -i nebula-graph-2.0.0.ubuntu1804.amd64.deb\n</code></pre> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula/</code>.</p> </li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#next_to_do","title":"Next to do","text":"<ul> <li>Start NebulaGraph </li> </ul> <ul> <li>Connect to NebulaGraph</li> </ul>"},{"location":"reuse/source_manage-service/","title":"Source manage service","text":"<p>NebulaGraph supports managing services with scripts. </p>"},{"location":"reuse/source_manage-service/#manage_services_with_script","title":"Manage services with script","text":"<p>You can use the <code>nebula.service</code> script to start, stop, restart, terminate, and check the NebulaGraph services.</p> <p>Note</p> <p><code>nebula.service</code> is stored in the <code>/usr/local/nebula/scripts</code> directory by default. If you have customized the path, use the actual path in your environment.</p>"},{"location":"reuse/source_manage-service/#syntax","title":"Syntax","text":"<pre><code>$ sudo /usr/local/nebula/scripts/nebula.service\n[-v] [-c &lt;config_file_path&gt;]\n&lt;start | stop | restart | kill | status&gt;\n&lt;metad | graphd | storaged | all&gt;\n</code></pre> Parameter Description <code>-v</code> Display detailed debugging information. <code>-c</code> Specify the configuration file path. The default path is <code>/usr/local/nebula/etc/</code>. <code>start</code> Start the target services. <code>stop</code> Stop the target services. <code>restart</code> Restart the target services. <code>kill</code> Terminate the target services. <code>status</code> Check the status of the target services. <code>metad</code> Set the Meta Service as the target service. <code>graphd</code> Set the Graph Service as the target service. <code>storaged</code> Set the Storage Service as the target service. <code>all</code> Set all the NebulaGraph services as the target services."},{"location":"reuse/source_manage-service/#start_nebulagraph","title":"Start NebulaGraph","text":"<p>Run the following command to start NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service start all\n[INFO] Starting nebula-metad...\n[INFO] Done\n[INFO] Starting nebula-graphd...\n[INFO] Done\n[INFO] Starting nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"reuse/source_manage-service/#stop_nebulagraph","title":"Stop NebulaGraph","text":"<p>Danger</p> <p>Do not run <code>kill -9</code> to forcibly terminate the processes. Otherwise, there is a low probability of data loss.</p> <p>Run the following command to stop NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service stop all\n[INFO] Stopping nebula-metad...\n[INFO] Done\n[INFO] Stopping nebula-graphd...\n[INFO] Done\n[INFO] Stopping nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"reuse/source_manage-service/#check_the_service_status","title":"Check the service status","text":"<p>Run the following command to check the service status of NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service status all\n</code></pre> <ul> <li> <p>NebulaGraph is running normally if the following information is returned.</p> <pre><code>INFO] nebula-metad(33fd35e): Running as 29020, Listening on 9559\n[INFO] nebula-graphd(33fd35e): Running as 29095, Listening on 9669\n[WARN] nebula-storaged after v3.0.0 will not start service until it is added to cluster.\n[WARN] See Manage Storage hosts:ADD HOSTS in https://docs.nebula-graph.io/\n[INFO] nebula-storaged(33fd35e): Running as 29147, Listening on 9779\n</code></pre> <p>Note</p> <p>After starting NebulaGraph, the port of the <code>nebula-storaged</code> process is shown in red. Because the <code>nebula-storaged</code> process waits for the <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p> </li> </ul> <ul> <li>If the returned result is similar to the following one, there is a problem. You may also go to the NebulaGraph community for help.<pre><code>[INFO] nebula-metad: Running as 25600, Listening on 9559\n[INFO] nebula-graphd: Exited\n[INFO] nebula-storaged: Running as 25646, Listening on 9779\n</code></pre> </li> </ul> <p>The NebulaGraph services consist of the Meta Service, Graph Service, and Storage Service. The configuration files for all three services are stored in the <code>/usr/local/nebula/etc/</code> directory by default. You can check the configuration files according to the returned result to troubleshoot problems.</p>"},{"location":"reuse/source_manage-service/#next_to_do","title":"Next to do","text":"<p>Connect to NebulaGraph</p>"}]}