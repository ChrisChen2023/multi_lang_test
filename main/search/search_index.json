{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to NebulaGraph 3.6.0 Documentation","text":"<p>Note</p> <p>This manual is revised on 2023-12-27, with GitHub commit 3335991.</p> <p>NebulaGraph is a distributed, scalable, and lightning-fast graph database. It is the optimal solution in the world capable of hosting graphs with dozens of billions of vertices (nodes) and trillions of edges (relationships) with millisecond latency.</p>"},{"location":"#getting_started","title":"Getting started","text":"<ul> <li>Quick start</li> <li>Preparations before deployment</li> <li>nGQL cheatsheet</li> <li>FAQ</li> <li>Ecosystem Tools</li> </ul>"},{"location":"#release_notes","title":"Release notes","text":"<ul> <li>NebulaGraph Community Edition 3.6.0</li> <li>NebulaGraph Dashboard Community</li> <li>NebulaGraph Studio</li> </ul>"},{"location":"#other_sources","title":"Other Sources","text":"<ul> <li>To cite NebulaGraph</li> <li>Forum</li> <li>NebulaGraph Homepage</li> <li>Blogs</li> <li>Videos</li> <li>Chinese Docs</li> </ul>"},{"location":"#symbols_used_in_this_manual","title":"Symbols used in this manual","text":"<p>Note</p> <p>Additional information or operation-related notes.</p> <p>Caution</p> <p>Cautions that need strict observation. If not, systematic breakdown, data loss, and security issues may happen.</p> <p>Danger</p> <p>Operations that may cause danger. If not observed, systematic breakdown, data loss, and security issues will happen.</p> <p>Performance</p> <p>Operations that merit attention as for performance enhancement.</p> <p>Faq</p> <p>Frequently asked questions.</p> <p>Compatibility</p> <p>The compatibility notes between nGQL and openCypher, or between the current version of nGQL and its prior ones. </p> <p>Enterpriseonly</p> <p>Differences between the NebulaGraph Community and Enterprise editions.</p>"},{"location":"#modify_errors","title":"Modify errors","text":"<p>This NebulaGraph manual is written in the Markdown language. Users can click the pencil sign on the upper right side of each document title and modify errors.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/","title":"What is NebulaGraph","text":"<p>NebulaGraph is an open-source, distributed, easily scalable, and native graph database. It is capable of hosting graphs with hundreds of billions of vertices and trillions of edges, and serving queries with millisecond-latency. </p> <p></p>"},{"location":"1.introduction/1.what-is-nebula-graph/#what_is_a_graph_database","title":"What is a graph database","text":"<p>A graph database, such as NebulaGraph, is a database that specializes in storing vast graph networks and retrieving information from them. It efficiently stores data as vertices (nodes) and edges (relationships) in labeled property graphs. Properties can be attached to both vertices and edges. Each vertex can have one or multiple tags (labels).</p> <p></p> <p>Graph databases are well suited for storing most kinds of data models abstracted from reality. Things are connected in almost all fields in the world. Modeling systems like relational databases extract the relationships between entities and squeeze them into table columns alone, with their types and properties stored in other columns or even other tables. This makes data management time-consuming and cost-ineffective.</p> <p>NebulaGraph, as a typical native graph database, allows you to store the rich relationships as edges with edge types and properties directly attached to them.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#advantages_of_nebulagraph","title":"Advantages of NebulaGraph","text":""},{"location":"1.introduction/1.what-is-nebula-graph/#open_source","title":"Open source","text":"<p>NebulaGraph is open under the Apache 2.0 License. More and more people such as database developers, data scientists, security experts, and algorithm engineers are participating in the designing and development of NebulaGraph. To join the opening of source code and ideas, surf the NebulaGraph GitHub page.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#outstanding_performance","title":"Outstanding performance","text":"<p>Written in C++ and born for graphs, NebulaGraph handles graph queries in milliseconds. Among most databases, NebulaGraph shows superior performance in providing graph data services. The larger the data size, the greater the superiority of NebulaGraph.For more information, see NebulaGraph benchmarking.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#high_scalability","title":"High scalability","text":"<p>NebulaGraph is designed in a shared-nothing architecture and supports scaling in and out without interrupting the database service.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#developer_friendly","title":"Developer friendly","text":"<p>NebulaGraph supports clients in popular programming languages like Java, Python, C++, and Go, and more are under development. For more information, see NebulaGraph clients.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#reliable_access_control","title":"Reliable access control","text":"<p>NebulaGraph supports strict role-based access control and external authentication servers such as LDAP (Lightweight Directory Access Protocol) servers to enhance data security. For more information, see Authentication and authorization.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#diversified_ecosystem","title":"Diversified ecosystem","text":"<p>More and more native tools of NebulaGraph have been released, such as NebulaGraph Studio, NebulaGraph Console, and NebulaGraph Exchange. For more ecosystem tools, see Ecosystem tools overview.</p> <p>Besides, NebulaGraph has the ability to be integrated with many cutting-edge technologies, such as Spark, Flink, and HBase, for the purpose of mutual strengthening in a world of increasing challenges and chances.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#opencypher-compatible_query_language","title":"OpenCypher-compatible query language","text":"<p>The native NebulaGraph Query Language, also known as nGQL, is a declarative, openCypher-compatible textual query language. It is easy to understand and easy to use. For more information, see nGQL guide.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#future-oriented_hardware_with_balanced_reading_and_writing","title":"Future-oriented hardware with balanced reading and writing","text":"<p>Solid-state drives have extremely high performance and they are getting cheaper. NebulaGraph is a product based on SSD. Compared with products based on HDD and large memory, it is more suitable for future hardware trends and easier to achieve balanced reading and writing.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#easy_data_modeling_and_high_flexibility","title":"Easy data modeling and high flexibility","text":"<p>You can easily model the connected data into NebulaGraph for your business without forcing them into a structure such as a relational table, and properties can be added, updated, and deleted freely. For more information, see Data modeling.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#high_popularity","title":"High popularity","text":"<p>NebulaGraph is being used by tech leaders such as Tencent, Vivo, Meituan, and JD Digits. For more information, visit the NebulaGraph official website.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#use_cases","title":"Use cases","text":"<p>NebulaGraph can be used to support various graph-based scenarios. To spare the time spent on pushing the kinds of data mentioned in this section into relational databases and on bothering with join queries, use NebulaGraph.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#fraud_detection","title":"Fraud detection","text":"<p>Financial institutions have to traverse countless transactions to piece together potential crimes and understand how combinations of transactions and devices might be related to a single fraud scheme. This kind of scenario can be modeled in graphs, and with the help of NebulaGraph, fraud rings and other sophisticated scams can be easily detected.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#real-time_recommendation","title":"Real-time recommendation","text":"<p>NebulaGraph offers the ability to instantly process the real-time information produced by a visitor and make accurate recommendations on articles, videos, products, and services.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#intelligent_question-answer_system","title":"Intelligent question-answer system","text":"<p>Natural languages can be transformed into knowledge graphs and stored in NebulaGraph. A question organized in a natural language can be resolved by a semantic parser in an intelligent question-answer system and re-organized. Then, possible answers to the question can be retrieved from the knowledge graph and provided to the one who asked the question.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#social_networking","title":"Social networking","text":"<p>Information on people and their relationships is typical graph data. NebulaGraph can easily handle the social networking information of billions of people and trillions of relationships, and provide lightning-fast queries for friend recommendations and job promotions in the case of massive concurrency.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#related_links","title":"Related links","text":"<ul> <li>Official website</li> <li>Docs</li> <li>Blogs</li> <li>Forum</li> <li>GitHub</li> </ul>"},{"location":"1.introduction/2.1.path/","title":"Path types","text":"<p>In graph theory, a path in a graph is a finite or infinite sequence of edges which joins a sequence of vertices. Paths are fundamental concepts of graph theory.</p> <p>Paths can be categorized into 3 types: <code>walk</code>, <code>trail</code>, and <code>path</code>. For more information, see Wikipedia.</p> <p>The following figure is an example for a brief introduction.</p> <p></p>"},{"location":"1.introduction/2.1.path/#walk","title":"Walk","text":"<p>A <code>walk</code> is a finite or infinite sequence of edges. Both vertices and edges can be repeatedly visited in graph traversal.</p> <p>In the above figure C, D, and E form a cycle. So, this figure contains infinite paths, such as <code>A-&gt;B-&gt;C-&gt;D-&gt;E</code>, <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>, and <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;D</code>.</p> <p>Note</p> <p><code>GO</code> statements use <code>walk</code>.</p>"},{"location":"1.introduction/2.1.path/#trail","title":"Trail","text":"<p>A <code>trail</code> is a finite sequence of edges. Only vertices can be repeatedly visited in graph traversal. The Seven Bridges of K\u00f6nigsberg is a typical <code>trail</code>.</p> <p>In the above figure, edges cannot be repeatedly visited. So, this figure contains finite paths. The longest path in this figure consists of 5 edges: <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>.</p> <p>Note</p> <p><code>MATCH</code>, <code>FIND PATH</code>, and <code>GET SUBGRAPH</code> statements use <code>trail</code>.</p> <p>There are two special cases of trail, <code>cycle</code> and <code>circuit</code>. The following figure is an example for a brief introduction.</p> <p></p> <ul> <li> <p>cycle</p> <p>A <code>cycle</code> refers to a closed <code>trail</code>. Only the terminal vertices can be repeatedly visited. The longest path in this figure consists of 3 edges: <code>A-&gt;B-&gt;C-&gt;A</code> or <code>C-&gt;D-&gt;E-&gt;C</code>.</p> </li> </ul> <ul> <li> <p>circuit</p> <p>A <code>circuit</code> refers to a closed <code>trail</code>. Edges cannot be repeatedly visited in graph traversal. Apart from the terminal vertices, other vertices can also be repeatedly visited. The longest path in this figure: <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;A</code>.</p> </li> </ul>"},{"location":"1.introduction/2.1.path/#path","title":"Path","text":"<p>A <code>path</code> is a finite sequence of edges. Neither vertices nor edges can be repeatedly visited in graph traversal.</p> <p>So, the above figure contains finite paths. The longest path in this figure consists of 4 edges: <code>A-&gt;B-&gt;C-&gt;D-&gt;E</code>.</p>"},{"location":"1.introduction/2.data-model/","title":"Data modeling","text":"<p>A data model is a model that organizes data and specifies how they are related to one another. This topic describes the Nebula\u00a0Graph data model and provides suggestions for data modeling with NebulaGraph.</p>"},{"location":"1.introduction/2.data-model/#data_structures","title":"Data structures","text":"<p>NebulaGraph data model uses six data structures to store data. They are graph spaces, vertices, edges, tags, edge types and properties.</p> <ul> <li>Graph spaces: Graph spaces are used to isolate data from different teams or programs. Data stored in different graph spaces are securely isolated. Storage replications, privileges, and partitions can be assigned.</li> </ul> <ul> <li>Vertices: Vertices are used to store entities.</li> </ul> <ul> <li> <p>In NebulaGraph, vertices are identified with vertex identifiers (i.e. <code>VID</code>). The <code>VID</code> must be unique in the same graph space. VID should be int64, or fixed_string(N).</p> <ul> <li>A vertex has zero to multiple tags.</li> </ul> <p>Compatibility</p> <p>In NebulaGraph 2.x a vertex must have at least one tag. And in NebulaGraph 3.6.0, a tag is not required for a vertex.</p> </li> </ul> <ul> <li>Edges: Edges are used to connect vertices. An edge is a connection or behavior between two vertices.<ul> <li>There can be multiple edges between two vertices.</li> <li>Edges are directed. <code>-&gt;</code> identifies the directions of edges. Edges can be traversed in either direction.</li> <li>An edge is identified uniquely with <code>&lt;a source vertex, an edge type, a rank value, and a destination vertex&gt;</code>. Edges have no EID.</li> <li>An edge must have one and only one edge type.</li> <li>The rank value is an immutable user-assigned 64-bit signed integer. It identifies the edges with the same edge type between two vertices. Edges are sorted by their rank values. The edge with the greatest rank value is listed first. The default rank value is zero.</li> </ul> </li> </ul> <ul> <li>Tags: Tags are used to categorize vertices. Vertices that have the same tag share the same definition of properties.</li> </ul> <ul> <li>Edge types: Edge types are used to categorize edges. Edges that have the same edge type share the same definition of properties.</li> </ul> <ul> <li>Properties: Properties are key-value pairs. Both vertices and edges are containers for properties.</li> </ul> <p>Note</p> <p>Tags and Edge types are similar to \"vertex tables\" and \"edge tables\" in the relational databases.</p>"},{"location":"1.introduction/2.data-model/#directed_property_graph","title":"Directed property graph","text":"<p>NebulaGraph stores data in directed property graphs. A directed property graph has a set of vertices connected by directed edges. Both vertices and edges can have properties. A directed property graph is represented as:</p> <p>G = &lt; V, E, P<sub>V</sub>, P<sub>E</sub> &gt;</p> <ul> <li>V is a set of vertices.</li> <li>E is a set of directed edges.</li> <li>P<sub>V</sub> is the property of vertices.</li> <li>P<sub>E</sub> is the property of edges.</li> </ul> <p>The following table is an example of the structure of the basketball player dataset. We have two types of vertices, that is player and team, and two types of edges, that is serve and follow.</p> Element Name Property name (Data type) Description Tag player name (string) age (int) Represents players in the team. Tag team name (string) Represents the teams. Edge type serve start_year (int)  end_year (int) Represents actions taken by players in the team.An action links a player with a team, and the direction is from a player to a team. Edge type follow degree (int) Represents actions taken by players in the team.An action links a player with another player, and the direction is from one player to the other player. <p>Note</p> <p>NebulaGraph supports only directed edges.</p> <p>Compatibility</p> <p>NebulaGraph 3.6.0 allows dangling edges. Therefore, when adding or deleting, you need to ensure the corresponding source vertex and destination vertex of an edge exist. For details, see INSERT VERTEX, DELETE VERTEX, INSERT EDGE, and DELETE EDGE.</p> <p>The MERGE statement in openCypher is not supported.</p>"},{"location":"1.introduction/3.vid/","title":"VID","text":"<p>In a graph space, a vertex is uniquely identified by its ID, which is called a VID or a Vertex ID.</p>"},{"location":"1.introduction/3.vid/#features","title":"Features","text":"<ul> <li>The data types of VIDs are restricted to <code>FIXED_STRING(&lt;N&gt;)</code> or <code>INT64</code>. One graph space can only select one VID type.</li> </ul> <ul> <li>A VID in a graph space is unique. It functions just as a primary key in a relational database. VIDs in different graph spaces are independent.</li> </ul> <ul> <li>The VID generation method must be set by users, because NebulaGraph does not provide auto increasing ID, or UUID.</li> </ul> <ul> <li> <p>Vertices with the same VID will be identified as the same one. For example:</p> <ul> <li>A VID is the unique identifier of an entity, like a person's ID card number. A tag means the type of an entity,  such as driver, and boss. Different tags define two groups of different properties, such as driving license number, driving age, order amount, order taking alt, and job number, payroll, debt ceiling, business phone number.</li> </ul> <ul> <li>When two <code>INSERT</code> statements (neither uses a parameter of <code>IF NOT EXISTS</code>) with the same VID and tag are operated at the same time, the latter <code>INSERT</code> will overwrite the former.</li> </ul> <ul> <li>When two <code>INSERT</code> statements with the same VID but different tags, like <code>TAG A</code> and <code>TAG B</code>, are operated at the same time, the operation of <code>Tag A</code> will not affect <code>Tag B</code>.</li> </ul> </li> </ul> <ul> <li>VIDs will usually be indexed and stored into memory (in the way of LSM-tree). Thus, direct access to VIDs enjoys peak performance.</li> </ul>"},{"location":"1.introduction/3.vid/#vid_operation","title":"VID Operation","text":"<ul> <li>NebulaGraph 1.x only supports <code>INT64</code> while NebulaGraph 2.x supports <code>INT64</code> and <code>FIXED_STRING(&lt;N&gt;)</code>. In <code>CREATE SPACE</code>, VID types can be set via <code>vid_type</code>.</li> </ul> <ul> <li><code>id()</code> function can be used to specify or locate a VID.</li> </ul> <ul> <li><code>LOOKUP</code> or <code>MATCH</code> statements can be used to find a VID via property index.</li> </ul> <ul> <li>Direct access to vertices statements via VIDs enjoys peak performance, such as <code>DELETE xxx WHERE id(xxx) == \"player100\"</code> or <code>GO FROM \"player100\"</code>. Finding VIDs via properties and then operating the graph will cause poor performance, such as <code>LOOKUP | GO FROM $-.ids</code>, which will run both <code>LOOKUP</code> and <code>|</code> one more time.</li> </ul>"},{"location":"1.introduction/3.vid/#vid_generation","title":"VID Generation","text":"<p>VIDs can be generated via applications. Here are some tips:</p> <ul> <li>(Optimal) Directly take a unique primary key or property as a VID. Property access depends on the VID.</li> </ul> <ul> <li>Generate a VID via a unique combination of properties. Property access depends on property index.</li> </ul> <ul> <li>Generate a VID via algorithms like snowflake. Property access depends on property index.</li> </ul> <ul> <li>If short primary keys greatly outnumber long primary keys, do not enlarge the <code>N</code> of <code>FIXED_STRING(&lt;N&gt;)</code> too much. Otherwise, it will occupy a lot of memory and hard disks, and slow down performance. Generate VIDs via BASE64, MD5, hash by encoding and splicing.</li> </ul> <ul> <li>If you generate int64 VID via hash, the probability of collision is about 1/10 when there are 1 billion vertices. The number of edges has no concern with the probability of collision.</li> </ul>"},{"location":"1.introduction/3.vid/#define_and_modify_a_vid_and_its_data_type","title":"Define and modify a VID and its data type","text":"<p>The data type of a VID must be defined when you create the graph space. Once defined, it cannot be modified.</p> <p>A VID is set when you insert a vertex and cannot be modified. </p>"},{"location":"1.introduction/3.vid/#query_start_vid_and_global_scan","title":"Query <code>start vid</code> and global scan","text":"<p>In most cases, the execution plan of query statements in NebulaGraph (<code>MATCH</code>, <code>GO</code>, and <code>LOOKUP</code>) must query the <code>start vid</code> in a certain way.</p> <p>There are only two ways to locate <code>start vid</code>:</p> <ol> <li> <p>For example, <code>GO FROM \"player100\" OVER</code> explicitly indicates in the statement that <code>start vid</code> is \"player100\".</p> </li> <li> <p>For example, <code>LOOKUP ON player WHERE player.name == \"Tony Parker\"</code> or <code>MATCH (v:player {name:\"Tony Parker\"})</code> locates <code>start vid</code> by the index of the property <code>player.name</code>.</p> </li> </ol>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/","title":"Architecture overview","text":"<p>NebulaGraph consists of three services: the Graph Service, the Storage Service, and the Meta Service. It applies the separation of storage and computing architecture.</p> <p>Each service has its executable binaries and processes launched from the binaries. Users can deploy a NebulaGraph cluster on a single machine or multiple machines using these binaries.</p> <p>The following figure shows the architecture of a typical NebulaGraph cluster.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_meta_service","title":"The Meta Service","text":"<p>The Meta Service in the NebulaGraph architecture is run by the nebula-metad processes. It is responsible for metadata management, such as schema operations, cluster administration, and user privilege management.</p> <p>For details on the Meta Service, see Meta Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_graph_service_and_the_storage_service","title":"The Graph Service and the Storage Service","text":"<p>NebulaGraph applies the separation of storage and computing architecture. The Graph Service is responsible for querying. The Storage Service is responsible for storage. They are run by different processes, i.e., nebula-graphd and nebula-storaged. The benefits of the separation of storage and computing architecture are as follows:</p> <ul> <li>Great scalability<p>The separated structure makes both the Graph Service and the Storage Service flexible and easy to scale in or out.</p> </li> </ul> <ul> <li>High availability<p>If part of the Graph Service fails, the data stored by the Storage Service suffers no loss. And if the rest part of the Graph Service is still able to serve the clients, service recovery can be performed quickly, even unfelt by the users.</p> </li> </ul> <ul> <li>Cost-effective<p>The separation of storage and computing architecture provides a higher resource utilization rate, and it enables clients to manage the cost flexibly according to business demands.</p> </li> </ul> <ul> <li>Open to more possibilities<p>With the ability to run separately, the Graph Service may work with multiple types of storage engines, and the Storage Service may also serve more types of computing engines.</p> </li> </ul> <p>For details on the Graph Service and the Storage Service, see Graph Service and Storage Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/","title":"Meta Service","text":"<p>This topic introduces the architecture and functions of the Meta Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#the_architecture_of_the_meta_service","title":"The architecture of the Meta Service","text":"<p>The architecture of the Meta Service is as follows:</p> <p></p> <p>The Meta Service is run by nebula-metad processes. Users can deploy nebula-metad processes according to the scenario:</p> <ul> <li>In a test environment, users can deploy one or three nebula-metad processes on different machines or a single machine.</li> <li>In a production environment, we recommend that users deploy three nebula-metad processes on different machines for high availability.</li> </ul> <p>All the nebula-metad processes form a Raft-based cluster, with one process as the leader and the others as the followers.</p> <p>The leader is elected by the majorities and only the leader can provide service to the clients or other components of NebulaGraph. The followers will be run in a standby way and each has a data replication of the leader. Once the leader fails, one of the followers will be elected as the new leader.</p> <p>Note</p> <p>The data of the leader and the followers will keep consistent through Raft. Thus the breakdown and election of the leader will not cause data inconsistency. For more information on Raft, see Storage service architecture.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#functions_of_the_meta_service","title":"Functions of the Meta Service","text":""},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_user_accounts","title":"Manages user accounts","text":"<p>The Meta Service stores the information of user accounts and the privileges granted to the accounts. When the clients send queries to the Meta Service through an account, the Meta Service checks the account information and whether the account has the right privileges to execute the queries or not.</p> <p>For more information on NebulaGraph access control, see Authentication.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_partitions","title":"Manages partitions","text":"<p>The Meta Service stores and manages the locations of the storage partitions and helps balance the partitions.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_graph_spaces","title":"Manages graph spaces","text":"<p>NebulaGraph supports multiple graph spaces. Data stored in different graph spaces are securely isolated. The Meta Service stores the metadata of all graph spaces and tracks the changes of them, such as adding or dropping a graph space.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_schema_information","title":"Manages schema information","text":"<p>NebulaGraph is a strong-typed graph database. Its schema contains tags (i.e., the vertex types), edge types, tag properties, and edge type properties.</p> <p>The Meta Service stores the schema information. Besides, it performs the addition, modification, and deletion of the schema, and logs the versions of them.</p> <p>For more information on NebulaGraph schema, see Data model.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_ttl_information","title":"Manages TTL information","text":"<p>The Meta Service stores the definition of TTL (Time to Live) options which are used to control data expiration. The Storage Service takes care of the expiring and evicting processes. For more information, see TTL.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_jobs","title":"Manages jobs","text":"<p>The Job Management module in the Meta Service is responsible for the creation, queuing, querying, and deletion of jobs.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/","title":"Graph Service","text":"<p>The Graph Service is used to process the query. It has four submodules: Parser, Validator, Planner, and Executor. This topic will describe the Graph Service accordingly.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#the_architecture_of_the_graph_service","title":"The architecture of the Graph Service","text":"<p>After a query is sent to the Graph Service, it will be processed by the following four submodules:</p> <ol> <li> <p>Parser: Performs lexical analysis and syntax analysis.</p> </li> <li> <p>Validator: Validates the statements.</p> </li> <li> <p>Planner: Generates and optimizes the execution plans.</p> </li> <li> <p>Executor: Executes the plans with operators.</p> </li> </ol>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#parser","title":"Parser","text":"<p>After receiving a request, the statements will be parsed by Parser composed of Flex (lexical analysis tool) and Bison (syntax analysis tool), and its corresponding AST will be generated. Statements will be directly intercepted in this stage because of their invalid syntax.</p> <p>For example, the structure of the AST of <code>GO FROM \"Tim\" OVER like WHERE properties(edge).likeness &gt; 8.0 YIELD dst(edge)</code> is shown in the following figure.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#validator","title":"Validator","text":"<p>Validator performs a series of validations on the AST. It mainly works on these tasks:</p> <ul> <li>Validating metadata<p>Validator will validate whether the metadata is correct or not.</p> <p>When parsing the <code>OVER</code>, <code>WHERE</code>, and <code>YIELD</code> clauses, Validator looks up the Schema and verifies whether the edge type and tag data exist or not. For an <code>INSERT</code> statement, Validator verifies whether the types of the inserted data are the same as the ones defined in the Schema.</p> </li> </ul> <ul> <li>Validating contextual reference<p>Validator will verify whether the cited variable exists or not, or whether the cited property is variable or not.</p> <p>For composite statements, like <code>$var = GO FROM \"Tim\" OVER like YIELD dst(edge) AS ID; GO FROM $var.ID OVER serve YIELD dst(edge)</code>, Validator verifies first to see if <code>var</code> is defined, and then to check if the <code>ID</code> property is attached to the <code>var</code> variable.</p> </li> </ul> <ul> <li>Validating type inference<p>Validator infers what type the result of an expression is and verifies the type against the specified clause.</p> <p>For example, the <code>WHERE</code> clause requires the result to be a <code>bool</code> value, a <code>NULL</code> value, or <code>empty</code>.</p> </li> </ul> <ul> <li>Validating the information of <code>*</code><p>Validator needs to verify all the Schema that involves <code>*</code> when verifying the clause if there is a <code>*</code> in the statement.</p> <p>Take a statement like <code>GO FROM \"Tim\" OVER * YIELD dst(edge), properties(edge).likeness, dst(edge)</code> as an example. When verifying the <code>OVER</code> clause, Validator needs to verify all the edge types. If the edge type includes <code>like</code> and <code>serve</code>, the statement would be <code>GO FROM \"Tim\" OVER like,serve YIELD dst(edge), properties(edge).likeness, dst(edge)</code>.</p> </li> </ul> <ul> <li>Validating input and output<p>Validator will check the consistency of the clauses before and after the <code>|</code>.</p> <p>In the statement <code>GO FROM \"Tim\" OVER like YIELD dst(edge) AS ID | GO FROM $-.ID OVER serve YIELD dst(edge)</code>, Validator will verify whether <code>$-.ID</code> is defined in the clause before the <code>|</code>.</p> </li> </ul> <p>When the validation succeeds, an execution plan will be generated. Its data structure will be stored in the <code>src/planner</code> directory.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#planner","title":"Planner","text":"<p>In the <code>nebula-graphd.conf</code> file, when <code>enable_optimizer</code> is set to be <code>false</code>, Planner will not optimize the execution plans generated by Validator. It will be executed by Executor directly.</p> <p>In the <code>nebula-graphd.conf</code> file, when <code>enable_optimizer</code> is set to be <code>true</code>, Planner will optimize the execution plans generated by Validator. The structure is as follows.</p> <p></p> <ul> <li>Before optimization<p>In the execution plan on the right side of the preceding figure, each node directly depends on other nodes. For example, the root node <code>Project</code> depends on the <code>Filter</code> node, the <code>Filter</code> node depends on the <code>GetNeighbor</code> node, and so on, up to the leaf node <code>Start</code>. Then the execution plan is (not truly) executed.</p> <p>During this stage, every node has its input and output variables, which are stored in a hash table. The execution plan is not truly executed, so the value of each key in the associated hash table is empty (except for the <code>Start</code> node, where the input variables hold the starting data), and the hash table is defined in <code>src/context/ExecutionContext.cpp</code> under the <code>nebula-graph</code> repository.</p> <p>For example, if the hash table is named as <code>ResultMap</code> when creating the <code>Filter</code> node, users can determine that the node takes data from <code>ResultMap[\"GN1\"]</code>, then puts the result into <code>ResultMap[\"Filter2\"]</code>, and so on. All these work as the input and output of each node.</p> </li> </ul> <ul> <li>Process of optimization<p>The optimization rules that Planner has implemented so far are considered RBO (Rule-Based Optimization), namely the pre-defined optimization rules. The CBO (Cost-Based Optimization) feature is under development. The optimized code is in the <code>src/optimizer/</code> directory under the <code>nebula-graph</code> repository.</p> <p>RBO is a \u201cbottom-up\u201d exploration process. For each rule, the root node of the execution plan (in this case, the <code>Project</code> node) is the entry point, and step by step along with the node dependencies, it reaches the node at the bottom to see if it matches the rule.</p> <p>As shown in the preceding figure, when the <code>Filter</code> node is explored, it is found that its children node is <code>GetNeighbors</code>, which matches successfully with the pre-defined rules, so a transformation is initiated to integrate the <code>Filter</code> node into the <code>GetNeighbors</code> node, the <code>Filter</code> node is removed, and then the process continues to the next rule. Therefore, when the <code>GetNeighbor</code> operator calls interfaces of the Storage layer to get the neighboring edges of a vertex during the execution stage, the Storage layer will directly filter out the unqualified edges internally. Such optimization greatly reduces the amount of data transfer, which is commonly known as filter pushdown.</p> </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#executor","title":"Executor","text":"<p>The Executor module consists of Scheduler and Executor. The Scheduler generates the corresponding execution operators against the execution plan, starting from the leaf nodes and ending at the root node. The structure is as follows.</p> <p></p> <p>Each node of the execution plan has one execution operator node, whose input and output have been determined in the execution plan. Each operator only needs to get the values for the input variables, compute them, and finally put the results into the corresponding output variables. Therefore, it is only necessary to execute step by step from <code>Start</code>, and the result of the last operator is returned to the user as the final result.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#source_code_hierarchy","title":"Source code hierarchy","text":"<p>The source code hierarchy under the nebula-graph repository is as follows.</p> <pre><code>|--src\n   |--graph\n      |--context    //contexts for validation and execution\n      |--executor   //execution operators\n      |--gc         //garbage collector\n      |--optimizer  //optimization rules\n      |--planner    //structure of the execution plans\n      |--scheduler  //scheduler\n      |--service    //external service management\n      |--session    //session management\n      |--stats      //monitoring metrics\n      |--util       //basic components\n      |--validator  //validation of the statements\n      |--visitor    //visitor expression\n</code></pre>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/","title":"Storage Service","text":"<p>The persistent data of NebulaGraph have two parts. One is the Meta Service that stores the meta-related data.</p> <p>The other is the Storage Service that stores the data, which is run by the nebula-storaged process. This topic will describe the architecture of the Storage Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#advantages","title":"Advantages","text":"<ul> <li>High performance (Customized built-in KVStore)</li> </ul> <ul> <li>Great scalability (Shared-nothing architecture, not rely on NAS/SAN-like devices)</li> </ul> <ul> <li>Strong consistency (Raft)</li> </ul> <ul> <li>High availability (Raft)</li> </ul> <ul> <li>Supports synchronizing with the third party systems, such as Elasticsearch.</li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#the_architecture_of_the_storage_service","title":"The architecture of the Storage Service","text":"<p>The Storage Service is run by the nebula-storaged process. Users can deploy nebula-storaged processes on different occasions. For example, users can deploy 1 nebula-storaged process in a test environment and deploy 3 nebula-storaged processes in a production environment.</p> <p>All the nebula-storaged processes consist of a Raft-based cluster. There are three layers in the Storage Service:</p> <ul> <li> <p>Storage interface</p> <p>The top layer is the storage interface. It defines a set of APIs that are related to the graph concepts. These API requests will be translated into a set of KV operations targeting the corresponding Partition. For example:</p> <ul> <li><code>getNeighbors</code>: queries the in-edge or out-edge of a set of vertices, returns the edges and the corresponding properties, and supports conditional filtering.</li> </ul> <ul> <li><code>insert vertex/edge</code>: inserts a vertex or edge and its properties.</li> </ul> <ul> <li><code>getProps</code>: gets the properties of a vertex or an edge.</li> </ul> <p>It is this layer that makes the Storage Service a real graph storage. Otherwise, it is just a KV storage.</p> </li> </ul> <ul> <li> <p>Consensus</p> <p>Below the storage interface is the consensus layer that implements Multi Group Raft, which ensures the strong consistency and high availability of the Storage Service.</p> </li> </ul> <ul> <li> <p>Store engine</p> <p>The bottom layer is the local storage engine library, providing operations like <code>get</code>, <code>put</code>, and <code>scan</code> on local disks. The related interfaces are stored in <code>KVStore.h</code> and <code>KVEngine.h</code> files. You can develop your own local store plugins based on your needs.</p> </li> </ul> <p>The following will describe some features of the Storage Service based on the above architecture.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#storage_writing_process","title":"Storage writing process","text":""},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#kvstore","title":"KVStore","text":"<p>NebulaGraph develops and customizes its built-in KVStore for the following reasons.</p> <ul> <li>It is a high-performance KVStore.</li> </ul> <ul> <li>It is provided as a (kv) library and can be easily developed for the filter pushdown purpose. As a strong-typed database, how to provide Schema during pushdown is the key to efficiency for NebulaGraph.</li> </ul> <ul> <li>It has strong data consistency.</li> </ul> <p>Therefore, NebulaGraph develops its own KVStore with RocksDB as the local storage engine. The advantages are as follows.</p> <ul> <li>For multiple local hard disks, NebulaGraph can make full use of its concurrent capacities through deploying multiple data directories.</li> </ul> <ul> <li> <p>The Meta Service manages all the Storage servers. All the partition distribution data and current machine status can be found in the meta service. Accordingly, users can execute a manual load balancing plan in meta service.</p> <p>Note</p> <p>NebulaGraph does not support auto load balancing because auto data transfer will affect online business.</p> </li> </ul> <ul> <li>NebulaGraph provides its own WAL mode so one can customize the WAL. Each partition owns its WAL.</li> </ul> <ul> <li>One NebulaGraph KVStore cluster supports multiple graph spaces, and each graph space has its own partition number and replica copies. Different graph spaces are isolated physically from each other in the same cluster.</li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#data_storage_structure","title":"Data storage structure","text":"<p>Graphs consist of vertices and edges. NebulaGraph uses key-value pairs to store vertices, edges, and their properties. Vertices and edges are stored in keys and their properties are stored in values. Such structure enables efficient property filtering.</p> <ul> <li> <p>The storage structure of vertices</p> <p>Different from NebulaGraph version 2.x, version 3.x added a new key for each vertex. Compared to the old key that still exists, the new key has no <code>TagID</code> field and no value. Vertices in NebulaGraph can now live without tags owing to the new key.</p> <p></p> Field Description <code>Type</code> One byte, used to indicate the key type. <code>PartID</code> Three bytes, used to indicate the sharding partition and to scan the partition data based on the prefix when re-balancing the partition. <code>VertexID</code> The vertex ID. For an integer VertexID, it occupies eight bytes. However, for a string VertexID, it is changed to <code>fixed_string</code> of a fixed length which needs to be specified by users when they create the space. <code>TagID</code> Four bytes, used to indicate the tags that vertex relate with. <code>SerializedValue</code> The serialized value of the key. It stores the property information of the vertex. </li> </ul> <ul> <li>The storage structure of edges<p></p> Field Description <code>Type</code> One byte, used to indicate the key type. <code>PartID</code> Three bytes, used to indicate the partition ID. This field can be used to scan the partition data based on the prefix when re-balancing the partition. <code>VertexID</code> Used to indicate vertex ID. The former VID refers to the source VID in the outgoing edge and the dest VID in the incoming edge, while the latter VID refers to the dest VID in the outgoing edge and the source VID in the incoming edge. <code>Edge Type</code> Four bytes, used to indicate the edge type. Greater than zero indicates out-edge, less than zero means in-edge. <code>Rank</code> Eight bytes, used to indicate multiple edges in one edge type. Users can set the field based on needs and store weight, such as transaction time and transaction number. <code>PlaceHolder</code> One byte. Reserved. <code>SerializedValue</code> The serialized value of the key. It stores the property information of the edge. </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#property_descriptions","title":"Property descriptions","text":"<p>NebulaGraph uses strong-typed Schema.</p> <p>NebulaGraph will store the properties of vertex and edges in order after encoding them. Since the length of fixed-length properties is fixed, queries can be made in no time according to offset. Before decoding, NebulaGraph needs to get (and cache) the schema information in the Meta Service. In addition, when encoding properties, NebulaGraph will add the corresponding schema version to support online schema change.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#data_partitioning","title":"Data partitioning","text":"<p>Since in an ultra-large-scale relational network, vertices can be as many as tens to hundreds of billions, and edges are even more than trillions. Even if only vertices and edges are stored, the storage capacity of both exceeds that of ordinary servers. Therefore, NebulaGraph uses hash to shard the graph elements and store them in different partitions.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#edge_partitioning_and_storage_amplification","title":"Edge partitioning and storage amplification","text":"<p>In NebulaGraph, an edge corresponds to two key-value pairs on the hard disk. When there are lots of edges and each has many properties, storage amplification will be obvious. The storage format of edges is shown in the figure below.</p> <p></p> <p>In this example, SrcVertex connects DstVertex via EdgeA, forming the path of <code>(SrcVertex)-[EdgeA]-&gt;(DstVertex)</code>. SrcVertex, DstVertex, and EdgeA will all be stored in Partition x and Partition y as four key-value pairs in the storage layer. Details are as follows:</p> <ul> <li>The key value of SrcVertex is stored in Partition x. Key fields include Type, PartID(x), VID(Src), and TagID. SerializedValue, namely Value, refers to serialized vertex properties.</li> </ul> <ul> <li>The first key value of EdgeA, namely EdgeA_Out, is stored in the same partition as the SrcVertex. Key fields include Type, PartID(x), VID(Src), EdgeType(+ means out-edge), Rank(0), VID(Dst), and PlaceHolder. SerializedValue, namely Value, refers to serialized edge properties.</li> </ul> <ul> <li>The key value of DstVertex is stored in Partition y. Key fields include Type, PartID(y), VID(Dst), and TagID. SerializedValue, namely Value, refers to serialized vertex properties.</li> </ul> <ul> <li>The second key value of EdgeA, namely EdgeA_In, is stored in the same partition as the DstVertex. Key fields include Type, PartID(y), VID(Dst), EdgeType(- means in-edge), Rank(0), VID(Src), and PlaceHolder. SerializedValue, namely Value, refers to serialized edge properties, which is exactly the same as that in EdgeA_Out.</li> </ul> <p>EdgeA_Out and EdgeA_In are stored in storage layer with opposite directions, constituting EdgeA logically. EdgeA_Out is used for traversal requests starting from SrcVertex, such as <code>(a)-[]-&gt;()</code>; EdgeA_In is used for traversal requests starting from DstVertex, such as <code>()-[]-&gt;(a)</code>.</p> <p>Like EdgeA_Out and EdgeA_In, NebulaGraph redundantly stores the information of each edge, which doubles the actual capacities needed for edge storage. The key corresponding to the edge occupies a small hard disk space, but the space occupied by Value is proportional to the length and amount of the property value. Therefore, it will occupy a relatively large hard disk space if the property value of the edge is large or there are many edge property values.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#partition_algorithm","title":"Partition algorithm","text":"<p>NebulaGraph uses a static Hash strategy to shard data through a modulo operation on vertex ID. All the out-keys, in-keys, and tag data will be placed in the same partition. In this way, query efficiency is increased dramatically.</p> <p>Note</p> <p>The number of partitions needs to be determined when users are creating a graph space since it cannot be changed afterward. Users are supposed to take into consideration the demands of future business when setting it.</p> <p>When inserting into NebulaGraph, vertices and edges are distributed across different partitions. And the partitions are located on different machines. The number of partitions is set in the CREATE SPACE statement and cannot be changed afterward.</p> <p>If certain vertices need to be placed on the same partition (i.e., on the same machine), see Formula/code.</p> <p>The following code will briefly describe the relationship between VID and partition.</p> <pre><code>// If VertexID occupies 8 bytes, it will be stored in int64 to be compatible with the version 1.0.\nuint64_t vid = 0;\nif (id.size() == 8) {\n    memcpy(static_cast&lt;void*&gt;(&amp;vid), id.data(), 8);\n} else {\n    MurmurHash2 hash;\n    vid = hash(id.data());\n}\nPartitionID pId = vid % numParts + 1;\n</code></pre> <p>Roughly speaking, after hashing a fixed string to int64, (the hashing of int64 is the number itself), do modulo, and then plus one, namely:</p> <pre><code>pId = vid % numParts + 1;\n</code></pre> <p>Parameters and descriptions of the preceding formula are as follows:</p> Parameter Description <code>%</code> The modulo operation. <code>numParts</code> The number of partitions for the graph space where the <code>VID</code> is located, namely the value of <code>partition_num</code> in the CREATE SPACE statement. <code>pId</code> The ID for the partition where the <code>VID</code> is located. <p>Suppose there are 100 partitions, the vertices with <code>VID</code> 1, 101, and 1001 will be stored on the same partition. But, the mapping between the partition ID and the machine address is random. Therefore, we cannot assume that any two partitions are located on the same machine.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#raft","title":"Raft","text":""},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#raft_implementation","title":"Raft implementation","text":"<p>In a distributed system, one data usually has multiple replicas so that the system can still run normally even if a few copies fail. It requires certain technical means to ensure consistency between replicas.</p> <p>Basic principle: Raft is designed to ensure consistency between replicas. Raft uses election between replicas, and the (candidate) replica that wins more than half of the votes will become the Leader, providing external services on behalf of all replicas. The rest Followers will play backups. When the Leader fails (due to communication failure, operation and maintenance commands, etc.), the rest Followers will conduct a new round of elections and vote for a new Leader. The Leader and Followers will detect each other's survival through heartbeats and write them to the hard disk in Raft-wal mode. Replicas that do not respond to more than multiple heartbeats will be considered faulty.</p> <p>Note</p> <p>Raft-wal needs to be written into the hard disk periodically. If hard disk bottlenecks to write, Raft will fail to send a heartbeat and conduct a new round of elections. If the hard disk IO is severely blocked, there will be no Leader for a long time.</p> <p>Read and write: For every writing request of the clients, the Leader will initiate a Raft-wal and synchronize it with the Followers. Only after over half replicas have received the Raft-wal will it return to the clients successfully. For every reading request of the clients, it will get to the Leader directly, while Followers will not be involved.</p> <p>Failure: Scenario 1: Take a (space) cluster of a single replica as an example. If the system has only one replica, the Leader will be itself. If failure happens, the system will be completely unavailable. Scenario 2: Take a (space) cluster of three replicas as an example. If the system has three replicas, one of them will be the Leader and the rest will be the Followers. If the Leader fails, the rest two can still vote for a new Leader (and a Follower), and the system is still available. But if any of the two Followers fails again, the system will be completely unavailable due to inadequate voters.</p> <p>Note</p> <p>Raft and HDFS have different modes of duplication. Raft is based on a quorum vote, so the number of replicas cannot be even.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#multi_group_raft","title":"Multi Group Raft","text":"<p>The Storage Service supports a distributed cluster architecture, so NebulaGraph implements Multi Group Raft according to Raft protocol. Each Raft group stores all the replicas of each partition. One replica is the leader, while others are followers. In this way, NebulaGraph achieves strong consistency and high availability. The functions of Raft are as follows.</p> <p>NebulaGraph uses Multi Group Raft to improve performance when there are many partitions because Raft-wal cannot be NULL. When there are too many partitions, costs will increase, such as storing information in Raft group, WAL files, or batch operation in low load.</p> <p>There are two key points to implement the Multi Raft Group:</p> <ul> <li> <p>To share transport layer</p> <p>Each Raft Group sends messages to its corresponding peers. So if the transport layer cannot be shared, the connection costs will be very high.</p> </li> </ul> <ul> <li> <p>To share thread pool</p> <p>Raft Groups share the same thread pool to prevent starting too many threads and a high context switch cost.</p> </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#batch","title":"Batch","text":"<p>For each partition, it is necessary to do a batch to improve throughput when writing the WAL serially. As NebulaGraph uses WAL to implement some special functions, batches need to be grouped, which is a feature of NebulaGraph.</p> <p>For example, lock-free CAS operations will execute after all the previous WALs are committed. So for a batch, if there are several WALs in CAS type, we need to divide this batch into several smaller groups and make sure they are committed serially.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#transfer_leadership","title":"Transfer Leadership","text":"<p>Transfer leadership is extremely important for balance. When moving a partition from one machine to another, NebulaGraph first checks if the source is a leader. If so, it should be moved to another peer. After data migration is completed, it is important to balance leader distribution again.</p> <p>When a transfer leadership command is committed, the leader will abandon its leadership and the followers will start a leader election.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#peer_changes","title":"Peer changes","text":"<p>To avoid split-brain, when members in a Raft Group change, an intermediate state is required. In such a state, the quorum of the old group and new group always have an overlap. Thus it prevents the old or new group from making decisions unilaterally. To make it even simpler, in his doctoral thesis Diego Ongaro suggests adding or removing a peer once to ensure the overlap between the quorum of the new group and the old group. NebulaGraph also uses this approach, except that the way to add or remove a member is different. For details, please refer to addPeer/removePeer in the Raft Part class.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#differences_with_hdfs","title":"Differences with HDFS","text":"<p>The Storage Service is a Raft-based distributed architecture, which has certain differences with that of HDFS. For example:</p> <ul> <li>The Storage Service ensures consistency through Raft. Usually, the number of its replicas is odd to elect a leader. However, DataNode used by HDFS ensures consistency through NameNode, which has no limit on the number of replicas.</li> </ul> <ul> <li>In the Storage Service, only the replicas of the leader can read and write, while in HDFS all the replicas can do so.</li> </ul> <ul> <li>In the Storage Service, the number of replicas needs to be determined when creating a space, since it cannot be changed afterward. But in HDFS, the number of replicas can be changed freely.</li> </ul> <ul> <li>The Storage Service can access the file system directly. While the applications of HDFS (such as HBase) have to access HDFS before the file system, which requires more RPC times.</li> </ul> <p>In a word, the Storage Service is more lightweight with some functions simplified and its architecture is simpler than HDFS, which can effectively improve the read and write performance of a smaller block of data.</p>"},{"location":"2.quick-start/1.quick-start-workflow0/","title":"Quickly deploy NebulaGraph using Docker","text":"<p>You can quickly get started with NebulaGraph by deploying NebulaGraph with Docker Desktop or Docker Compose. </p> <p>=== \"Using Docker Desktop\"</p> <pre><code>NebulaGraph is available as a [Docker Extension](https://hub.docker.com/extensions/weygu/nebulagraph-dd-ext) that you can easily install and run on your Docker Desktop. You can quickly deploy NebulaGraph using Docker Desktop with just one click.\n\n1. Install Docker Desktop\n\n  - [Install Docker Desktop on Mac](https://docs.docker.com/docker-for-mac/install/)\n  - [Install Docker Desktop on Windows](https://docs.docker.com/docker-for-windows/install/)\n\n  !!! caution\n      To install Docker Desktop, you need to install [WSL 2](https://docs.docker.com/desktop/install/windows-install/#system-requirements) first.\n\n2. In the left sidebar of Docker Desktop, click **Extensions** or **Add Extensions**.\n3. On the Extensions Marketplace, search for NebulaGraph and click **Install**.\n\n  ![docker](https://docs-cdn.nebula-graph.com.cn/figures/docker.png)\n\n  Click **Update** to update NebulaGraph to the latest version when a new version is available.\n\n  ![docker-update](https://docs-cdn.nebula-graph.com.cn/figures/docker-update.png)\n\n4. Click **Open** to navigate to the NebulaGraph extension page.\n\n5. At the top of the page, click **Studio in Browser** to use NebulaGraph.\n\nFor more information about how to use NebulaGraph with Docker Desktop, see the following video:\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/8zKer-4RXEg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen&gt;&lt;/iframe&gt;\n</code></pre> <p>=== \"Using Docker Compose\"</p> <pre><code>Using Docker Compose can quickly deploy NebulaGraph services based on the prepared configuration file. It is only recommended to use this method when testing the functions of NebulaGraph.\n\n## Prerequisites\n\n* You have installed the following applications on your host.\n\n  | Application    | Recommended version | Official installation reference                                    |\n  | -------------- | ------------------- | ------------------------------------------------------------------ |\n  | Docker         | Latest              | [Install Docker Engine](https://docs.docker.com/engine/install/)   |\n  | Docker Compose | Latest              | [Install Docker Compose](https://docs.docker.com/compose/install/) |\n  | Git            | Latest              | [Download Git](https://git-scm.com/download/)       |\n\n* If you are deploying NebulaGraph as a non-root user, grant the user with Docker-related privileges. For detailed instructions, see [Manage Docker as a non-root user](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user).\n\n* You have started the Docker service on your host.\n\n* If you have already deployed another version of NebulaGraph with Docker Compose on your host, to avoid compatibility issues, you need to delete the `nebula-docker-compose/data` directory.\n\n## Deploy NebulaGraph\n\n\n1. Clone the `3.6.0` branch of the `nebula-docker-compose` repository to your host with Git.\n\n  !!! danger\n\n        The `master` branch contains the untested code for the latest NebulaGraph development release. **DO NOT** use this release in a production environment.\n\n    ```bash\n    $ git clone -b release-3.6 https://github.com/vesoft-inc/nebula-docker-compose.git\n    ```\n\n  !!! Note\n\n        The `x.y` version of Docker Compose aligns to the `x.y` version of NebulaGraph. For the NebulaGraph `z` version, Docker Compose does not publish the corresponding `z` version, but pulls the `z` version of the NebulaGraph image.\n\n2. Go to the `nebula-docker-compose` directory.\n\n    ```bash\n    $ cd nebula-docker-compose/\n    ```\n\n3. Run the following command to start all the NebulaGraph services.\n\n\n  !!! Note\n\n        - Update the [NebulaGraph images](#how_to_upgrade_or_update_the_docker_images_of_nebulagraph_services) and [NebulaGraph Console images](#how_to_update_the_nebulagraph_console_client) first if they are out of date.\n        - The return result after executing the command varies depending on the installation directory.\n\n    ```bash\n    [nebula-docker-compose]$ docker-compose up -d\n    Creating nebula-docker-compose_metad0_1 ... done\n    Creating nebula-docker-compose_metad2_1 ... done\n    Creating nebula-docker-compose_metad1_1 ... done\n    Creating nebula-docker-compose_graphd2_1   ... done\n    Creating nebula-docker-compose_graphd_1    ... done\n    Creating nebula-docker-compose_graphd1_1   ... done\n    Creating nebula-docker-compose_storaged0_1 ... done\n    Creating nebula-docker-compose_storaged2_1 ... done\n    Creating nebula-docker-compose_storaged1_1 ... done\n    ```\n\n  !!! compatibility\n\n        Starting from NebulaGraph version 3.1.0, nebula-docker-compose automatically starts a NebulaGraph Console docker container and adds the storage host to the cluster (i.e. `ADD HOSTS` command).\n\n  !!! note\n\n        For more information of the preceding services, see [NebulaGraph architecture](../1.introduction/3.nebula-graph-architecture/1.architecture-overview.md).\n\n## Connect to NebulaGraph\n\nThere are two ways to connect to NebulaGraph:\n\n- Connected with Nebula Console outside the container. Because the external mapping port for the Graph service is also fixed as `9669` in the container's configuration file, you can connect directly through the default port. For details, see [Connect to NebulaGraph](../2.quick-start/3.connect-to-nebula-graph.md).\n\n- Log into the container installed NebulaGraph Console, then connect to the Graph service. This section describes this approach.\n\n1. Run the following command to view the name of NebulaGraph Console docker container.\n\n  ```bash\n  $ docker-compose ps\n            Name                         Command             State                 Ports\n  --------------------------------------------------------------------------------------------\n  nebula-docker-compose_console_1     sh -c sleep 3 &amp;&amp;          Up\n                                    nebula-co ...\n  ......\n  ```\n\n2. Run the following command to enter the NebulaGraph Console docker container.\n\n  ```bash\n  docker exec -it nebula-docker-compose_console_1 /bin/sh\n  / #\n  ```\n\n3. Connect to NebulaGraph with NebulaGraph Console.\n\n  ```bash\n  / # ./usr/local/bin/nebula-console -u &lt;user_name&gt; -p &lt;password&gt; --address=graphd --port=9669\n  ```\n\n  !!! Note\n\n        By default, the authentication is off, you can only log in with an existing username (the default is `root`) and any password. To turn it on, see [Enable authentication](../7.data-security/1.authentication/1.authentication.md).\n\n4. Run the following commands to view the cluster state.\n\n  ```bash\n  nebula&gt; SHOW HOSTS;\n  +-------------+------+----------+--------------+----------------------+------------------------+---------+\n  | Host        | Port | Status   | Leader count | Leader distribution  | Partition distribution | Version |\n  +-------------+------+----------+--------------+----------------------+------------------------+---------+\n  | \"storaged0\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.6.0\" |\n  | \"storaged1\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.6.0\" |\n  | \"storaged2\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.6.0\" |\n  +-------------+------+----------+--------------+----------------------+------------------------+---------+\n  ```\n\nRun `exit` twice to switch back to your terminal (shell).\n\n## Check the NebulaGraph service status and ports\n\nRun `docker-compose ps` to list all the services of NebulaGraph and their status and ports.\n\n!!! note\n\n    NebulaGraph provides services to the clients through port `9669` by default. To use other ports, modify the `docker-compose.yaml` file in the `nebula-docker-compose` directory and restart the NebulaGraph services.\n\n```bash\n$ docker-compose ps\nnebula-docker-compose_console_1     sh -c sleep 3 &amp;&amp;                 Up\n                                  nebula-co ...\nnebula-docker-compose_graphd1_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49174-&gt;19669/tcp,:::49174-&gt;19669/tcp, 0.0.0.0:49171-&gt;19670/tcp,:::49171-&gt;19670/tcp, 0.0.0.0:49177-&gt;9669/tcp,:::49177-&gt;9669/tcp\nnebula-docker-compose_graphd2_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49175-&gt;19669/tcp,:::49175-&gt;19669/tcp, 0.0.0.0:49172-&gt;19670/tcp,:::49172-&gt;19670/tcp, 0.0.0.0:49178-&gt;9669/tcp,:::49178-&gt;9669/tcp\nnebula-docker-compose_graphd_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49180-&gt;19669/tcp,:::49180-&gt;19669/tcp, 0.0.0.0:49179-&gt;19670/tcp,:::49179-&gt;19670/tcp, 0.0.0.0:9669-&gt;9669/tcp,:::9669-&gt;9669/tcp\nnebula-docker-compose_metad0_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49157-&gt;19559/tcp,:::49157-&gt;19559/tcp, 0.0.0.0:49154-&gt;19560/tcp,:::49154-&gt;19560/tcp, 0.0.0.0:49160-&gt;9559/tcp,:::49160-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad1_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49156-&gt;19559/tcp,:::49156-&gt;19559/tcp, 0.0.0.0:49153-&gt;19560/tcp,:::49153-&gt;19560/tcp, 0.0.0.0:49159-&gt;9559/tcp,:::49159-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad2_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49158-&gt;19559/tcp,:::49158-&gt;19559/tcp, 0.0.0.0:49155-&gt;19560/tcp,:::49155-&gt;19560/tcp, 0.0.0.0:49161-&gt;9559/tcp,:::49161-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_storaged0_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49166-&gt;19779/tcp,:::49166-&gt;19779/tcp, 0.0.0.0:49163-&gt;19780/tcp,:::49163-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49169-&gt;9779/tcp,:::49169-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged1_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49165-&gt;19779/tcp,:::49165-&gt;19779/tcp, 0.0.0.0:49162-&gt;19780/tcp,:::49162-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49168-&gt;9779/tcp,:::49168-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged2_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49167-&gt;19779/tcp,:::49167-&gt;19779/tcp, 0.0.0.0:49164-&gt;19780/tcp,:::49164-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49170-&gt;9779/tcp,:::49170-&gt;9779/tcp, 9780/tcp\n```\n\nIf the service is abnormal, you can first confirm the abnormal container name (such as `nebula-docker-compose_graphd2_1`).\n\nThen you can execute `docker ps` to view the corresponding `CONTAINER ID` (such as `2a6c56c405f5`).\n\n```bash\n[nebula-docker-compose]$ docker ps\nCONTAINER ID   IMAGE                               COMMAND                  CREATED          STATUS                    PORTS                                                                                                  NAMES\n2a6c56c405f5   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:49230-&gt;9669/tcp, 0.0.0.0:49229-&gt;19669/tcp, 0.0.0.0:49228-&gt;19670/tcp                            nebula-docker-compose_graphd2_1\n7042e0a8e83d   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49227-&gt;9779/tcp, 0.0.0.0:49226-&gt;19779/tcp, 0.0.0.0:49225-&gt;19780/tcp   nebula-docker-compose_storaged2_1\n18e3ea63ad65   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49219-&gt;9779/tcp, 0.0.0.0:49218-&gt;19779/tcp, 0.0.0.0:49217-&gt;19780/tcp   nebula-docker-compose_storaged0_1\n4dcabfe8677a   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:49224-&gt;9669/tcp, 0.0.0.0:49223-&gt;19669/tcp, 0.0.0.0:49222-&gt;19670/tcp                            nebula-docker-compose_graphd1_1\na74054c6ae25   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:9669-&gt;9669/tcp, 0.0.0.0:49221-&gt;19669/tcp, 0.0.0.0:49220-&gt;19670/tcp                             nebula-docker-compose_graphd_1\n880025a3858c   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49216-&gt;9779/tcp, 0.0.0.0:49215-&gt;19779/tcp, 0.0.0.0:49214-&gt;19780/tcp   nebula-docker-compose_storaged1_1\n45736a32a23a   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49213-&gt;9559/tcp, 0.0.0.0:49212-&gt;19559/tcp, 0.0.0.0:49211-&gt;19560/tcp                  nebula-docker-compose_metad0_1\n3b2c90eb073e   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49207-&gt;9559/tcp, 0.0.0.0:49206-&gt;19559/tcp, 0.0.0.0:49205-&gt;19560/tcp                  nebula-docker-compose_metad2_1\n7bb31b7a5b3f   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49210-&gt;9559/tcp, 0.0.0.0:49209-&gt;19559/tcp, 0.0.0.0:49208-&gt;19560/tcp                  nebula-docker-compose_metad1_1\n```\n\nUse the `CONTAINER ID` to log in the container and troubleshoot.\n\n```bash\nnebula-docker-compose]$ docker exec -it 2a6c56c405f5 bash\n[root@2a6c56c405f5 nebula]#\n```\n\n## Check the service data and logs\n\nAll the data and logs of NebulaGraph are stored persistently in the `nebula-docker-compose/data` and `nebula-docker-compose/logs` directories.\n\nThe structure of the directories is as follows:\n\n```text\nnebula-docker-compose/\n  |-- docker-compose.yaml\n  \u251c\u2500\u2500 data\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta1\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta2\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage1\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 storage2\n  \u2514\u2500\u2500 logs\n      \u251c\u2500\u2500 graph\n      \u251c\u2500\u2500 graph1\n      \u251c\u2500\u2500 graph2\n      \u251c\u2500\u2500 meta0\n      \u251c\u2500\u2500 meta1\n      \u251c\u2500\u2500 meta2\n      \u251c\u2500\u2500 storage0\n      \u251c\u2500\u2500 storage1\n      \u2514\u2500\u2500 storage2\n```\n\n## Stop the NebulaGraph services\n\nYou can run the following command to stop the NebulaGraph services:\n\n```bash\n$ docker-compose down\n```\n\nThe following information indicates you have successfully stopped the NebulaGraph services:\n\n```bash\nStopping nebula-docker-compose_console_1   ... done\nStopping nebula-docker-compose_graphd1_1   ... done\nStopping nebula-docker-compose_graphd_1    ... done\nStopping nebula-docker-compose_graphd2_1   ... done\nStopping nebula-docker-compose_storaged1_1 ... done\nStopping nebula-docker-compose_storaged0_1 ... done\nStopping nebula-docker-compose_storaged2_1 ... done\nStopping nebula-docker-compose_metad2_1    ... done\nStopping nebula-docker-compose_metad0_1    ... done\nStopping nebula-docker-compose_metad1_1    ... done\nRemoving nebula-docker-compose_console_1   ... done\nRemoving nebula-docker-compose_graphd1_1   ... done\nRemoving nebula-docker-compose_graphd_1    ... done\nRemoving nebula-docker-compose_graphd2_1   ... done\nRemoving nebula-docker-compose_storaged1_1 ... done\nRemoving nebula-docker-compose_storaged0_1 ... done\nRemoving nebula-docker-compose_storaged2_1 ... done\nRemoving nebula-docker-compose_metad2_1    ... done\nRemoving nebula-docker-compose_metad0_1    ... done\nRemoving nebula-docker-compose_metad1_1    ... done\nRemoving network nebula-docker-compose_nebula-net\n```\n\n!!! danger\n\n    The parameter `-v` in the command `docker-compose down -v` will **delete** all your local NebulaGraph storage data. Try this command if you are using the nightly release and having some compatibility issues.\n\n## Modify configurations\n\nThe configuration file of NebulaGraph deployed by Docker Compose is `nebula-docker-compose/docker-compose.yaml`. To make the new configuration take effect, modify the configuration in this file and restart the service.\n\nFor more instructions, see [Configurations](../5.configurations-and-logs/1.configurations/1.configurations.md).\n\n## FAQ\n\n### How to fix the docker mapping to external ports?\n\nTo set the `ports` of corresponding services as fixed mapping, modify the `docker-compose.yaml` in the `nebula-docker-compose` directory. For example:\n\n```bash\ngraphd:\n    image: vesoft/nebula-graphd:release-3.6\n    ...\n    ports:\n      - 9669:9669\n      - 19669\n      - 19670\n```\n\n`9669:9669` indicates the internal port 9669 is uniformly mapped to external ports, while `19669` indicates the internal port 19669 is randomly mapped to external ports.\n\n### How to upgrade or update the docker images of NebulaGraph services\n\n5. In the `nebula-docker-compose/docker-compose.yaml` file, change all the `image` values to the required image version.\n\n6. In the `nebula-docker-compose` directory, run `docker-compose pull` to update the images of the Graph Service, Storage Service, Meta Service, and NebulaGraph Console.\n\n7. Run `docker-compose up -d` to start the NebulaGraph services again.\n\n8. After connecting to NebulaGraph with NebulaGraph Console, run `SHOW HOSTS GRAPH`, `SHOW HOSTS STORAGE`, or `SHOW HOSTS META` to check the version of the responding service respectively.\n\n### `ERROR: toomanyrequests` when `docker-compose pull`\n\nYou may meet the following error.\n\n`ERROR: toomanyrequests: You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: https://www.docker.com/increase-rate-limit`.\n\nYou have met the rate limit of Docker Hub. Learn more on [Understanding Docker Hub Rate Limiting](https://www.docker.com/increase-rate-limit).\n\n### How to update the NebulaGraph Console client\n\nThe command `docker-compose pull` updates both the NebulaGraph services and the NebulaGraph Console.\n</code></pre>"},{"location":"2.quick-start/2.install-nebula-graph/","title":"Step 1: Install NebulaGraph","text":"<p>RPM and DEB are common package formats on Linux systems. This topic shows how to quickly install NebulaGraph with the RPM or DEB package.</p> <p>Note</p> <p>The console is not complied or packaged with NebulaGraph server binaries. You can install nebula-console by yourself.</p>"},{"location":"2.quick-start/2.install-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>The tool <code>wget</code> is installed.</li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#step_1_download_the_package_from_cloud_service","title":"Step 1: Download the package from cloud service","text":"<p>Note</p> <p>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </p> <ul> <li>Download the released version.<p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the release package <code>3.6.0</code> for <code>Centos 7.5</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>Download the release package <code>3.6.0</code> for <code>Ubuntu 1804</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul> <ul> <li> <p>Download the nightly version.</p> <p>Danger</p> <ul> <li>Nightly versions are usually used to test new features. Do not use it in a production environment.</li> <li>Nightly versions may not be built successfully every night. And the names may change from day to day.</li> </ul> <p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the <code>Centos 7.5</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>For example, download the <code>Ubuntu 1804</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#step_2_install_nebulagraph","title":"Step 2: Install NebulaGraph","text":"<ul> <li> <p>Use the following syntax to install with an RPM package.</p> <pre><code>$ sudo rpm -ivh --prefix=&lt;installation_path&gt; &lt;package_name&gt;\n</code></pre> <p>The option <code>--prefix</code> indicates the installation path. The default path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install an RPM package in the default path for the 3.6.0 version, run the following command.</p> <pre><code>sudo rpm -ivh nebula-graph-3.6.0.el7.x86_64.rpm\n</code></pre> </li> </ul> <ul> <li> <p>Use the following syntax to install with a DEB package.</p> <pre><code>$ sudo dpkg -i &lt;package_name&gt;\n</code></pre> <p>Note</p> <p>Customizing the installation path is not supported when installing NebulaGraph with a DEB package. The default installation path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install a DEB package for the 3.6.0 version, run the following command.</p> <pre><code>sudo dpkg -i nebula-graph-3.6.0.ubuntu1804.amd64.deb\n</code></pre> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula/</code>.</p> </li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#next_to_do","title":"Next to do","text":"<ul> <li>Start NebulaGraph </li> </ul> <ul> <li>Connect to NebulaGraph</li> </ul>"},{"location":"2.quick-start/3.1add-storage-hosts/","title":"Register the Storage Service","text":"<p>When connecting to NebulaGraph for the first time, you have to add the Storage hosts, and confirm that all the hosts are online.</p> <p>Compatibility</p> <ul> <li>Starting from NebulaGraph 3.0.0, you have to run <code>ADD HOSTS</code> before reading or writing data into the Storage Service.</li> <li>For NebulaGraph of versions earlier than 3.0.0 and NebulaGraph Cloud clusters, <code>ADD HOSTS</code> is not needed. </li> </ul>"},{"location":"2.quick-start/3.1add-storage-hosts/#prerequisites","title":"Prerequisites","text":"<p>You have connected to NebulaGraph.</p>"},{"location":"2.quick-start/3.1add-storage-hosts/#steps","title":"Steps","text":"<ol> <li> <p>Add the Storage hosts.</p> <p>Run the following command to add hosts:</p> <pre><code>ADD HOSTS &lt;ip&gt;:&lt;port&gt; [,&lt;ip&gt;:&lt;port&gt; ...];\n</code></pre> <p>Example\uff1a</p> <pre><code>nebula&gt; ADD HOSTS 192.168.10.100:9779, 192.168.10.101:9779, 192.168.10.102:9779;\n</code></pre> <p>Caution</p> <p>Make sure that the IP you added is the same as the IP configured for <code>local_ip</code> in the <code>nebula-storaged.conf</code> file. Otherwise, the Storage service will fail to start. For information about configurations, see Configurations.  </p> </li> <li> <p>Check the status of the hosts to make sure that they are all online.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n| Host             | Port | Status   | Leader count | Leader distribution  |   Partition distribution | Version |\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n| \"192.168.10.100\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"3.6.0\" |\n| \"192.168.10.101\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"3.6.0\"|\n| \"192.168.10.102\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"3.6.0\"|\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n</code></pre> <p>The <code>Status</code> column of the result above shows that all Storage hosts are online.</p> </li> </ol>"},{"location":"2.quick-start/3.connect-to-nebula-graph/","title":"Step 3: Connect to NebulaGraph","text":"<p>This topic provides basic instruction on how to use the native CLI client NebulaGraph Console to connect to NebulaGraph.</p> <p>Caution</p> <p>When connecting to NebulaGraph for the first time, you must register the Storage Service before querying data.</p> <p>NebulaGraph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. For more information, see the client list.</p>"},{"location":"2.quick-start/3.connect-to-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have started NebulaGraph services.</li> </ul> <ul> <li>The machine on which you plan to run NebulaGraph Console has network access to the Graph Service of NebulaGraph.</li> </ul> <ul> <li> <p>The NebulaGraph Console version is compatible with the NebulaGraph version.</p> <p>Note</p> <p>NebulaGraph Console and NebulaGraph of the same version number are the most compatible. There may be compatibility issues when connecting to NebulaGraph with a different version of NebulaGraph Console. The error message <code>incompatible version between client and server</code> is displayed when there is such an issue.</p> </li> </ul>"},{"location":"2.quick-start/3.connect-to-nebula-graph/#steps","title":"Steps","text":"<ol> <li> <p>On the NebulaGraph Console releases page, select a NebulaGraph Console version and click Assets.</p> <p>Note</p> <p>It is recommended to select the latest version.</p> </li> <li> <p>In the Assets area, find the correct binary file for the machine where you want to run NebulaGraph Console and download the file to the machine.</p> </li> <li> <p>(Optional) Rename the binary file to <code>nebula-console</code> for convenience.</p> <p>Note</p> <p>For Windows, rename the file to <code>nebula-console.exe</code>.</p> </li> <li> <p>On the machine to run NebulaGraph Console, grant the execute permission of the nebula-console binary file to the user.</p> <p>Note</p> <p>For Windows, skip this step.</p> <pre><code>$ chmod 111 nebula-console\n</code></pre> </li> <li> <p>In the command line interface, change the working directory to the one where the nebula-console binary file is stored.</p> </li> <li> <p>Run the following command to connect to NebulaGraph.</p> <ul> <li>For Linux or macOS:</li> </ul> <pre><code>$ ./nebula-console -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <ul> <li>For Windows:</li> </ul> <pre><code>&gt; nebula-console.exe -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP address of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the storage path of the certification authority file. <code>-ssl_cert_path</code> Sets the storage path of the certificate file. <code>-ssl_private_key_path</code> Sets the storage path of the private key file. <p>For information on more parameters, see the project repository.</p> </li> </ol>"},{"location":"2.quick-start/4.nebula-graph-crud/","title":"Step 4: Use nGQL (CRUD)","text":"<p>This topic will describe the basic CRUD operations in NebulaGraph.</p> <p>For more information, see nGQL guide.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#graph_space_and_nebulagraph_schema","title":"Graph space and NebulaGraph schema","text":"<p>A NebulaGraph instance consists of one or more graph spaces. Graph spaces are physically isolated from each other. You can use different graph spaces in the same instance to store different datasets.</p> <p></p> <p>To insert data into a graph space, define a schema for the graph database. NebulaGraph schema is based on the following components.</p> Schema component Description Vertex Represents an entity in the real world. A vertex can have zero to multiple tags. Tag The type of the same group of vertices. It defines a set of properties that describes the types of vertices. Edge Represents a directed relationship between two vertices. Edge type The type of an edge. It defines a group of properties that describes the types of edges. <p>For more information, see Data modeling.</p> <p>In this topic, we will use the following dataset to demonstrate basic CRUD operations.</p> <p></p>"},{"location":"2.quick-start/4.nebula-graph-crud/#async_implementation_of_create_and_alter","title":"Async implementation of <code>CREATE</code> and <code>ALTER</code>","text":"<p>Caution</p> <p>In NebulaGraph, the following <code>CREATE</code> or <code>ALTER</code> commands are implemented in an async way and take effect in the next heartbeat cycle. Otherwise, an error will be returned. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <ul> <li><code>CREATE SPACE</code></li> <li><code>CREATE TAG</code></li> <li><code>CREATE EDGE</code></li> <li><code>ALTER TAG</code></li> <li><code>ALTER EDGE</code></li> <li><code>CREATE TAG INDEX</code></li> <li><code>CREATE EDGE INDEX</code></li> </ul> <p>Note</p> <p>The default heartbeat interval is 10 seconds. To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#create_and_use_a_graph_space","title":"Create and use a graph space","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax","title":"nGQL syntax","text":"<ul> <li>Create a graph space:<pre><code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; (\n[partition_num = &lt;partition_number&gt;,]\n[replica_factor = &lt;replica_number&gt;,]\nvid_type = {FIXED_STRING(&lt;N&gt;) | INT64}\n)\n[COMMENT = '&lt;comment&gt;'];\n</code></pre> <p>For more information on parameters, see CREATE SPACE.</p> </li> </ul> <ul> <li>List graph spaces and check if the creation is successful:<pre><code>nebula&gt; SHOW SPACES;\n</code></pre> </li> </ul> <ul> <li>Use a graph space:<pre><code>USE &lt;graph_space_name&gt;;\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples","title":"Examples","text":"<ol> <li> <p>Use the following statement to create a graph space named <code>basketballplayer</code>.</p> <pre><code>nebula&gt; CREATE SPACE basketballplayer(partition_num=15, replica_factor=1, vid_type=fixed_string(30));\n</code></pre> <p>Note</p> <p>If the system returns the error <code>[ERROR (-1005)]: Host not enough!</code>, check whether registered the Storage Service.</p> </li> <li> <p>Check the partition distribution with <code>SHOW HOSTS</code> to make sure that the partitions are distributed in a balanced way.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+-------------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n| Host        | Port      | Status    | Leader count | Leader distribution              | Partition distribution | Version |\n+-------------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n| \"storaged0\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"3.6.0\"|\n| \"storaged1\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"3.6.0\"|\n| \"storaged2\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"3.6.0\"|\n+-------------+-----------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n</code></pre> <p>If the Leader distribution is uneven, use <code>BALANCE LEADER</code> to redistribute the partitions. For more information, see BALANCE.</p> </li> <li> <p>Use the <code>basketballplayer</code> graph space.</p> <pre><code>nebula[(none)]&gt; USE basketballplayer;\n</code></pre> <p>You can use <code>SHOW SPACES</code> to check the graph space you created.</p> <pre><code>nebula&gt; SHOW SPACES;\n+--------------------+\n| Name               |\n+--------------------+\n| \"basketballplayer\" |\n+--------------------+\n</code></pre> </li> </ol>"},{"location":"2.quick-start/4.nebula-graph-crud/#create_tags_and_edge_types","title":"Create tags and edge types","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_1","title":"nGQL syntax","text":"<pre><code>CREATE {TAG | EDGE} [IF NOT EXISTS] {&lt;tag_name&gt; | &lt;edge_type_name&gt;}\n    (\n      &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']\n      [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] \n    )\n    [TTL_DURATION = &lt;ttl_duration&gt;]\n    [TTL_COL = &lt;prop_name&gt;]\n    [COMMENT = '&lt;comment&gt;'];\n</code></pre> <p>For more information on parameters, see CREATE TAG and CREATE EDGE.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_1","title":"Examples","text":"<p>Create tags <code>player</code> and <code>team</code>, and edge types <code>follow</code> and <code>serve</code>. Descriptions are as follows.</p> Component name Type Property player Tag name (string), age (int) team Tag name (string) follow Edge type degree (int) serve Edge type start_year (int), end_year (int) <pre><code>nebula&gt; CREATE TAG player(name string, age int);\n\nnebula&gt; CREATE TAG team(name string);\n\nnebula&gt; CREATE EDGE follow(degree int);\n\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre>"},{"location":"2.quick-start/4.nebula-graph-crud/#insert_vertices_and_edges","title":"Insert vertices and edges","text":"<p>You can use the <code>INSERT</code> statement to insert vertices or edges based on existing tags or edge types.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_2","title":"nGQL syntax","text":"<ul> <li>Insert vertices:<pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES &lt;vid&gt;: ([prop_value_list])\n\ntag_props:\n  tag_name ([prop_name_list])\n\nprop_name_list:\n   [prop_name [, prop_name] ...]\n\nprop_value_list:\n   [prop_value [, prop_value] ...]   \n</code></pre> <p><code>vid</code> is short for Vertex ID. A <code>vid</code> must be a unique string value in a graph space. For details, see INSERT VERTEX.</p> </li> </ul> <ul> <li> <p>Insert edges:</p> <pre><code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES \n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; )\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...];\n&lt;prop_name_list&gt; ::=\n[ &lt;prop_name&gt; [, &lt;prop_name&gt; ] ...]\n&lt;prop_value_list&gt; ::=\n[ &lt;prop_value&gt; [, &lt;prop_value&gt; ] ...]\n</code></pre> <p>For more information on parameters, see INSERT EDGE.</p> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_2","title":"Examples","text":"<ul> <li>Insert vertices representing basketball players and teams:<pre><code>nebula&gt; INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\n\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36);\n\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\n\nnebula&gt; INSERT VERTEX team(name) VALUES \"team203\":(\"Trail Blazers\"), \"team204\":(\"Spurs\");\n</code></pre> </li> </ul> <ul> <li>Insert edges representing the relations between basketball players and teams:<pre><code>nebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player100\":(95);\n\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player102\":(90);\n\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player102\" -&gt; \"player100\":(75);\n\nnebula&gt; INSERT EDGE serve(start_year, end_year) VALUES \"player101\" -&gt; \"team204\":(1999, 2018),\"player102\" -&gt; \"team203\":(2006,  2015);\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#read_data","title":"Read data","text":"<ul> <li>The GO statement can traverse the database based on specific conditions. A <code>GO</code> traversal starts from one or more vertices, along one or more edges, and returns information in a form specified in the <code>YIELD</code> clause.</li> </ul> <ul> <li>The FETCH statement is used to get properties from vertices or edges.</li> </ul> <ul> <li>The LOOKUP statement is based on indexes. It is used together with the <code>WHERE</code> clause to search for the data that meet the specific conditions.</li> </ul> <ul> <li>The MATCH statement is the most commonly used statement for graph data querying. It can describe all kinds of graph patterns, but it relies on indexes to match data patterns in NebulaGraph. Therefore, its performance still needs optimization.</li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_3","title":"nGQL syntax","text":"<ul> <li><code>GO</code><pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS} ] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt; ]\nYIELD [DISTINCT] &lt;return_list&gt;\n[{ SAMPLE &lt;sample_list&gt; | &lt;limit_by_list_clause&gt; }]\n[| GROUP BY {&lt;col_name&gt; | expression&gt; | &lt;position&gt;} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;];\n</code></pre> </li> </ul> <ul> <li> <p><code>FETCH</code></p> <ul> <li> <p>Fetch properties on tags:</p> <pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *}\n&lt;vid&gt; [, vid ...]\nYIELD &lt;return_list&gt; [AS &lt;alias&gt;];\n</code></pre> </li> </ul> <ul> <li> <p>Fetch properties on edges:</p> <pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> </li> </ul> </li> </ul> <ul> <li><code>LOOKUP</code><pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;}\n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]]\nYIELD &lt;return_list&gt; [AS &lt;alias&gt;];\n&lt;return_list&gt;\n    &lt;prop_name&gt; [AS &lt;col_alias&gt;] [, &lt;prop_name&gt; [AS &lt;prop_alias&gt;] ...];\n</code></pre> </li> </ul> <ul> <li><code>MATCH</code><pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_of_go_statement","title":"Examples of <code>GO</code> statement","text":"<ul> <li>Search for the players that the player with VID <code>player101</code> follows.<pre><code>nebula&gt; GO FROM \"player101\" OVER follow YIELD id($$);\n+-------------+\n| id($$)      |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n+-------------+\n</code></pre> </li> </ul> <ul> <li>Filter the players that the player with VID <code>player101</code> follows whose age is equal to or greater than 35. Rename the corresponding columns in the results with <code>Teammate</code> and <code>Age</code>.<pre><code>nebula&gt; GO FROM \"player101\" OVER follow WHERE properties($$).age &gt;= 35 \\\n        YIELD properties($$).name AS Teammate, properties($$).age AS Age;\n+-----------------+-----+\n| Teammate        | Age |\n+-----------------+-----+\n| \"Tim Duncan\"    | 42  |\n| \"Manu Ginobili\" | 41  |\n+-----------------+-----+\n</code></pre> <p>| Clause/Sign | Description                                                         |   |-------------+---------------------------------------------------------------------|   | <code>YIELD</code>     | Specifies what values or results you want to return from the query. |   | <code>$$</code>        | Represents the target vertices.                                     |   | <code>\\</code>         | A line-breaker.                                                     |</p> </li> </ul> <ul> <li> <p>Search for the players that the player with VID <code>player101</code> follows. Then retrieve the teams of the players that the player with VID <code>player100</code> follows. To combine the two queries, use a pipe or a temporary variable.</p> <ul> <li> <p>With a pipe:</p> <pre><code>nebula&gt; GO FROM \"player101\" OVER follow YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------------+---------------------+\n| Team            | Player              |\n+-----------------+---------------------+\n| \"Spurs\"         | \"Tim Duncan\"        |\n| \"Trail Blazers\" | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"Manu Ginobili\"     |\n+-----------------+---------------------+\n</code></pre> Clause/Sign Description <code>$^</code> Represents the source vertex of the edge. <code>|</code> A pipe symbol can combine multiple queries. <code>$-</code> Represents the outputs of the query before the pipe symbol. </li> </ul> <ul> <li> <p>With a temporary variable:</p> <p>Note</p> <p>Once a composite statement is submitted to the server as a whole, the life cycle of the temporary variables in the statement ends.</p> <pre><code>nebula&gt; $var = GO FROM \"player101\" OVER follow YIELD dst(edge) AS id; \\\n        GO FROM $var.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------------+---------------------+\n| Team            | Player              |\n+-----------------+---------------------+\n| \"Spurs\"         | \"Tim Duncan\"        |\n| \"Trail Blazers\" | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"Manu Ginobili\"     |\n+-----------------+---------------------+\n</code></pre> </li> </ul> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#example_of_fetch_statement","title":"Example of <code>FETCH</code> statement","text":"<p>Use <code>FETCH</code>: Fetch the properties of the player with VID <code>player100</code>.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+-------------------------------+\n| properties(VERTEX)            |\n+-------------------------------+\n| {age: 42, name: \"Tim Duncan\"} |\n+-------------------------------+\n</code></pre> <p>Note</p> <p>The examples of <code>LOOKUP</code> and <code>MATCH</code> statements are in indexes.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#update_vertices_and_edges","title":"Update vertices and edges","text":"<p>Users can use the <code>UPDATE</code> or the <code>UPSERT</code> statements to update existing data.</p> <p><code>UPSERT</code> is the combination of <code>UPDATE</code> and <code>INSERT</code>. If you update a vertex or an edge with <code>UPSERT</code>, the database will insert a new vertex or edge if it does not exist.</p> <p>Note</p> <p><code>UPSERT</code> operates serially in a partition-based order. Therefore, it is slower than <code>INSERT</code> OR <code>UPDATE</code>. And <code>UPSERT</code> has concurrency only between multiple partitions.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_4","title":"nGQL syntax","text":"<ul> <li><code>UPDATE</code> vertices:<pre><code>UPDATE VERTEX &lt;vid&gt; SET &lt;properties to be updated&gt;\n[WHEN &lt;condition&gt;] [YIELD &lt;columns&gt;];\n</code></pre> </li> </ul> <ul> <li><code>UPDATE</code> edges:<pre><code>UPDATE EDGE ON &lt;edge_type&gt; &lt;source vid&gt; -&gt; &lt;destination vid&gt; [@rank] \nSET &lt;properties to be updated&gt; [WHEN &lt;condition&gt;] [YIELD &lt;columns to be output&gt;];\n</code></pre> </li> </ul> <ul> <li><code>UPSERT</code> vertices or edges:<pre><code>UPSERT {VERTEX &lt;vid&gt; | EDGE &lt;edge_type&gt;} SET &lt;update_columns&gt;\n[WHEN &lt;condition&gt;] [YIELD &lt;columns&gt;];\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_3","title":"Examples","text":"<ul> <li><code>UPDATE</code> the <code>name</code> property of the vertex with VID <code>player100</code> and check the result with the <code>FETCH</code> statement.<pre><code>nebula&gt; UPDATE VERTEX \"player100\" SET player.name = \"Tim\";\n\nnebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+------------------------+\n| properties(VERTEX)     |\n+------------------------+\n| {age: 42, name: \"Tim\"} |\n+------------------------+\n</code></pre> </li> </ul> <ul> <li><code>UPDATE</code> the <code>degree</code> property of an edge and check the result with the <code>FETCH</code> statement.<pre><code>nebula&gt; UPDATE EDGE ON follow \"player101\" -&gt; \"player100\" SET degree = 96;\n\nnebula&gt; FETCH PROP ON follow \"player101\" -&gt; \"player100\" YIELD properties(edge);\n+------------------+\n| properties(EDGE) |\n+------------------+\n| {degree: 96}     |\n+------------------+\n</code></pre> </li> </ul> <ul> <li>Insert a vertex with VID <code>player111</code> and <code>UPSERT</code> it.<pre><code>nebula&gt; INSERT VERTEX player(name,age) VALUES \"player111\":(\"David West\", 38);\n\nnebula&gt; UPSERT VERTEX \"player111\" SET player.name = \"David\", player.age = $^.player.age + 11 \\\n        WHEN $^.player.name == \"David West\" AND $^.player.age &gt; 20 \\\n        YIELD $^.player.name AS Name, $^.player.age AS Age;\n+---------+-----+\n| Name    | Age |\n+---------+-----+\n| \"David\" | 49  |\n+---------+-----+\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#delete_vertices_and_edges","title":"Delete vertices and edges","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_5","title":"nGQL syntax","text":"<ul> <li>Delete vertices:<pre><code>DELETE VERTEX &lt;vid1&gt;[, &lt;vid2&gt;...]\n</code></pre> </li> </ul> <ul> <li>Delete edges:<pre><code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;...]\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_4","title":"Examples","text":"<ul> <li>Delete vertices:<pre><code>nebula&gt; DELETE VERTEX \"player111\", \"team203\";\n</code></pre> </li> </ul> <ul> <li>Delete edges:<pre><code>nebula&gt; DELETE EDGE follow \"player101\" -&gt; \"team204\";\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#about_indexes","title":"About indexes","text":"<p>Users can add indexes to tags and edge types with the CREATE INDEX statement.</p> <p>Must-read for using indexes</p> <p>Both <code>MATCH</code> and <code>LOOKUP</code> statements depend on the indexes. But indexes can dramatically reduce the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.</p> <p>Users MUST rebuild indexes for pre-existing data. Otherwise, the pre-existing data cannot be indexed and therefore cannot be returned in <code>MATCH</code> or <code>LOOKUP</code> statements. For more information, see REBUILD INDEX.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_6","title":"nGQL syntax","text":"<ul> <li>Create an index:<pre><code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt;\nON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT = '&lt;comment&gt;'];\n</code></pre> </li> </ul> <ul> <li>Rebuild an index:<pre><code>REBUILD {TAG | EDGE} INDEX &lt;index_name&gt;;\n</code></pre> </li> </ul> <p>Note</p> <p>Define the index length when creating an index for a variable-length property. In UTF-8 encoding, a non-ascii character occupies 3 bytes. You should set an appropriate index length according to the variable-length property. For example, the index should be 30 bytes for 10 non-ascii characters. For more information, see CREATE INDEX</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_of_lookup_and_match_index-based","title":"Examples of <code>LOOKUP</code> and <code>MATCH</code> (index-based)","text":"<p>Make sure there is an index for <code>LOOKUP</code> or <code>MATCH</code> to use. If there is not, create an index first.</p> <p>Find the information of the vertex with the tag <code>player</code> and its value of the <code>name</code> property is <code>Tony Parker</code>.</p> <p>This example creates the index <code>player_index_1</code> on the <code>name</code> property.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index_1 ON player(name(20));\n</code></pre> <p>This example rebuilds the index to make sure it takes effect on pre-existing data.</p> <pre><code>nebula&gt; REBUILD TAG INDEX player_index_1\n+------------+\n| New Job Id |\n+------------+\n| 31         |\n+------------+\n</code></pre> <p>This example uses the <code>LOOKUP</code> statement to retrieve the vertex property.</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name AS name, properties(vertex).age AS age;\n+---------------+-----+\n| name          | age |\n+---------------+-----+\n| \"Tony Parker\" | 36  |\n+---------------+-----+\n</code></pre> <p>This example uses the <code>MATCH</code> statement to retrieve the vertex property.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tony Parker\"}) RETURN v;\n+-----------------------------------------------------+\n| v                                                   |\n+-----------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"}) |\n+-----------------------------------------------------+\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/","title":"Step 2: Manage NebulaGraph Service","text":"<p>NebulaGraph supports managing services with scripts. </p>"},{"location":"2.quick-start/5.start-stop-service/#manage_services_with_script","title":"Manage services with script","text":"<p>You can use the <code>nebula.service</code> script to start, stop, restart, terminate, and check the NebulaGraph services.</p> <p>Note</p> <p><code>nebula.service</code> is stored in the <code>/usr/local/nebula/scripts</code> directory by default. If you have customized the path, use the actual path in your environment.</p>"},{"location":"2.quick-start/5.start-stop-service/#syntax","title":"Syntax","text":"<pre><code>$ sudo /usr/local/nebula/scripts/nebula.service\n[-v] [-c &lt;config_file_path&gt;]\n&lt;start | stop | restart | kill | status&gt;\n&lt;metad | graphd | storaged | all&gt;\n</code></pre> Parameter Description <code>-v</code> Display detailed debugging information. <code>-c</code> Specify the configuration file path. The default path is <code>/usr/local/nebula/etc/</code>. <code>start</code> Start the target services. <code>stop</code> Stop the target services. <code>restart</code> Restart the target services. <code>kill</code> Terminate the target services. <code>status</code> Check the status of the target services. <code>metad</code> Set the Meta Service as the target service. <code>graphd</code> Set the Graph Service as the target service. <code>storaged</code> Set the Storage Service as the target service. <code>all</code> Set all the NebulaGraph services as the target services."},{"location":"2.quick-start/5.start-stop-service/#start_nebulagraph","title":"Start NebulaGraph","text":"<p>Run the following command to start NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service start all\n[INFO] Starting nebula-metad...\n[INFO] Done\n[INFO] Starting nebula-graphd...\n[INFO] Done\n[INFO] Starting nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/#stop_nebulagraph","title":"Stop NebulaGraph","text":"<p>Danger</p> <p>Do not run <code>kill -9</code> to forcibly terminate the processes. Otherwise, there is a low probability of data loss.</p> <p>Run the following command to stop NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service stop all\n[INFO] Stopping nebula-metad...\n[INFO] Done\n[INFO] Stopping nebula-graphd...\n[INFO] Done\n[INFO] Stopping nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/#check_the_service_status","title":"Check the service status","text":"<p>Run the following command to check the service status of NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service status all\n</code></pre> <ul> <li> <p>NebulaGraph is running normally if the following information is returned.</p> <pre><code>INFO] nebula-metad(33fd35e): Running as 29020, Listening on 9559\n[INFO] nebula-graphd(33fd35e): Running as 29095, Listening on 9669\n[WARN] nebula-storaged after v3.0.0 will not start service until it is added to cluster.\n[WARN] See Manage Storage hosts:ADD HOSTS in https://docs.nebula-graph.io/\n[INFO] nebula-storaged(33fd35e): Running as 29147, Listening on 9779\n</code></pre> <p>Note</p> <p>After starting NebulaGraph, the port of the <code>nebula-storaged</code> process is shown in red. Because the <code>nebula-storaged</code> process waits for the <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p> </li> </ul> <ul> <li>If the returned result is similar to the following one, there is a problem. You may also go to the NebulaGraph community for help.<pre><code>[INFO] nebula-metad: Running as 25600, Listening on 9559\n[INFO] nebula-graphd: Exited\n[INFO] nebula-storaged: Running as 25646, Listening on 9779\n</code></pre> </li> </ul> <p>The NebulaGraph services consist of the Meta Service, Graph Service, and Storage Service. The configuration files for all three services are stored in the <code>/usr/local/nebula/etc/</code> directory by default. You can check the configuration files according to the returned result to troubleshoot problems.</p>"},{"location":"2.quick-start/5.start-stop-service/#next_to_do","title":"Next to do","text":"<p>Connect to NebulaGraph</p>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/","title":"nGQL cheatsheet","text":""},{"location":"2.quick-start/6.cheatsheet-for-ngql/#functions","title":"Functions","text":"<ul> <li> <p>Math functions</p> Function Description double abs(double x) Returns the absolute value of the argument. double floor(double x) Returns the largest integer value smaller than or equal to the argument. (Rounds down) double ceil(double x) Returns the smallest integer greater than or equal to the argument. (Rounds up) double round(double x) Returns the integer value nearest to the argument. Returns a number farther away from 0 if the argument is in the middle. double sqrt(double x) Returns the square root of the argument. double cbrt(double x) Returns the cubic root of the argument. double hypot(double x, double y) Returns the hypotenuse of a right-angled triangle. double pow(double x, double y) Returns the result of x^y^. double exp(double x) Returns the result of e^x^. double exp2(double x) Returns the result of 2^x^. double log(double x) Returns the base-e logarithm of the argument. double log2(double x) Returns the base-2 logarithm of the argument. double log10(double x) Returns the base-10 logarithm of the argument. double sin(double x) Returns the sine of the argument. double asin(double x) Returns the inverse sine of the argument. double cos(double x) Returns the cosine of the argument. double acos(double x) Returns the inverse cosine of the argument. double tan(double x) Returns the tangent of the argument. double atan(double x) Returns the inverse tangent of the argument. double rand() Returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e.[0,1). int rand32(int min, int max) Returns a random 32-bit integer in <code>[min, max)</code>.If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default.If you set no argument, the system returns a random signed 32-bit integer. int rand64(int min, int max) Returns a random 64-bit integer in <code>[min, max)</code>.If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default.If you set no argument, the system returns a random signed 64-bit integer. bit_and() Bitwise AND. bit_or() Bitwise OR. bit_xor() Bitwise XOR. int size() Returns the number of elements in a list or a map or the length of a string. int range(int start, int end, int step) Returns a list of integers from <code>[start,end]</code> in the specified steps. <code>step</code> is 1 by default. int sign(double x) Returns the signum of the given number.If the number is <code>0</code>, the system returns <code>0</code>.If the number is negative, the system returns <code>-1</code>.If the number is positive, the system returns <code>1</code>. double e() Returns the base of the natural logarithm, e (2.718281828459045). double pi() Returns the mathematical constant pi (3.141592653589793). double radians() Converts degrees to radians. <code>radians(180)</code> returns <code>3.141592653589793</code>. </li> </ul> <ul> <li> <p>Aggregating functions</p> Function Description avg() Returns the average value of the argument. count() Syntax: <code>count({expr | *})</code> .<code>count()</code>returns the number of rows (including NULL). <code>count(expr)</code>returns the number of non-NULL values that meet the expression. count() and size() are different. max() Returns the maximum value. min() Returns the minimum value. collect() The collect() function returns a list containing the values returned by an expression. Using this function aggregates data by merging multiple records or values into a single list. std() Returns the population standard deviation. sum() Returns the sum value. </li> </ul> <ul> <li> <p>String functions</p> Function Description int strcasecmp(string a, string b) Compares string a and b without case sensitivity. When a = b, the return string lower(string a) Returns the argument in lowercase. string toLower(string a) The same as <code>lower()</code>. string upper(string a) Returns the argument in uppercase. string toUpper(string a) The same as <code>upper()</code>. int length(a) Returns the length of the given string in bytes or the length of a path in hops. string trim(string a) Removes leading and trailing spaces. string ltrim(string a) Removes leading spaces. string rtrim(string a) Removes trailing spaces. string left(string a, int count) Returns a substring consisting of <code>count</code> characters from the left side of string right(string a, int count) Returns a substring consisting of <code>count</code> characters from the right side of string lpad(string a, int size, string letters) Left-pads string a with string <code>letters</code> and returns a string rpad(string a, int size, string letters) Right-pads string a with string <code>letters</code> and returns a string substr(string a, int pos, int count) Returns a substring extracting <code>count</code> characters starting from string substring(string a, int pos, int count) The same as <code>substr()</code>. string reverse(string) Returns a string in reverse order. string replace(string a, string b, string c) Replaces string b in string a with string c. list split(string a, string b) Splits string a at string b and returns a list of strings. concat() The <code>concat()</code> function requires at least two or more strings. All the parameters are concatenated into one string.Syntax: <code>concat(string1,string2,...)</code> concat_ws() The <code>concat_ws()</code> function connects two or more strings with a predefined separator. extract() <code>extract()</code> uses regular expression matching to retrieve a single substring or all substrings from a string. json_extract() The <code>json_extract()</code> function converts the specified JSON string to map. </li> </ul> <ul> <li> <p>Data and time functions</p> Function Description int now() Returns the current timestamp of the system. timestamp timestamp() Returns the current timestamp of the system. date date() Returns the current UTC date based on the current system. time time() Returns the current UTC time based on the current system. datetime datetime() Returns the current UTC date and time based on the current system. </li> </ul> <ul> <li> <p>Schema-related functions</p> <ul> <li> <p>For nGQL statements</p> Function Description id(vertex) Returns the ID of a vertex. The data type of the result is the same as the vertex ID. map properties(vertex) Returns the properties of a vertex. map properties(edge) Returns the properties of an edge. string type(edge) Returns the edge type of an edge. src(edge) Returns the source vertex ID of an edge. The data type of the result is the same as the vertex ID. dst(edge) Returns the destination vertex ID of an edge. The data type of the result is the same as the vertex ID. int rank(edge) Returns the rank value of an edge. vertex Returns the information of vertices, including VIDs, tags, properties, and values. edge Returns the information of edges, including edge types, source vertices, destination vertices, ranks, properties, and values. vertices Returns the information of vertices in a subgraph. For more information, see GET SUBGRAPH. edges Returns the information of edges in a subgraph. For more information, see GET SUBGRAPH. path Returns the information of a path. For more information, see FIND PATH. </li> </ul> <ul> <li> <p>For statements compatible with openCypher</p> Function Description id(&lt;vertex&gt;) Returns the ID of a vertex. The data type of the result is the same as the vertex ID. list tags(&lt;vertex&gt;) Returns the Tag of a vertex, which serves the same purpose as labels(). list labels(&lt;vertex&gt;) Returns the Tag of a vertex, which serves the same purpose as tags(). This function is used for compatibility with openCypher syntax. map properties(&lt;vertex_or_edge&gt;) Returns the properties of a vertex or an edge. string type(&lt;edge&gt;) Returns the edge type of an edge. src(&lt;edge&gt;) Returns the source vertex ID of an edge. The data type of the result is the same as the vertex ID. dst(&lt;edge&gt;) Returns the destination vertex ID of an edge. The data type of the result is the same as the vertex ID. vertex startNode(&lt;path&gt;) Visits an edge or a path and returns its source vertex ID. string endNode(&lt;path&gt;) Visits an edge or a path and returns its destination vertex ID. int rank(&lt;edge&gt;) Returns the rank value of an edge. </li> </ul> </li> </ul> <ul> <li> <p>List functions</p> Function Description keys(expr) Returns a list containing the string representations for all the property names of vertices, edges, or maps. labels(vertex) Returns the list containing all the tags of a vertex. nodes(path) Returns the list containing all the vertices in a path. range(start, end [, step]) Returns the list containing all the fixed-length steps in <code>[start,end]</code>. <code>step</code> is 1 by default. relationships(path) Returns the list containing all the relationships in a path. reverse(list) Returns the list reversing the order of all elements in the original list. tail(list) Returns all the elements of the original list, excluding the first one. head(list) Returns the first element of a list. last(list) Returns the last element of a list. reduce() The <code>reduce()</code> function applies an expression to each element in a list one by one, chains the result to the next iteration by taking it as the initial value, and returns the final result. </li> </ul> <ul> <li> <p>Type conversion functions</p> Function Description bool toBoolean() Converts a string value to a boolean value. float toFloat() Converts an integer or string value to a floating point number. string toString() Converts non-compound types of data, such as numbers, booleans, and so on, to strings. int toInteger() Converts a floating point or string value to an integer value. set toSet() Converts a list or set value to a set value. int hash() The <code>hash()</code> function returns the hash value of the argument. The argument can be a number, a string, a list, a boolean, null, or an expression that evaluates to a value of the preceding data types. </li> </ul> <ul> <li> <p>Predicate functions</p> <p>Predicate functions return <code>true</code> or <code>false</code>. They are most commonly used in <code>WHERE</code> clauses.</p> <pre><code>&lt;predicate&gt;(&lt;variable&gt; IN &lt;list&gt; WHERE &lt;condition&gt;)\n</code></pre> Function Description exists() Returns <code>true</code> if the specified property exists in the vertex, edge or map. Otherwise, returns <code>false</code>. any() Returns <code>true</code> if the specified predicate holds for at least one element in the given list. Otherwise, returns <code>false</code>. all() Returns <code>true</code> if the specified predicate holds for all elements in the given list. Otherwise, returns <code>false</code>. none() Returns <code>true</code> if the specified predicate holds for no element in the given list. Otherwise, returns <code>false</code>. single() Returns <code>true</code> if the specified predicate holds for exactly one of the elements in the given list. Otherwise, returns <code>false</code>. </li> </ul> <ul> <li> <p>Conditional expressions functions</p> Function Description CASE The <code>CASE</code> expression uses conditions to filter the result of an nGQL query statement. It is usually used in the <code>YIELD</code> and <code>RETURN</code> clauses. The <code>CASE</code> expression will traverse all the conditions. When the first condition is met, the <code>CASE</code> expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the <code>ELSE</code> clause. If there is no <code>ELSE</code> clause and no conditions are met, it returns <code>NULL</code>. coalesce() Returns the first not null value in all expressions. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#general_queries_statements","title":"General queries statements","text":"<ul> <li> <p>MATCH</p> <pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> Pattern Example Description Match vertices <code>(v)</code> You can use a user-defined variable in a pair of parentheses to represent a vertex in a pattern. For example: <code>(v)</code>. Match tags <code>MATCH (v:player) RETURN v</code> You can specify a tag with <code>:&lt;tag_name&gt;</code> after the vertex in a pattern. Match multiple tags <code>MATCH (v:player:team) RETURN v</code> To match vertices with multiple tags, use colons (:). Match vertex properties <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v</code> <code>MATCH (v) WITH v, properties(v) as props, keys(properties(v)) as kk WHERE [i in kk where props[i] == \"Tim Duncan\"] RETURN v</code> You can specify a vertex property with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> after the tag in a pattern; or use a vertex property value to get vertices directly. Match a VID. <code>MATCH (v) WHERE id(v) == 'player101' RETURN v</code> You can use the VID to match a vertex. The <code>id()</code> function can retrieve the VID of a vertex. Match multiple VIDs. <code>MATCH (v:player { name: 'Tim Duncan' })--(v2) WHERE id(v2) IN [\"player101\", \"player102\"] RETURN v2</code> To match multiple VIDs, use <code>WHERE id(v) IN [vid_list]</code>. Match connected vertices <code>MATCH (v:player{name:\"Tim Duncan\"})--(v2) RETURN v2.player.name AS Name</code> You can use the <code>--</code> symbol to represent edges of both directions and match vertices connected by these edges. You can add a <code>&gt;</code> or <code>&lt;</code> to the <code>--</code> symbol to specify the direction of an edge. Match paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) RETURN p</code> Connected vertices and edges form a path. You can use a user-defined variable to name a path as follows. Match edges <code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-(v2) RETURN e</code><code>MATCH ()&lt;-[e]-() RETURN e</code> Besides using <code>--</code>, <code>--&gt;</code>, or <code>&lt;--</code> to indicate a nameless edge, you can use a user-defined variable in a pair of square brackets to represent a named edge. For example: <code>-[e]-</code>. Match an edge type <code>MATCH ()-[e:follow]-() RETURN e</code> Just like vertices, you can specify an edge type with <code>:&lt;edge_type&gt;</code> in a pattern. For example: <code>-[e:follow]-</code>. Match edge type properties <code>MATCH (v:player{name:\"Tim Duncan\"})-[e:follow{degree:95}]-&gt;(v2) RETURN e</code> <code>MATCH ()-[e]-&gt;() WITH e, properties(e) as props, keys(properties(e)) as kk WHERE [i in kk where props[i] == 90] RETURN e</code> You can specify edge type properties with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> in a pattern. For example: <code>[e:follow{likeness:95}]</code>; or use an edge type property value to get edges directly. Match multiple edge types <code>MATCH (v:player{name:\"Tim Duncan\"})-[e:follow | :serve]-&gt;(v2) RETURN e</code> The <code>|</code> symbol can help matching multiple edge types. For example: <code>[e:follow|:serve]</code>. The English colon (:) before the first edge type cannot be omitted, but the English colon before the subsequent edge type can be omitted, such as <code>[e:follow|serve]</code>. Match multiple edges <code>MATCH (v:player{name:\"Tim Duncan\"})-[]-&gt;(v2)&lt;-[e:serve]-(v3) RETURN v2, v3</code> You can extend a pattern to match multiple edges in a path. Match fixed-length paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) RETURN DISTINCT v2 AS Friends</code> You can use the <code>:&lt;edge_type&gt;*&lt;hop&gt;</code> pattern to match a fixed-length path. <code>hop</code> must be a non-negative integer. The data type of <code>e</code> is the list. Match variable-length paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]-&gt;(v2) RETURN v2 AS Friends</code> <code>minHop</code>: Optional. It represents the minimum length of the path. <code>minHop</code>: must be a non-negative integer. The default value is 1.<code>minHop</code> and <code>maxHop</code> are optional and the default value is 1 and infinity respectively. The data type of <code>e</code> is the list. Match variable-length paths with multiple edge types <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow | serve*2]-&gt;(v2) RETURN DISTINCT v2</code> You can specify multiple edge types in a fixed-length or variable-length pattern. In this case, <code>hop</code>, <code>minHop</code>, and <code>maxHop</code> take effect on all edge types. The data type of <code>e</code> is the list. Retrieve vertex or edge information <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v</code><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) RETURN e</code> Use <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}</code> to retrieve all the information of a vertex or an edge. Retrieve VIDs <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN id(v)</code> Use the <code>id()</code> function to retrieve VIDs. Retrieve tags <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN labels(v)</code> Use the <code>labels()</code> function to retrieve the list of tags on a vertex.To retrieve the nth element in the <code>labels(v)</code> list, use <code>labels(v)[n-1]</code>. Retrieve a single property on a vertex or an edge <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v.player.age</code> Use <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}.&lt;property&gt;</code> to retrieve a single property.Use <code>AS</code> to specify an alias for a property. Retrieve all properties on a vertex or an edge <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN properties(v2)</code> Use the <code>properties()</code> function to retrieve all properties on a vertex or an edge. Retrieve edge types <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e]-&gt;() RETURN DISTINCT type(e)</code> Use the <code>type()</code> function to retrieve the matched edge types. Retrieve paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[*3]-&gt;() RETURN p</code> Use <code>RETURN &lt;path_name&gt;</code> to retrieve all the information of the matched paths. Retrieve vertices in a path <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN nodes(p)</code> Use the <code>nodes()</code> function to retrieve all vertices in a path. Retrieve edges in a path <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN relationships(p)</code> Use the <code>relationships()</code> function to retrieve all edges in a path. Retrieve path length <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[*..2]-&gt;(v2) RETURN p AS Paths, length(p) AS Length</code> Use the <code>length()</code> function to retrieve the length of a path. </li> </ul> <ul> <li> <p>OPTIONAL MATCH</p> Pattern Example Description Matches patterns against your graph database, just like <code>MATCH</code> does. <code>MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" OPTIONAL MATCH (n)-[]-&gt;(l) RETURN id(m),id(n),id(l)</code> If no matches are found, <code>OPTIONAL MATCH</code> will use a null for missing parts of the pattern. </li> </ul> <ul> <li> <p>LOOKUP</p> <pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;} \n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]] \nYIELD &lt;return_list&gt; [AS &lt;alias&gt;]\n</code></pre> Pattern Example Description Retrieve vertices <code>LOOKUP ON player WHERE player.name == \"Tony Parker\" YIELD player.name AS name, player.age AS age</code> The following example returns vertices whose <code>name</code> is <code>Tony Parker</code> and the tag is <code>player</code>. Retrieve edges <code>LOOKUP ON follow WHERE follow.degree == 90 YIELD follow.degree</code> Returns edges whose <code>degree</code> is <code>90</code> and the edge type is <code>follow</code>. List vertices with a tag <code>LOOKUP ON player YIELD properties(vertex),id(vertex)</code> Shows how to retrieve the VID of all vertices tagged with <code>player</code>. List edges with an edge types <code>LOOKUP ON follow YIELD edge AS e</code> Shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the <code>follow</code> edge type. Count the numbers of vertices or edges <code>LOOKUP ON player YIELD id(vertex)| YIELD COUNT(*) AS Player_Count</code> Shows how to count the number of vertices tagged with <code>player</code>. Count the numbers of edges <code>LOOKUP ON follow YIELD edge as e| YIELD COUNT(*) AS Like_Count</code> Shows how to count the number of edges of the <code>follow</code> edge type. </li> </ul> <ul> <li> <p>GO</p> <pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS} ] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt; ]\nYIELD [DISTINCT] &lt;return_list&gt;\n[{SAMPLE &lt;sample_list&gt; | LIMIT &lt;limit_list&gt;}]\n[| GROUP BY {col_name | expr | position} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset_value&gt;,] &lt;number_rows&gt;]\n</code></pre> Example Description <code>GO FROM \"player102\" OVER serve YIELD dst(edge)</code> Returns the teams that player 102 serves. <code>GO 2 STEPS FROM \"player102\" OVER follow YIELD dst(edge)</code> Returns the friends of player 102 with 2 hops. <code>GO FROM \"player100\", \"player102\" OVER serve WHERE properties(edge).start_year &gt; 1995 YIELD DISTINCT properties($$).name AS team_name, properties(edge).start_year AS start_year, properties($^).name AS player_name</code> Adds a filter for the traversal. <code>GO FROM \"player100\" OVER follow, serve YIELD properties(edge).degree, properties(edge).start_year</code> The following example traverses along with multiple edge types. If there is no value for a property, the output is <code>NULL</code>. <code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS destination</code> The following example returns the neighbor vertices in the incoming direction of player 100. <code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id | GO FROM $-.id OVER serve WHERE properties($^).age &gt; 20 YIELD properties($^).name AS FriendOf, properties($$).name AS Team</code> The following example retrieves the friends of player 100 and the teams that they serve. <code>GO FROM \"player102\" OVER follow YIELD dst(edge) AS both</code> The following example returns all the neighbor vertices of player 102. <code>GO 2 STEPS FROM \"player100\" OVER follow YIELD src(edge) AS src, dst(edge) AS dst, properties($$).age AS age | GROUP BY $-.dst YIELD $-.dst AS dst, collect_set($-.src) AS src, collect($-.age) AS age</code> The following example the outputs according to age. </li> </ul> <ul> <li> <p>FETCH</p> <ul> <li> <p>Fetch vertex properties</p> <pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *} \n&lt;vid&gt; [, vid ...] \nYIELD &lt;return_list&gt; [AS &lt;alias&gt;]\n</code></pre> Example Description <code>FETCH PROP ON player \"player100\" YIELD properties(vertex)</code> Specify a tag in the <code>FETCH</code> statement to fetch the vertex properties by that tag. <code>FETCH PROP ON player \"player100\" YIELD player.name AS name</code> Use a <code>YIELD</code> clause to specify the properties to be returned. <code>FETCH PROP ON player \"player101\", \"player102\", \"player103\" YIELD properties(vertex)</code> Specify multiple VIDs (vertex IDs) to fetch properties of multiple vertices. Separate the VIDs with commas. <code>FETCH PROP ON player, t1 \"player100\", \"player103\" YIELD properties(vertex)</code> Specify multiple tags in the <code>FETCH</code> statement to fetch the vertex properties by the tags. Separate the tags with commas. <code>FETCH PROP ON * \"player100\", \"player106\", \"team200\" YIELD properties(vertex)</code> Set an asterisk symbol <code>*</code> to fetch properties by all tags in the current graph space. </li> </ul> <ul> <li> <p>Fetch edge properties</p> <pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> Example Description <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD properties(edge)</code> The following statement fetches all the properties of the <code>serve</code> edge that connects vertex <code>\"player100\"</code> and vertex <code>\"team204\"</code>. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD serve.start_year</code> Use a <code>YIELD</code> clause to fetch specific properties of an edge. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\", \"player133\" -&gt; \"team202\" YIELD properties(edge)</code> Specify multiple edge patterns (<code>&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]</code>) to fetch properties of multiple edges. Separate the edge patterns with commas. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\"@1 YIELD properties(edge)</code> To fetch on an edge whose rank is not 0, set its rank in the FETCH statement. <code>GO FROM \"player101\" OVER follow YIELD follow._src AS s, follow._dst AS d | FETCH PROP ON follow $-.s -&gt; $-.d YIELD follow.degree</code> The following statement returns the <code>degree</code> values of the <code>follow</code> edges that start from vertex <code>\"player101\"</code>. <code>$var = GO FROM \"player101\" OVER follow YIELD follow._src AS s, follow._dst AS d; FETCH PROP ON follow $var.s -&gt; $var.d YIELD follow.degree</code> You can use user-defined variables to construct similar queries. </li> </ul> </li> </ul> <ul> <li> <p>SHOW</p> Statement Syntax Example Description SHOW CHARSET <code>SHOW CHARSET</code> <code>SHOW CHARSET</code> Shows the available character sets. SHOW COLLATION <code>SHOW COLLATION</code> <code>SHOW COLLATION</code> Shows the collations supported by NebulaGraph. SHOW CREATE SPACE <code>SHOW CREATE SPACE &lt;space_name&gt;</code> <code>SHOW CREATE SPACE basketballplayer</code> Shows the creating statement of the specified graph space. SHOW CREATE TAG/EDGE <code>SHOW CREATE {TAG &lt;tag_name&gt; | EDGE &lt;edge_name&gt;}</code> <code>SHOW CREATE TAG player</code> Shows the basic information of the specified tag. SHOW HOSTS <code>SHOW HOSTS [GRAPH | STORAGE | META]</code> <code>SHOW HOSTS</code><code>SHOW HOSTS GRAPH</code> Shows the host and version information of Graph Service, Storage Service, and Meta Service. SHOW INDEX STATUS <code>SHOW {TAG | EDGE} INDEX STATUS</code> <code>SHOW TAG INDEX STATUS</code> Shows the status of jobs that rebuild native indexes, which helps check whether a native index is successfully rebuilt or not. SHOW INDEXES <code>SHOW {TAG | EDGE} INDEXES</code> <code>SHOW TAG INDEXES</code> Shows the names of existing native indexes. SHOW PARTS <code>SHOW PARTS [&lt;part_id&gt;]</code> <code>SHOW PARTS</code> Shows the information of a specified partition or all partitions in a graph space. SHOW ROLES <code>SHOW ROLES IN &lt;space_name&gt;</code> <code>SHOW ROLES in basketballplayer</code> Shows the roles that are assigned to a user account. SHOW SNAPSHOTS <code>SHOW SNAPSHOTS</code> <code>SHOW SNAPSHOTS</code> Shows the information of all the snapshots. SHOW SPACES <code>SHOW SPACES</code> <code>SHOW SPACES</code> Shows existing graph spaces in NebulaGraph. SHOW STATS <code>SHOW STATS</code> <code>SHOW STATS</code> Shows the statistics of the graph space collected by the latest <code>STATS</code> job. SHOW TAGS/EDGES <code>SHOW TAGS | EDGES</code> <code>SHOW TAGS</code>,<code>SHOW EDGES</code> Shows all the tags in the current graph space. SHOW USERS <code>SHOW USERS</code> <code>SHOW USERS</code> Shows the user information. SHOW SESSIONS <code>SHOW SESSIONS</code> <code>SHOW SESSIONS</code> Shows the information of all the sessions. SHOW SESSIONS <code>SHOW SESSION &lt;Session_Id&gt;</code> <code>SHOW SESSION 1623304491050858</code> Shows a specified session with its ID. SHOW QUERIES <code>SHOW [ALL] QUERIES</code> <code>SHOW QUERIES</code> Shows the information of working queries in the current session. SHOW META LEADER <code>SHOW META LEADER</code> <code>SHOW META LEADER</code> Shows the information of the leader in the current Meta cluster. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#clauses_and_options","title":"Clauses and options","text":"Clause Syntax Example Description GROUP BY <code>GROUP BY &lt;var&gt; YIELD &lt;var&gt;, &lt;aggregation_function(var)&gt;</code> <code>GO FROM \"player100\" OVER follow BIDIRECT YIELD $$.player.name as Name | GROUP BY $-.Name YIELD $-.Name as Player, count(*) AS Name_Count</code> Finds all the vertices connected directly to vertex <code>\"player100\"</code>, groups the result set by player names, and counts how many times the name shows up in the result set. LIMIT <code>YIELD &lt;var&gt; [| LIMIT [&lt;offset_value&gt;,] &lt;number_rows&gt;]</code> <code>GO FROM \"player100\" OVER follow REVERSELY YIELD $$.player.name AS Friend, $$.player.age AS Age | ORDER BY $-.Age, $-.Friend | LIMIT 1, 3</code> Returns the 3 rows of data starting from the second row of the sorted output. SKIP <code>RETURN &lt;var&gt; [SKIP &lt;offset&gt;] [LIMIT &lt;number_rows&gt;]</code> <code>MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) RETURN v2.player.name AS Name, v2.player.age AS Age ORDER BY Age DESC SKIP 1</code> <code>SKIP</code> can be used alone to set the offset and return the data after the specified position. SAMPLE <code>&lt;go_statement&gt; SAMPLE &lt;sample_list&gt;;</code> <code>GO 3 STEPS FROM \"player100\" OVER * YIELD properties($$).name AS NAME, properties($$).age AS Age SAMPLE [1,2,3];</code> Takes samples evenly in the result set and returns the specified amount of data. ORDER BY <code>&lt;YIELD clause&gt; ORDER BY &lt;expression&gt; [ASC | DESC] [, &lt;expression&gt; [ASC | DESC] ...]</code> <code>FETCH PROP ON player \"player100\", \"player101\", \"player102\", \"player103\" YIELD player.age AS age, player.name AS name | ORDER BY $-.age ASC, $-.name DESC</code> The <code>ORDER BY</code> clause specifies the order of the rows in the output. RETURN <code>RETURN {&lt;vertex_name&gt;|&lt;edge_name&gt;|&lt;vertex_name&gt;.&lt;property&gt;|&lt;edge_name&gt;.&lt;property&gt;|...}</code> <code>MATCH (v:player) RETURN v.player.name, v.player.age LIMIT 3</code> Returns the first three rows with values of the vertex properties <code>name</code> and <code>age</code>. TTL <code>CREATE TAG &lt;tag_name&gt;(&lt;property_name_1&gt; &lt;property_value_1&gt;, &lt;property_name_2&gt; &lt;property_value_2&gt;, ...) ttl_duration= &lt;value_int&gt;, ttl_col = &lt;property_name&gt;</code> <code>CREATE TAG t2(a int, b int, c string) ttl_duration= 100, ttl_col = \"a\"</code> Create a tag and set the TTL options. WHERE <code>WHERE {&lt;vertex|edge_alias&gt;.&lt;property_name&gt; {&gt;|==|&lt;|...} &lt;value&gt;...}</code> <code>MATCH (v:player) WHERE v.player.name == \"Tim Duncan\" XOR (v.player.age &lt; 30 AND v.player.name == \"Yao Ming\") OR NOT (v.player.name == \"Yao Ming\" OR v.player.name == \"Tim Duncan\") RETURN v.player.name, v.player.age</code> The <code>WHERE</code> clause filters the output by conditions. The <code>WHERE</code> clause usually works in Native nGQL <code>GO</code> and <code>LOOKUP</code> statements, and OpenCypher <code>MATCH</code> and <code>WITH</code> statements. YIELD <code>YIELD [DISTINCT] &lt;col&gt; [AS &lt;alias&gt;] [, &lt;col&gt; [AS &lt;alias&gt;] ...] [WHERE &lt;conditions&gt;];</code> <code>GO FROM \"player100\" OVER follow YIELD dst(edge) AS ID | FETCH PROP ON player $-.ID YIELD player.age AS Age | YIELD AVG($-.Age) as Avg_age, count(*)as Num_friends</code> Finds the players that \"player100\" follows and calculates their average age. WITH <code>MATCH $expressions WITH {nodes()|labels()|...}</code> <code>MATCH p=(v:player{name:\"Tim Duncan\"})--() WITH nodes(p) AS n UNWIND n AS n1 RETURN DISTINCT n1</code> The <code>WITH</code> clause can retrieve the output from a query part, process it, and pass it to the next query part as the input. UNWIND <code>UNWIND &lt;list&gt; AS &lt;alias&gt; &lt;RETURN clause&gt;</code> <code>UNWIND [1,2,3] AS n RETURN n</code> Splits a list into rows."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#space_statements","title":"Space statements","text":"Statement Syntax Example Description CREATE SPACE <code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; ( [partition_num = &lt;partition_number&gt;,] [replica_factor = &lt;replica_number&gt;,] vid_type = {FIXED_STRING(&lt;N&gt;) | INT[64]} ) [COMMENT = '&lt;comment&gt;']</code> <code>CREATE SPACE my_space_1 (vid_type=FIXED_STRING(30))</code> Creates a graph space with CREATE SPACE <code>CREATE SPACE &lt;new_graph_space_name&gt; AS &lt;old_graph_space_name&gt;</code> <code>CREATE SPACE my_space_4 as my_space_3</code> Clone a graph. space. USE <code>USE &lt;graph_space_name&gt;</code> <code>USE space1</code> Specifies a graph space as the current working graph space for subsequent queries. SHOW SPACES <code>SHOW SPACES</code> <code>SHOW SPACES</code> Lists all the graph spaces in the NebulaGraph examples. DESCRIBE SPACE <code>DESC[RIBE] SPACE &lt;graph_space_name&gt;</code> <code>DESCRIBE SPACE basketballplayer</code> Returns the information about the specified graph space. CLEAR SPACE <code>CLEAR SPACE [IF EXISTS] &lt;graph_space_name&gt;</code> Deletes the vertices and edges in a graph space, but does not delete the graph space itself and the schema information. DROP SPACE <code>DROP SPACE [IF EXISTS] &lt;graph_space_name&gt;</code> <code>DROP SPACE basketballplayer</code> Deletes everything in the specified graph space."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#tag_statements","title":"TAG statements","text":"Statement Syntax Example Description CREATE TAG <code>CREATE TAG [IF NOT EXISTS] &lt;tag_name&gt; ( &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'] [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL |  NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] ) [TTL_DURATION = &lt;ttl_duration&gt;] [TTL_COL = &lt;prop_name&gt;] [COMMENT = '&lt;comment&gt;']</code> <code>CREATE TAG woman(name string, age int, married bool, salary double, create_time timestamp) TTL_DURATION = 100, TTL_COL = \"create_time\"</code> Creates a tag with the given name in a graph space. DROP TAG <code>DROP TAG [IF EXISTS] &lt;tag_name&gt;</code> <code>DROP TAG test;</code> Drops a tag with the given name in the current working graph space. ALTER TAG <code>ALTER TAG &lt;tag_name&gt;    &lt;alter_definition&gt; [, alter_definition] ...]    [ttl_definition [, ttl_definition] ... ]    [COMMENT = '&lt;comment&gt;']</code> <code>ALTER TAG t1 ADD (p3 int, p4 string)</code> Alters the structure of a tag with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration. SHOW TAGS <code>SHOW TAGS</code> <code>SHOW TAGS</code> Shows the name of all tags in the current graph space. DESCRIBE TAG <code>DESC[RIBE] TAG &lt;tag_name&gt;</code> <code>DESCRIBE TAG player</code> Returns the information about a tag with the given name in a graph space, such as field names, data type, and so on. DELETE TAG <code>DELETE TAG &lt;tag_name_list&gt; FROM &lt;VID&gt;</code> <code>DELETE TAG test1 FROM \"test\"</code> Deletes a tag with the given name on a specified vertex."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#edge_type_statements","title":"Edge type statements","text":"Statement Syntax Example Description CREATE EDGE <code>CREATE EDGE [IF NOT EXISTS] &lt;edge_type_name&gt;    ( &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'] [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] ) [TTL_DURATION = &lt;ttl_duration&gt;] [TTL_COL = &lt;prop_name&gt;] [COMMENT = '&lt;comment&gt;']</code> <code>CREATE EDGE e1(p1 string, p2 int, p3 timestamp) TTL_DURATION = 100, TTL_COL = \"p2\"</code> Creates an edge type with the given name in a graph space. DROP EDGE <code>DROP EDGE [IF EXISTS] &lt;edge_type_name&gt;</code> <code>DROP EDGE e1</code> Drops an edge type with the given name in a graph space. ALTER EDGE <code>ALTER EDGE &lt;edge_type_name&gt;    &lt;alter_definition&gt; [, alter_definition] ...]    [ttl_definition [, ttl_definition] ... ]    [COMMENT = '&lt;comment&gt;']</code> <code>ALTER EDGE e1 ADD (p3 int, p4 string)</code> Alters the structure of an edge type with the given name in a graph space. SHOW EDGES <code>SHOW EDGES</code> <code>SHOW EDGES</code> Shows all edge types in the current graph space. DESCRIBE EDGE <code>DESC[RIBE] EDGE &lt;edge_type_name&gt;</code> <code>DESCRIBE EDGE follow</code> Returns the information about an edge type with the given name in a graph space, such as field names, data type, and so on."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#vertex_statements","title":"Vertex statements","text":"Statement Syntax Example Description INSERT VERTEX <code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...] VALUES &lt;vid&gt;: ([prop_value_list])</code> <code>INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8)</code> Inserts one or more vertices into a graph space in NebulaGraph. DELETE VERTEX <code>DELETE VERTEX &lt;vid&gt; [, &lt;vid&gt; ...]</code> <code>DELETE VERTEX \"team1\"</code> Deletes vertices and the related incoming and outgoing edges of the vertices. UPDATE VERTEX <code>UPDATE VERTEX ON &lt;tag_name&gt; &lt;vid&gt; SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPDATE VERTEX ON player \"player101\" SET age = age + 2</code> Updates properties on tags of a vertex. UPSERT VERTEX <code>UPSERT VERTEX ON &lt;tag&gt; &lt;vid&gt; SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPSERT VERTEX ON player \"player667\" SET age = 31</code> The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT VERTEX</code> to update the properties of a vertex if it exists or insert a new vertex if it does not exist."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#edge_statements","title":"Edge statements","text":"Statement Syntax Example Description INSERT EDGE <code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ) [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...]</code> <code>INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 1)</code> Inserts an edge or multiple edges into a graph space from a source vertex (given by src_vid) to a destination vertex (given by dst_vid) with a specific rank in NebulaGraph. DELETE EDGE <code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] ...]</code> <code>DELETE EDGE serve \"player100\" -&gt; \"team204\"@0</code> Deletes one edge or multiple edges at a time. UPDATE EDGE <code>UPDATE EDGE ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@&lt;rank&gt;] SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPDATE EDGE ON serve \"player100\" -&gt; \"team204\"@0 SET start_year = start_year + 1</code> Updates properties on an edge. UPSERT EDGE <code>UPSERT EDGE ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@rank] SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;properties&gt;]</code> <code>UPSERT EDGE on serve \"player666\" -&gt; \"team200\"@0 SET end_year = 2021</code> The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT EDGE</code> to update the properties of an edge if it exists or insert a new edge if it does not exist."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#index","title":"Index","text":"<ul> <li> <p>Native index</p> <p>You can use native indexes together with <code>LOOKUP</code> and <code>MATCH</code> statements.</p> Statement Syntax Example Description CREATE INDEX <code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT = '&lt;comment&gt;']</code> <code>CREATE TAG INDEX player_index on player()</code> Add native indexes for the existing tags, edge types, or properties. SHOW CREATE INDEX <code>SHOW CREATE {TAG | EDGE} INDEX &lt;index_name&gt;</code> <code>show create tag index index_2</code> Shows the statement used when creating a tag or an edge type. It contains detailed information about the index, such as its associated properties. SHOW INDEXES <code>SHOW {TAG | EDGE} INDEXES</code> <code>SHOW TAG INDEXES</code> Shows the defined tag or edge type indexes names in the current graph space. DESCRIBE INDEX <code>DESCRIBE {TAG | EDGE} INDEX &lt;index_name&gt;</code> <code>DESCRIBE TAG INDEX player_index_0</code> Gets the information about the index with a given name, including the property name (Field) and the property type (Type) of the index. REBUILD INDEX <code>REBUILD {TAG | EDGE} INDEX [&lt;index_name_list&gt;]</code> <code>REBUILD TAG INDEX single_person_index</code> Rebuilds the created tag or edge type index. If data is updated or inserted before the creation of the index, you must rebuild the indexes manually to make sure that the indexes contain the previously added data. SHOW INDEX STATUS <code>SHOW {TAG | EDGE} INDEX STATUS</code> <code>SHOW TAG INDEX STATUS</code> Returns the name of the created tag or edge type index and its status. DROP INDEX <code>DROP {TAG | EDGE} INDEX [IF EXISTS] &lt;index_name&gt;</code> <code>DROP TAG INDEX player_index_0</code> Removes an existing index from the current graph space. </li> </ul> <ul> <li> <p>Full-text index</p> Syntax Example Description <code>SIGN IN TEXT SERVICE [(&lt;elastic_ip:port&gt; [,&lt;username&gt;, &lt;password&gt;]), (&lt;elastic_ip:port&gt;), ...]</code> <code>SIGN IN TEXT SERVICE (127.0.0.1:9200)</code> The full-text indexes is implemented based on Elasticsearch. After deploying an Elasticsearch cluster, you can use the <code>SIGN IN</code> statement to log in to the Elasticsearch client. <code>SHOW TEXT SEARCH CLIENTS</code> <code>SHOW TEXT SEARCH CLIENTS</code> Shows text search clients. <code>SIGN OUT TEXT SERVICE</code> <code>SIGN OUT TEXT SERVICE</code> Signs out to the text search clients. <code>CREATE FULLTEXT {TAG | EDGE} INDEX &lt;index_name&gt; ON {&lt;tag_name&gt; |  &lt;edge_name&gt;} ([&lt;prop_name_list&gt;])</code> <code>CREATE FULLTEXT TAG INDEX nebula_index_1 ON player(name)</code> Creates full-text indexes. <code>SHOW FULLTEXT INDEXES</code> <code>SHOW FULLTEXT INDEXES</code> Show full-text indexes. <code>REBUILD FULLTEXT INDEX</code> <code>REBUILD FULLTEXT INDEX</code> Rebuild full-text indexes. <code>DROP FULLTEXT INDEX &lt;index_name&gt;</code> <code>DROP FULLTEXT INDEX nebula_index_1</code> Drop full-text indexes. <code>LOOKUP ON {&lt;tag&gt; | &lt;edge_type&gt;} WHERE &lt;expression&gt; [YIELD &lt;return_list&gt;]</code> <code>LOOKUP ON player WHERE FUZZY(player.name, \"Tim Dunncan\", AUTO, OR) YIELD player.name</code> Use query options. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#subgraph_and_path_statements","title":"Subgraph and path statements","text":"Type Syntax Example Description GET SUBGRAPH <code>GET SUBGRAPH [WITH PROP] [&lt;step_count&gt; {STEP|STEPS}] FROM {&lt;vid&gt;, &lt;vid&gt;...} [{IN | OUT | BOTH} &lt;edge_type&gt;, &lt;edge_type&gt;...] YIELD [VERTICES AS &lt;vertex_alias&gt;] [,EDGES AS &lt;edge_alias&gt;]</code> <code>GET SUBGRAPH 1 STEPS FROM \"player100\" YIELD VERTICES AS nodes, EDGES AS relationships</code> Retrieves information of vertices and edges reachable from the source vertices of the specified edge types and returns information of the subgraph. FIND PATH <code>FIND { SHORTEST | ALL | NOLOOP } PATH [WITH PROP] FROM &lt;vertex_id_list&gt; TO &lt;vertex_id_list&gt; OVER &lt;edge_type_list&gt; [REVERSELY | BIDIRECT] [&lt;WHERE clause&gt;] [UPTO &lt;N&gt; {STEP|STEPS}] YIELD path as &lt;alias&gt; [| ORDER BY $-.path] [| LIMIT &lt;M&gt;]</code> <code>FIND SHORTEST PATH FROM \"player102\" TO \"team204\" OVER * YIELD path as p</code> Finds the paths between the selected source vertices and destination vertices. A returned path is like <code>(&lt;vertex_id&gt;)-[:&lt;edge_type_name&gt;@&lt;rank&gt;]-&gt;(&lt;vertex_id)</code>."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#query_tuning_statements","title":"Query tuning statements","text":"Type Syntax Example Description EXPLAIN <code>EXPLAIN [format=\"row\" | \"dot\"] &lt;your_nGQL_statement&gt;</code> <code>EXPLAIN format=\"row\" SHOW TAGS</code><code>EXPLAIN format=\"dot\" SHOW TAGS</code> Helps output the execution plan of an nGQL statement without executing the statement. PROFILE <code>PROFILE [format=\"row\" | \"dot\"] &lt;your_nGQL_statement&gt;</code> <code>PROFILE format=\"row\" SHOW TAGS</code><code>EXPLAIN format=\"dot\" SHOW TAGS</code> Executes the statement, then outputs the execution plan as well as the execution profile."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#operation_and_maintenance_statements","title":"Operation and maintenance statements","text":"<ul> <li> <p>SUBMIT JOB BALANCE</p> Syntax Description <code>BALANCE LEADER</code> Starts a job to balance the distribution of all the storage leaders in graph spaces. It returns the job ID. </li> </ul> <ul> <li> <p>Job statements</p> Syntax Description <code>SUBMIT JOB COMPACT</code> Triggers the long-term RocksDB <code>compact</code> operation. <code>SUBMIT JOB FLUSH</code> Writes the RocksDB memfile in the memory to the hard disk. <code>SUBMIT JOB STATS</code> Starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the <code>SHOW STATS</code> statement to list the statistics. <code>SHOW JOB &lt;job_id&gt;</code> Shows the information about a specific job and all its tasks in the current graph space. The Meta Service parses a <code>SUBMIT JOB</code> request into multiple tasks and assigns them to the nebula-storaged processes. <code>SHOW JOBS</code> Lists all the unexpired jobs in the current graph space. <code>STOP JOB</code> Stops jobs that are not finished in the current graph space. <code>RECOVER JOB</code> Re-executes the failed jobs in the current graph space and returns the number of recovered jobs. </li> </ul> <ul> <li> <p>Kill queries</p> Syntax Example Description <code>KILL QUERY (session=&lt;session_id&gt;, plan=&lt;plan_id&gt;)</code> <code>KILL QUERY(SESSION=1625553545984255,PLAN=163)</code> Terminates the query being executed, and is often used to terminate slow queries. </li> </ul>"},{"location":"3.ngql-guide/4.job-statements/","title":"Job manager and the JOB statements","text":"<p>The long-term tasks run by the Storage Service are called jobs, such as <code>COMPACT</code>, <code>FLUSH</code>, and <code>STATS</code>. These jobs can be time-consuming if the data amount in the graph space is large. The job manager helps you run, show, stop, and recover jobs.</p> <p>Note</p> <p>All job management commands can be executed only after selecting a graph space.</p>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_balance_leader","title":"SUBMIT JOB BALANCE LEADER","text":"<p>Starts a job to balance the distribution of all the storage leaders in all graph spaces. It returns the job ID.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB BALANCE LEADER;\n+------------+\n| New Job Id |\n+------------+\n| 33         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_compact","title":"SUBMIT JOB COMPACT","text":"<p>The <code>SUBMIT JOB COMPACT</code> statement triggers the long-term RocksDB <code>compact</code> operation in the current graph space.</p> <p>For more information about <code>compact</code> configuration, see Storage Service configuration.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB COMPACT;\n+------------+\n| New Job Id |\n+------------+\n| 40         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_flush","title":"SUBMIT JOB FLUSH","text":"<p>The <code>SUBMIT JOB FLUSH</code> statement writes the RocksDB memfile in the memory to the hard disk in the current graph space.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB FLUSH;\n+------------+\n| New Job Id |\n+------------+\n| 96         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_stats","title":"SUBMIT JOB STATS","text":"<p>The <code>SUBMIT JOB STATS</code> statement starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the <code>SHOW STATS</code> statement to list the statistics. For more information, see SHOW STATS.</p> <p>Note</p> <p>If the data stored in the graph space changes, in order to get the latest statistics, you have to run <code>SUBMIT JOB STATS</code> again.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 9          |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_downloadingest","title":"SUBMIT JOB DOWNLOAD/INGEST","text":"<p>The <code>SUBMIT JOB DOWNLOAD HDFS</code> and <code>SUBMIT JOB INGEST</code> commands are used to import the SST file into NebulaGraph. For detail, see Import data from SST files.</p> <p>The <code>SUBMIT JOB DOWNLOAD HDFS</code> command will download the SST file on the specified HDFS.</p> <p>The <code>SUBMIT JOB INGEST</code> command will import the downloaded SST file into NebulaGraph.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB DOWNLOAD HDFS \"hdfs://192.168.10.100:9000/sst\";\n+------------+\n| New Job Id |\n+------------+\n| 10         |\n+------------+\nnebula&gt; SUBMIT JOB INGEST;\n+------------+\n| New Job Id |\n+------------+\n| 11         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#show_job","title":"SHOW JOB","text":"<p>The Meta Service parses a <code>SUBMIT JOB</code> request into multiple tasks and assigns them to the nebula-storaged processes. The <code>SHOW JOB &lt;job_id&gt;</code> statement shows the information about a specific job and all its tasks in the current graph space.</p> <p><code>job_id</code> is returned when you run the <code>SUBMIT JOB</code> statement.</p> <p>For example:</p> <pre><code>nebula&gt; SHOW JOB 8;\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n| Job Id(TaskId) | Command(Dest)   | Status     | Start Time                 | Stop Time                  | Error Code  |\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n| 8              | \"STATS\"         | \"FINISHED\" | 2022-10-18T08:14:45.000000 | 2022-10-18T08:14:45.000000 | \"SUCCEEDED\" |\n| 0              | \"192.168.8.129\" | \"FINISHED\" | 2022-10-18T08:14:45.000000 | 2022-10-18T08:15:13.000000 | \"SUCCEEDED\" |\n| \"Total:1\"      | \"Succeeded:1\"   | \"Failed:0\" | \"In Progress:0\"            | \"\"                         | \"\"          |\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n</code></pre> <p>The descriptions are as follows.</p> Parameter Description <code>Job Id(TaskId)</code> The first row shows the job ID and the other rows show the task IDs and the last row shows the total number of job-related tasks. <code>Command(Dest)</code> The first row shows the command executed and the other rows show on which storaged processes the task is running. The last row shows the number of successful tasks related to the job. <code>Status</code> Shows the status of the job or task. The last row shows the number of failed tasks related to the job. For more information, see Job status. <code>Start Time</code> Shows a timestamp indicating the time when the job or task enters the <code>RUNNING</code> phase. The last row shows the number of ongoing tasks related to the job. <code>Stop Time</code> Shows a timestamp indicating the time when the job or task gets <code>FINISHED</code>, <code>FAILED</code>, or <code>STOPPED</code>. <code>Error Code</code> The error code of job."},{"location":"3.ngql-guide/4.job-statements/#job_status","title":"Job status","text":"<p>The descriptions are as follows.</p> Status Description QUEUE The job or task is waiting in a queue. The <code>Start Time</code> is empty in this phase. RUNNING The job or task is running. The <code>Start Time</code> shows the beginning time of this phase. FINISHED The job or task is successfully finished. The <code>Stop Time</code> shows the time when the job or task enters this phase. FAILED The job or task has failed. The <code>Stop Time</code> shows the time when the job or task enters this phase. STOPPED The job or task is stopped without running. The <code>Stop Time</code> shows the time when the job or task enters this phase. REMOVED The job or task is removed. <p>The description of switching the status is described as follows.</p> <pre><code>Queue -- running -- finished -- removed\n     \\          \\                /\n      \\          \\ -- failed -- /\n       \\          \\            /\n        \\ ---------- stopped -/\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#show_jobs","title":"SHOW JOBS","text":"<p>The <code>SHOW JOBS</code> statement lists all the unexpired jobs in the current graph space.</p> <p>The default job expiration interval is one week. You can change it by modifying the <code>job_expired_secs</code> parameter of the Meta Service. For how to modify <code>job_expired_secs</code>, see Meta Service configuration.</p> <p>For example:</p> <pre><code>nebula&gt; SHOW JOBS;\n+--------+---------------------+------------+----------------------------+----------------------------+\n| Job Id | Command             | Status     | Start Time                 | Stop Time                  |\n+--------+---------------------+------------+----------------------------+----------------------------+\n| 34     | \"STATS\"             | \"FINISHED\" | 2021-11-01T03:32:27.000000 | 2021-11-01T03:32:27.000000 |\n| 33     | \"FLUSH\"             | \"FINISHED\" | 2021-11-01T03:32:15.000000 | 2021-11-01T03:32:15.000000 |\n| 32     | \"COMPACT\"           | \"FINISHED\" | 2021-11-01T03:32:06.000000 | 2021-11-01T03:32:06.000000 |\n| 31     | \"REBUILD_TAG_INDEX\" | \"FINISHED\" | 2021-10-29T05:39:16.000000 | 2021-10-29T05:39:17.000000 |\n| 10     | \"COMPACT\"           | \"FINISHED\" | 2021-10-26T02:27:05.000000 | 2021-10-26T02:27:05.000000 |\n+--------+---------------------+------------+----------------------------+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#stop_job","title":"STOP JOB","text":"<p>The <code>STOP JOB &lt;job_id&gt;</code> statement stops jobs that are not finished in the current graph space.</p> <p>For example:</p> <pre><code>nebula&gt; STOP JOB 22;\n+---------------+\n| Result        |\n+---------------+\n| \"Job stopped\" |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#recover_job","title":"RECOVER JOB","text":"<p>The <code>RECOVER JOB [&lt;job_id&gt;]</code> statement re-executes the jobs that status is <code>FAILED</code> or <code>STOPPED</code> in the current graph space and returns the number of recovered jobs. If <code>&lt;job_id&gt;</code> is not specified, re-execution is performed from the earliest job and the number of jobs that have been recovered is returned.</p> <p>For example:</p> <pre><code>nebula&gt; RECOVER JOB;\n+-------------------+\n| Recovered job num |\n+-------------------+\n| 5 job recovered   |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#faq","title":"FAQ","text":""},{"location":"3.ngql-guide/4.job-statements/#how_to_troubleshoot_job_problems","title":"How to troubleshoot job problems?","text":"<p>The <code>SUBMIT JOB</code> operations use the HTTP port. Please check if the HTTP ports on the machines where the Storage Service is running are working well. You can use the following command to debug.</p> <pre><code>curl \"http://{storaged-ip}:19779/admin?space={space_name}&amp;op=compact\"\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/","title":"NebulaGraph Query Language (nGQL)","text":"<p>This topic gives an introduction to the query language of NebulaGraph, nGQL.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_is_ngql","title":"What is nGQL","text":"<p>nGQL is a declarative graph query language for NebulaGraph. It allows expressive and efficient graph patterns. nGQL is designed for both developers and operations professionals. nGQL is an SQL-like query language, so it's easy to learn.</p> <p>nGQL is a project in progress. New features and optimizations are done steadily. There can be differences between syntax and implementation. Submit an issue to inform the NebulaGraph team if you find a new issue of this type. NebulaGraph 3.0 or later releases will support openCypher 9.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_can_ngql_do","title":"What can nGQL do","text":"<ul> <li>Supports graph traversals</li> <li>Supports pattern match</li> <li>Supports aggregation</li> <li>Supports graph mutation</li> <li>Supports access control</li> <li>Supports composite queries</li> <li>Supports index</li> <li>Supports most openCypher 9 graph query syntax (but mutations and controls syntax are not supported)</li> </ul>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#example_data_basketballplayer","title":"Example data Basketballplayer","text":"<p>Users can download the example data Basketballplayer in NebulaGraph. After downloading the example data, you can import it to NebulaGraph by using the <code>-f</code> option in NebulaGraph Console.</p> <p>Note</p> <p>Ensure that you have executed the <code>ADD HOSTS</code> command to add the Storage service to your NebulaGraph cluster before importing the example data. For more information, see Manage Storage hosts.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#placeholder_identifiers_and_values","title":"Placeholder identifiers and values","text":"<p>Refer to the following standards in nGQL:</p> <ul> <li>(Draft) ISO/IEC JTC1 N14279 SC 32 - Database_Languages - GQL</li> </ul> <ul> <li>(Draft) ISO/IEC JTC1 SC32 N3228 - SQL_Property_Graph_Queries - SQLPGQ</li> </ul> <ul> <li>OpenCypher 9</li> </ul> <p>In template code, any token that is not a keyword, a literal value, or punctuation is a placeholder identifier or a placeholder value.</p> <p>For details of the symbols in nGQL syntax, see the following table:</p> Token Meaning &lt; &gt; name of a syntactic element : formula that defines an element [ ] optional elements { } explicitly specified elements | complete alternative elements ... may be repeated any number of times <p>For example, create vertices in nGQL syntax:</p> <pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES &lt;vid&gt;: ([prop_value_list])\ntag_props:\n  tag_name ([prop_name_list])\nprop_name_list:\n   [prop_name [, prop_name] ...]\nprop_value_list:\n   [prop_value [, prop_value] ...]  \n</code></pre> <p>Example statement:</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int);\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#about_opencypher_compatibility","title":"About openCypher compatibility","text":""},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#native_ngql_and_opencypher","title":"Native nGQL and openCypher","text":"<p>Native nGQL is the part of a graph query language designed and implemented by NebulaGraph. OpenCypher is a graph query language maintained by openCypher Implementers Group.</p> <p>The latest release is openCypher 9. The compatible parts of openCypher in nGQL are called openCypher compatible sentences (short as openCypher).</p> <p>Note</p> <p><code>nGQL</code> = <code>native nGQL</code> + <code>openCypher compatible sentences</code></p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#is_ngql_compatible_with_opencypher_9_completely","title":"Is nGQL compatible with openCypher 9 completely?","text":"<p>NO.</p> <p>Compatibility with openCypher</p> <p>nGQL is designed to be compatible with part of DQL (match, optional match, with, etc.).</p> <ul> <li>It is not planned to be compatible with any DDL, DML, or DCL.</li> <li>It is not planned to be compatible with the Bolt Protocol.</li> <li>It is not planned to be compatible with APOC and GDS.</li> </ul> <p>Users can search in this manual with the keyword <code>compatibility</code> to find major compatibility issues.  </p> <p>Multiple known incompatible items are listed in NebulaGraph Issues. Submit an issue with the <code>incompatible</code> tag if you find a new issue of this type. </p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_are_the_major_differences_between_ngql_and_opencypher_9","title":"What are the major differences between nGQL and openCypher 9?","text":"<p>The following are some major differences (by design incompatible) between nGQL and openCypher.</p> Category openCypher 9 nGQL Schema Optional Schema Strong Schema Equality operator <code>=</code> <code>==</code> Math exponentiation <code>^</code> <code>^</code> is not supported. Use pow(x, y) instead. Edge rank No such concept. edge rank (reference by @) Statement - All DMLs (<code>CREATE</code>, <code>MERGE</code>, etc) of openCypher 9. Label and tag A label is used for searching a vertex, namely an index of vertex. A tag defines the type of a vertex and its corresponding properties. It cannot be used as an index. Pre-compiling and parameterized queries Support Parameterized queries are supported, but precompiling is not. <p>Compatibility</p> <p>OpenCypher 9 and Cypher have some differences in grammar and licence. For example,</p> <ol> <li> <p>Cypher requires that All Cypher statements are explicitly run within a transaction. While openCypher has no such requirement. And nGQL does not support transactions.</p> </li> <li> <p>Cypher has a variety of constraints, including Unique node property constraints, Node property existence constraints, Relationship property existence constraints, and Node key constraints. While OpenCypher has no such constraints. As a strong schema system, most of the constraints mentioned above can be solved through schema definitions (including NOT NULL) in nGQL. The only function that cannot be supported is the UNIQUE constraint.</p> </li> <li> <p>Cypher has APoC, while openCypher 9 does not have APoC. Cypher has Blot protocol support requirements, while openCypher 9 does not.</p> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#where_can_i_find_more_ngql_examples","title":"Where can I find more nGQL examples?","text":"<p>Users can find more than 2500 nGQL examples in the features directory on the NebulaGraph GitHub page.</p> <p>The <code>features</code> directory consists of <code>.feature</code> files. Each file records scenarios that you can use as nGQL examples. Here is an example:</p> <pre><code>Feature: Basic match\n\n  Background:\n    Given a graph with space named \"basketballplayer\"\n\n  Scenario: Single node\n    When executing query:\n      \"\"\"\n      MATCH (v:player {name: \"Yao Ming\"}) RETURN v;\n      \"\"\"\n    Then the result should be, in any order, with relax comparison:\n      | v                                                |\n      | (\"player133\" :player{age: 38, name: \"Yao Ming\"}) |\n\n  Scenario: One step\n    When executing query:\n      \"\"\"\n      MATCH (v1:player{name: \"LeBron James\"}) -[r]-&gt; (v2)\n      RETURN type(r) AS Type, v2.player.name AS Name\n      \"\"\"\n    Then the result should be, in any order:\n\n      | Type     | Name        |\n      | \"follow\" | \"Ray Allen\" |\n      | \"serve\"  | \"Lakers\"    |\n      | \"serve\"  | \"Heat\"      |\n      | \"serve\"  | \"Cavaliers\" |\n\nFeature:  Comparison of where clause\n\n  Background:\n    Given a graph with space named \"basketballplayer\"\n\n    Scenario: push edge props filter down\n      When profiling query:\n        \"\"\"\n        GO FROM \"player100\" OVER follow \n        WHERE properties(edge).degree IN [v IN [95,99] WHERE v &gt; 0] \n        YIELD dst(edge), properties(edge).degree\n        \"\"\"\n      Then the result should be, in any order:\n        | follow._dst | follow.degree |\n        | \"player101\" | 95            |\n        | \"player125\" | 95            |\n      And the execution plan should be:\n        | id | name         | dependencies | operator info                                               |\n        | 0  | Project      | 1            |                                                             |\n        | 1  | GetNeighbors | 2            | {\"filter\": \"(properties(edge).degree IN [v IN [95,99] WHERE (v&gt;0)])\"} |\n        | 2  | Start        |              |                                                             |\n</code></pre> <p>The keywords in the preceding example are described as follows.</p> Keyword Description <code>Feature</code> Describes the topic of the current <code>.feature</code> file. <code>Background</code> Describes the background information of the current <code>.feature</code> file. <code>Given</code> Describes the prerequisites of running the test statements in the current <code>.feature</code> file. <code>Scenario</code> Describes the scenarios. If there is the <code>@skip</code> before one <code>Scenario</code>, this scenario may not work and do not use it as a working example in a production environment. <code>When</code> Describes the nGQL statement to be executed. It can be a <code>executing query</code> or <code>profiling query</code>. <code>Then</code> Describes the expected return results of running the statement in the <code>When</code> clause. If the return results in your environment do not match the results described in the <code>.feature</code> file, submit an issue to inform the NebulaGraph team. <code>And</code> Describes the side effects of running the statement in the <code>When</code> clause. <code>@skip</code> This test case will be skipped. Commonly, the to-be-tested code is not ready. <p>Welcome to add more tck case and return automatically to the using statements in CI/CD.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#does_it_support_tinkerpop_gremlin","title":"Does it support TinkerPop Gremlin?","text":"<p>No. And no plan to support that.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#does_nebulagraph_support_w3c_rdf_sparql_or_graphql","title":"Does NebulaGraph support W3C RDF (SPARQL) or GraphQL?","text":"<p>No. And no plan to support that.</p> <p>The data model of NebulaGraph is the property graph. And as a strong schema system, NebulaGraph does not support RDF.</p> <p>NebulaGraph Query Language does not support <code>SPARQL</code> nor <code>GraphQL</code>.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/","title":"Patterns","text":"<p>Patterns and graph pattern matching are the very heart of a graph query language. This topic will describe the patterns in NebulaGraph, some of which have not yet been implemented.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_vertices","title":"Patterns for vertices","text":"<p>A vertex is described using a pair of parentheses and is typically given a name. For example:</p> <pre><code>+--------------------+\n| e                  |\n+--------------------+\n| [{classYear:2007}] |\n| [{classYear:2006}] |\n...\n</code></pre> <pre><code>+--------------------+\n| e                  |\n+--------------------+\n| [{classYear:2007}] |\n| [{classYear:2006}] |\n...\n</code></pre> <p>Code format test </p> <pre><code>+-------------------------------------------------------------------------+\n| v3                                                                      |\n+-------------------------------------------------------------------------+\n| ({id:1436,name:\"Dhamar\",url:\"http://dbpedia.org/resource/Dhamar\"})      |\n| ({id:854,name:\"Ulyanovsk\",url:\"http://dbpedia.org/resource/Ulyanovsk\"}) |\n...\n</code></pre> <p>This simple pattern describes a single vertex and names that vertex using the variable <code>a</code>.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_related_vertices","title":"Patterns for related vertices","text":"<p>A more powerful construct is a pattern that describes multiple vertices and edges between them. Patterns describe an edge by employing an arrow between two vertices. For example:</p> <pre><code>(a)-[]-&gt;(b)\n</code></pre> <p>This pattern describes a very simple data structure: two vertices and a single edge from one to the other. In this example, the two vertices are named as <code>a</code> and <code>b</code> respectively and the edge is <code>directed</code>: it goes from <code>a</code> to <code>b</code>.</p> <p>This manner of describing vertices and edges can be extended to cover an arbitrary number of vertices and the edges between them, for example:</p> <pre><code>(a)-[]-&gt;(b)&lt;-[]-(c)\n</code></pre> <p>Such a series of connected vertices and edges is called a <code>path</code>.</p> <p>Note that the naming of the vertices in these patterns is only necessary when one needs to refer to the same vertex again, either later in the pattern or elsewhere in the query. If not, the name may be omitted as follows:</p> <pre><code>(a)-[]-&gt;()&lt;-[]-(c)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_tags","title":"Patterns for tags","text":"<p>Note</p> <p>The concept of <code>tag</code> in nGQL has a few differences from that of <code>label</code> in openCypher. For example, users must create a <code>tag</code> before using it. And a <code>tag</code> also defines the type of properties.</p> <p>In addition to simply describing the vertices in the graphs, patterns can also describe the tags of the vertices. For example:</p> <pre><code>(a:User)-[]-&gt;(b)\n</code></pre> <p>Patterns can also describe a vertex that has multiple tags. For example:</p> <pre><code>(a:User:Admin)-[]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_properties","title":"Patterns for properties","text":"<p>Vertices and edges are the fundamental elements in a graph. In nGQL, properties are added to them for richer models.</p> <p>In the patterns, the properties can be expressed as follows: some key-value pairs are enclosed in curly brackets and separated by commas, and the tag or edge type to which a property belongs must be specified.</p> <p>For example, a vertex with two properties will be like:</p> <pre><code>(a:player{name: \"Tim Duncan\", age: 42})\n</code></pre> <p>One of the edges that connect to this vertex can be like:</p> <pre><code>(a)-[e:follow{degree: 95}]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_edges","title":"Patterns for edges","text":"<p>The simplest way to describe an edge is by using the arrow between two vertices, as in the previous examples.</p> <p>Users can describe an edge and its direction using the following statement. If users do not care about its direction, the arrowhead can be omitted. For example:</p> <pre><code>(a)-[]-(b)\n</code></pre> <p>Like vertices, edges can also be named. A pair of square brackets will be used to separate the arrow and the variable will be placed between them. For example:</p> <pre><code>(a)-[r]-&gt;(b)\n</code></pre> <p>Like the tags on vertices, edges can also have types. To describe an edge with a specific type, use the pattern as follows:</p> <pre><code>(a)-[r:REL_TYPE]-&gt;(b)\n</code></pre> <p>An edge can only have one edge type. But if we'd like to describe some data such that the edge could have a set of types, then they can all be listed in the pattern, separating them with the pipe symbol <code>|</code> like this:</p> <pre><code>(a)-[r:TYPE1|TYPE2]-&gt;(b)\n</code></pre> <p>Like vertices, the name of an edge can be omitted. For example:</p> <pre><code>(a)-[:REL_TYPE]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#variable-length_pattern","title":"Variable-length pattern","text":"<p>Rather than describing a long path using a sequence of many vertex and edge descriptions in a pattern, many edges (and the intermediate vertices) can be described by specifying a length in the edge description of a pattern. For example:</p> <pre><code>(a)-[*2]-&gt;(b)\n</code></pre> <p>The following pattern describes a graph of three vertices and two edges, all in one path (a path of length 2). It is equivalent to:</p> <pre><code>(a)-[]-&gt;()-[]-&gt;(b)\n</code></pre> <p>The range of lengths can also be specified. Such edge patterns are called <code>variable-length edges</code>. For example:</p> <pre><code>(a)-[*3..5]-&gt;(b)\n</code></pre> <p>The preceding example defines a path with a minimum length of 3 and a maximum length of 5.</p> <p>It describes a graph of either 4 vertices and 3 edges, 5 vertices and 4 edges, or 6 vertices and 5 edges, all connected in a single path.</p> <p>The lower bound can be omitted. For example, to describe paths of length 5 or less, use:</p> <pre><code>(a)-[*..5]-&gt;(b)\n</code></pre> <p>Note</p> <p>The upper bound must be specified. The following are NOT accepted.</p> <pre><code>(a)-[*3..]-&gt;(b)\n(a)-[*]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#assigning_to_path_variables","title":"Assigning to path variables","text":"<p>As described above, a series of connected vertices and edges is called a <code>path</code>. nGQL allows paths to be named using variables. For example:</p> <pre><code>p = (a)-[*3..5]-&gt;(b)\n</code></pre> <p>Users can do this in the <code>MATCH</code> statement.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/","title":"Comments","text":"<p>This topic will describe the comments in nGQL.</p> <p>Legacy version compatibility</p> <ul> <li>In NebulaGraph 1.x, there are four comment styles: <code>#</code>, <code>--</code>, <code>//</code>, <code>/* */</code>.</li> <li>Since NebulaGraph 2.x, <code>--</code> cannot be used as comments.</li> </ul>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/#examples","title":"Examples","text":"<pre><code>nebula&gt; # Do nothing in this line\nnebula&gt; RETURN 1+1;     # This comment continues to the end of this line.\nnebula&gt; RETURN 1+1;     // This comment continues to the end of this line.\nnebula&gt; RETURN 1 /* This is an in-line comment. */ + 1 == 2;\nnebula&gt; RETURN 11 +            \\\n/* Multi-line comment.       \\\nUse a backslash as a line break.   \\\n*/ 12;\n</code></pre> <p>In nGQL statement, the backslash <code>\\</code> in a line indicates a line break.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>In nGQL, you must add a <code>\\</code> at the end of every line, even in multi-line comments <code>/* */</code>.</li> <li>In openCypher, there is no need to use a <code>\\</code> as a line break.</li> </ul> <pre><code>/* openCypher style:\nThe following comment\nspans more than\none line */\nMATCH (n:label)\nRETURN n;\n</code></pre> <pre><code>/* nGQL style:  \\\nThe following comment       \\\nspans more than     \\\none line */       \\\nMATCH (n:tag) \\\nRETURN n;\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/","title":"Identifier case sensitivity","text":""},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#identifiers_are_case-sensitive","title":"Identifiers are Case-Sensitive","text":"<p>The following statements will not work because they refer to two different spaces, i.e. <code>my_space</code> and <code>MY_SPACE</code>.</p> <pre><code>nebula&gt; CREATE SPACE IF NOT EXISTS my_space (vid_type=FIXED_STRING(30));\nnebula&gt; use MY_SPACE;\n[ERROR (-1005)]: SpaceNotFound:\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#keywords_and_reserved_words_are_case-insensitive","title":"Keywords and Reserved Words are Case-Insensitive","text":"<p>The following statements are equivalent since <code>show</code> and <code>spaces</code> are keywords.</p> <pre><code>nebula&gt; show spaces;  \nnebula&gt; SHOW SPACES;\nnebula&gt; SHOW spaces;\nnebula&gt; show SPACES;\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#functions_are_case-insensitive","title":"Functions are Case-Insensitive","text":"<p>Functions are case-insensitive. For example, <code>count()</code>, <code>COUNT()</code>, and <code>couNT()</code> are equivalent.</p> <pre><code>nebula&gt; WITH [NULL, 1, 1, 2, 2] As a \\\n        UNWIND a AS b \\\n        RETURN count(b), COUNT(*), couNT(DISTINCT b);\n+----------+----------+-------------------+\n| count(b) | COUNT(*) | couNT(distinct b) |\n+----------+----------+-------------------+\n| 4        | 5        | 2                 |\n+----------+----------+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/","title":"Keywords","text":"<p>Keywords in nGQL are words with particular meanings, such as <code>CREATE</code> and <code>TAG</code> in the <code>CREATE TAG</code> statement. Keywords that require special processing to be used as identifiers are referred to as <code>reserved keywords</code>, while the part of keywords that can be used directly as identifiers are called <code>non-reserved keywords</code>.\"</p> <p>It is not recommend to use keywords in schema. If you must use keywords in schema:</p> <ul> <li>Non-reserved keywords can be used as identifiers without quotes if they are all in lowercase. However, if a non-reserved keyword contains any uppercase letters when used as an identifier, it must be enclosed in backticks (`), for example, `Comment`.</li> </ul> <ul> <li>To use special characters or reserved keywords as identifiers, quote them with backticks such as <code>AND</code>.</li> </ul> <p>Note</p> <p>Keywords are case-insensitive.</p> <pre><code>nebula&gt; CREATE TAG TAG(name string);\n[ERROR (-1004)]: SyntaxError: syntax error near `TAG'\n\nnebula&gt; CREATE TAG `TAG` (name string);\nExecution succeeded\n\nnebula&gt; CREATE TAG SPACE(name string);\nExecution succeeded\n\nnebula&gt; CREATE TAG \u4e2d\u6587(\u7b80\u4f53 string);\nExecution succeeded\n\nnebula&gt; CREATE TAG `\uffe5%special characters&amp;*+-*/` (`q~\uff01\uff08\uff09=  wer` string);\nExecution succeeded\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/#reserved_keywords","title":"Reserved keywords","text":"<pre><code>ACROSS\nADD\nALTER\nAND\nAS\nASC\nASCENDING\nBALANCE\nBOOL\nBY\nCASE\nCHANGE\nCOMPACT\nCREATE\nDATE\nDATETIME\nDELETE\nDESC\nDESCENDING\nDESCRIBE\nDISTINCT\nDOUBLE\nDOWNLOAD\nDROP\nDURATION\nEDGE\nEDGES\nEXISTS\nEXPLAIN\nFETCH\nFIND\nFIXED_STRING\nFLOAT\nFLUSH\nFORMAT\nFROM\nGET\nGO\nGRANT\nIF\nIGNORE_EXISTED_INDEX\nIN\nINDEX\nINDEXES\nINGEST\nINSERT\nINT\nINT16\nINT32\nINT64\nINT8\nINTERSECT\nIS\nLIMIT\nLIST\nLOOKUP\nMAP\nMATCH\nMINUS\nNO\nNOT\nNOT_IN\nNULL\nOF\nOFFSET\nON\nOR\nORDER\nOVER\nOVERWRITE\nPROFILE\nPROP\nREBUILD\nRECOVER\nREMOVE\nRESTART\nRETURN\nREVERSELY\nREVOKE\nSET\nSHOW\nSTEP\nSTEPS\nSTOP\nSTRING\nSUBMIT\nTAG\nTAGS\nTIME\nTIMESTAMP\nTO\nUNION\nUPDATE\nUPSERT\nUPTO\nUSE\nVERTEX\nVERTICES\nWHEN\nWHERE\nWITH\nXOR\nYIELD\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/#non-reserved_keywords","title":"Non-reserved keywords","text":"<pre><code>ACCOUNT\nADMIN\nALL\nANY\nATOMIC_EDGE\nAUTO\nBIDIRECT\nBOTH\nCHARSET\nCLIENTS\nCOLLATE\nCOLLATION\nCOMMENT\nCONFIGS\nCONTAINS\nDATA\nDBA\nDEFAULT\nELASTICSEARCH\nELSE\nEND\nENDS\nENDS_WITH\nFALSE\nFORCE\nFULLTEXT\nFUZZY\nGOD\nGRAPH\nGROUP\nGROUPS\nGUEST\nHDFS\nHOST\nHOSTS\nINTO\nIS_EMPTY\nIS_NOT_EMPTY\nIS_NOT_NULL\nIS_NULL\nJOB\nJOBS\nKILL\nLEADER\nLISTENER\nMETA\nNOLOOP\nNONE\nNOT_CONTAINS\nNOT_ENDS_WITH\nNOT_STARTS_WITH\nOPTIONAL\nOUT\nPART\nPARTITION_NUM\nPARTS\nPASSWORD\nPATH\nPLAN\nPREFIX\nQUERIES\nQUERY\nREDUCE\nREGEXP\nREPLICA_FACTOR\nRESET\nROLE\nROLES\nSAMPLE\nSEARCH\nSERVICE\nSESSION\nSESSIONS\nSHORTEST\nSIGN\nSINGLE\nSKIP\nSNAPSHOT\nSNAPSHOTS\nSPACE\nSPACES\nSTARTS\nSTARTS_WITH\nSTATS\nSTATUS\nSTORAGE\nSUBGRAPH\nTEXT\nTEXT_SEARCH\nTHEN\nTOP\nTRUE\nTTL_COL\nTTL_DURATION\nUNWIND\nUSER\nUSERS\nUUID\nVALUE\nVALUES\nVID_TYPE\nWILDCARD\nZONE\nZONES\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/","title":"nGQL style guide","text":"<p>nGQL does not have strict formatting requirements, but creating nGQL statements according to an appropriate and uniform style can improve readability and avoid ambiguity. Using the same nGQL style in the same organization or project helps reduce maintenance costs and avoid problems caused by format confusion or misunderstanding. This topic will provide a style guide for writing nGQL statements.</p> <p>Compatibility</p> <p>The styles of nGQL and Cypher Style Guide are different.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#newline","title":"Newline","text":"<ol> <li> <p>Start a new line to write a clause.</p> <p>Not recommended:</p> <pre><code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id;\n</code></pre> <p>Recommended:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow REVERSELY \\\nYIELD src(edge) AS id;\n</code></pre> </li> <li> <p>Start a new line to write different statements in a composite statement.</p> <p>Not recommended:</p> <pre><code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id | GO FROM $-.id \\\nOVER serve WHERE properties($^).age &gt; 20 YIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n</code></pre> <p>Recommended:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow REVERSELY \\\nYIELD src(edge) AS id | \\\nGO FROM $-.id OVER serve \\\nWHERE properties($^).age &gt; 20 \\\nYIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n</code></pre> </li> <li> <p>If the clause exceeds 80 characters, start a new line at the appropriate place.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\nWHERE (v2.player.name STARTS WITH \"Y\" AND v2.player.age &gt; 35 AND v2.player.age &lt; v.player.age) OR (v2.player.name STARTS WITH \"T\" AND v2.player.age &lt; 45 AND v2.player.age &gt; v.player.age) \\\nRETURN v2;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\nWHERE (v2.player.name STARTS WITH \"Y\" AND v2.player.age &gt; 35 AND v2.player.age &lt; v.player.age) \\\nOR (v2.player.name STARTS WITH \"T\" AND v2.player.age &lt; 45 AND v2.player.age &gt; v.player.age) \\\nRETURN v2;\n</code></pre> </li> </ol> <p>Note</p> <p>If needed, you can also start a new line for better understanding, even if the clause does not exceed 80 characters. </p>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#identifier_naming","title":"Identifier naming","text":"<p>In nGQL statements, characters other than keywords, punctuation marks, and blanks are all identifiers. Recommended methods to name the identifiers are as follows.</p> <ol> <li> <p>Use singular nouns to name tags, and use the base form of verbs or verb phrases to form Edge types.</p> <p>Not recommended:</p> <pre><code>MATCH p=(v:players)-[e:are_following]-(v2) \\\nRETURN nodes(p);\n</code></pre> <p>Recommended:</p> <pre><code>MATCH p=(v:player)-[e:follow]-(v2) \\\nRETURN nodes(p);\n</code></pre> </li> <li> <p>Use the snake case to name identifiers, and connect words with underscores (_) with all the letters lowercase.</p> <p>Not recommended:</p> <pre><code>MATCH (v:basketballTeam) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:basketball_team) \\\nRETURN v;\n</code></pre> </li> <li> <p>Use uppercase keywords and lowercase variables.</p> <p>Not recommended:</p> <pre><code>match (V:player) return V limit 5;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player) RETURN v LIMIT 5;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#pattern","title":"Pattern","text":"<ol> <li> <p>Start a new line on the right side of the arrow indicating an edge when writing patterns.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player{name: \"Tim Duncan\", age: 42}) \\\n-[e:follow]-&gt;()-[e:serve]-&gt;()&lt;--(v2) \\\nRETURN v, e, v2;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player{name: \"Tim Duncan\", age: 42})-[e:follow]-&gt; \\\n()-[e:serve]-&gt;()&lt;--(v2) \\\nRETURN v, e, v2;\n</code></pre> </li> <li> <p>Anonymize the vertices and edges that do not need to be queried.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player)-[e:follow]-&gt;(v2) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player)-[:follow]-&gt;() \\\nRETURN v;\n</code></pre> </li> <li> <p>Place named vertices in front of anonymous vertices.</p> <p>Not recommended:</p> <pre><code>MATCH ()-[:follow]-&gt;(v) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v)&lt;-[:follow]-() \\\nRETURN v;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#string","title":"String","text":"<p>The strings should be surrounded by double quotes.</p> <p>Not recommended:</p> <pre><code>RETURN 'Hello Nebula!';\n</code></pre> <p>Recommended:</p> <pre><code>RETURN \"Hello Nebula!\\\"123\\\"\";\n</code></pre> <p>Note</p> <p>When single or double quotes need to be nested in a string, use a backslash () to escape. For example:</p> <pre><code>RETURN \"\\\"NebulaGraph is amazing,\\\" the user says.\";\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#statement_termination","title":"Statement termination","text":"<ol> <li> <p>End the nGQL statements with an English semicolon (;).</p> <p>Not recommended:</p> <pre><code>FETCH PROP ON player \"player100\" YIELD properties(vertex)\n</code></pre> <p>Recommended:</p> <pre><code>FETCH PROP ON player \"player100\" YIELD properties(vertex);\n</code></pre> </li> <li> <p>Use a pipe (|) to separate a composite statement, and end the statement with an English semicolon at the end of the last line. Using an English semicolon before a pipe will cause the statement to fail.</p> <p>Not supported:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow \\\nYIELD dst(edge) AS id; | \\\nGO FROM $-.id \\\nOVER serve \\\nYIELD properties($$).name AS Team, properties($^).name AS Player;\n</code></pre> <p>Supported:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow \\\nYIELD dst(edge) AS id | \\\nGO FROM $-.id \\\nOVER serve \\\nYIELD properties($$).name AS Team, properties($^).name AS Player;\n</code></pre> </li> <li> <p>In a composite statement that contains user-defined variables, use an English semicolon to end the statements that define the variables. If you do not follow the rules to add a semicolon or use a pipe to end the composite statement, the execution will fail.</p> <p>Not supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> <p>Not supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id | \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> <p>Supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id; \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/3.data-types/1.numeric/","title":"Numeric types","text":"<p>nGQL supports both integer and floating-point number.</p>"},{"location":"3.ngql-guide/3.data-types/1.numeric/#integer","title":"Integer","text":"<p>Signed 64-bit integer (INT64), 32-bit integer (INT32), 16-bit integer (INT16), and 8-bit integer (INT8) are supported.</p> Type Declared keywords Range INT64 <code>INT64</code> or<code>INT</code> -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 INT32 <code>INT32</code> -2,147,483,648 ~ 2,147,483,647 INT16 <code>INT16</code> -32,768 ~ 32,767 INT8 <code>INT8</code> -128 ~ 127"},{"location":"3.ngql-guide/3.data-types/1.numeric/#floating-point_number","title":"Floating-point number","text":"<p>Both single-precision floating-point format (FLOAT) and double-precision floating-point format (DOUBLE) are supported.</p> Type Declared keywords Range Precision FLOAT <code>FLOAT</code> 3.4E +/- 38 6~7 bits DOUBLE <code>DOUBLE</code> 1.7E +/- 308 15~16 bits <p>Scientific notation is also supported, such as <code>1e2</code>, <code>1.1e2</code>, <code>.3e4</code>, <code>1.e4</code>, and <code>-1234E-10</code>.</p> <p>Note</p> <p>The data type of DECIMAL in MySQL is not supported.</p>"},{"location":"3.ngql-guide/3.data-types/1.numeric/#reading_and_writing_of_data_values","title":"Reading and writing of data values","text":"<p>When writing and reading different types of data, nGQL complies with the following rules:</p> Data type Set as VID Set as property Resulted data type INT64 Supported Supported INT64 INT32 Not supported Supported INT64 INT16 Not supported Supported INT64 INT8 Not supported Supported INT64 FLOAT Not supported Supported DOUBLE DOUBLE Not supported Supported DOUBLE <p>For example, nGQL does not support setting VID as INT8, but supports setting a certain property type of TAG or Edge type as INT8. When using the nGQL statement to read the property of INT8, the resulted type is INT64.</p> <ul> <li> <p>Multiple formats are supported:</p> <ul> <li>Decimal, such as <code>123456</code>.</li> <li>Hexadecimal, such as <code>0x1e240</code>.</li> <li>Octal, such as <code>0361100</code>.</li> </ul> <p>However, NebulaGraph will parse the written non-decimal value into a decimal value and save it. The value read is decimal.</p> <p>For example, the type of the property <code>score</code> is <code>INT</code>. The value of <code>0xb</code> is assigned to it through the INSERT statement. If querying the property value with statements such as FETCH, you will get the result <code>11</code>, which is the decimal result of the hexadecimal <code>0xb</code>.</p> </li> </ul> <ul> <li>Round a FLOAT/DOUBLE value when inserting it to an INT column.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/10.geography/","title":"Geography","text":"<p>Geography is a data type composed of latitude and longitude that represents geospatial information. NebulaGraph currently supports Point, LineString, and Polygon in Simple Features and some functions in SQL-MM 3, such as part of the core geo parsing, construction, formatting, conversion, predicates, and dimensions.</p>"},{"location":"3.ngql-guide/3.data-types/10.geography/#type_description","title":"Type description","text":"<p>A point is the basic data type of geography, which is determined by a latitude and a longitude. For example, <code>\"POINT(3 8)\"</code> means that the longitude is <code>3\u00b0</code> and the latitude is <code>8\u00b0</code>. Multiple points can form a linestring or a polygon.</p> <p>Note</p> <p>You cannot directly insert geographic data of the following types, such as <code>INSERT VERTEX any_shape(geo) VALUES \"1\":(\"POINT(1 1)\")</code>. Instead, you need to use a geography function to specify the data type before inserting, such as <code>INSERT VERTEX any_shape(geo) VALUES \"1\":(ST_GeogFromText(\"POINT(1 1)\"));</code>.</p> Shape Example Description Point <code>\"POINT(3 8)\"</code> Specifies the data type as a point. LineString <code>\"LINESTRING(3 8, 4.7 73.23)\"</code> Specifies the data type as a linestring. Polygon <code>\"POLYGON((0 1, 1 2, 2 3, 0 1))\"</code> Specifies the data type as a polygon."},{"location":"3.ngql-guide/3.data-types/10.geography/#examples","title":"Examples","text":"<pre><code>//Create a Tag to allow storing any geography data type.\nnebula&gt; CREATE TAG IF NOT EXISTS any_shape(geo geography);\n\n//Create a Tag to allow storing a point only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_point(geo geography(point));\n\n//Create a Tag to allow storing a linestring only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_linestring(geo geography(linestring));\n\n//Create a Tag to allow storing a polygon only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_polygon(geo geography(polygon));\n\n//Create an Edge type to allow storing any geography data type.\nnebula&gt; CREATE EDGE IF NOT EXISTS any_shape_edge(geo geography);\n\n//Create a vertex to store the geography of a polygon.\nnebula&gt; INSERT VERTEX any_shape(geo) VALUES \"103\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n\n//Create an edge to store the geography of a polygon.\nnebula&gt; INSERT EDGE any_shape_edge(geo) VALUES \"201\"-&gt;\"302\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n\n//Query the geography of Vertex 103.\nnebula&gt; FETCH PROP ON any_shape \"103\" YIELD ST_ASText(any_shape.geo);\n+---------------------------------+\n| ST_ASText(any_shape.geo)        |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n\n//Query the geography of the edge which traverses from Vertex 201 to Vertex 302.\nnebula&gt; FETCH PROP ON any_shape_edge \"201\"-&gt;\"302\" YIELD ST_ASText(any_shape_edge.geo);\n+---------------------------------+\n| ST_ASText(any_shape_edge.geo)   |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n\n//Create an index for the geography of the Tag any_shape and run LOOKUP.\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo);\nnebula&gt; REBUILD TAG INDEX any_shape_geo_index;\nnebula&gt; LOOKUP ON any_shape YIELD ST_ASText(any_shape.geo);\n+---------------------------------+\n| ST_ASText(any_shape.geo)        |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n</code></pre> <p>When creating an index for geography properties, you can specify the parameters for the index.</p> Parameter Default value Description <code>s2_max_level</code> <code>30</code> The maximum level of S2 cell used in the covering. Allowed values: <code>1</code>~<code>30</code>. Setting it to less than the default means that NebulaGraph will be forced to generate coverings using larger cells. <code>s2_max_cells</code> <code>8</code> The maximum number of S2 cells used in the covering. Provides a limit on how much work is done exploring the possible coverings. Allowed values: <code>1</code>~<code>30</code>. You may want to use higher values for odd-shaped regions such as skinny rectangles. <p>Note</p> <p>Specifying the above two parameters does not affect the Point type of property. The <code>s2_max_level</code> value of the Point type is forced to be <code>30</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo) with (s2_max_level=30, s2_max_cells=8);\n</code></pre> <p>For more index information, see Index overview.</p>"},{"location":"3.ngql-guide/3.data-types/2.boolean/","title":"Boolean","text":"<p>A boolean data type is declared with the <code>bool</code> keyword and can only take the values <code>true</code> or <code>false</code>.</p> <p>nGQL supports using boolean in the following ways:</p> <ul> <li>Define the data type of the property value as a boolean.</li> <li>Use boolean as judgment conditions in the <code>WHERE</code> clause.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/","title":"String","text":"<p>Fixed-length strings and variable-length strings are supported.</p>"},{"location":"3.ngql-guide/3.data-types/3.string/#declaration_and_literal_representation","title":"Declaration and literal representation","text":"<p>The string type is declared with the keywords of:</p> <ul> <li><code>STRING</code>: Variable-length strings.</li> <li><code>FIXED_STRING(&lt;length&gt;)</code>: Fixed-length strings. <code>&lt;length&gt;</code> is the length of the string, such as <code>FIXED_STRING(32)</code>.</li> </ul> <p>A string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example, <code>\"Hello, Cooper\"</code> or <code>'Hello, Cooper'</code>.</p>"},{"location":"3.ngql-guide/3.data-types/3.string/#string_reading_and_writing","title":"String reading and writing","text":"<p>Nebula\u00a0Graph supports using string types in the following ways:</p> <ul> <li>Define the data type of VID as a fixed-length string.</li> <li>Set the variable-length string as the Schema name, including the names of the graph space, tag, edge type, and property.</li> <li>Define the data type of the property as a fixed-length or variable-length string.</li> </ul> <p>For example:</p> <ul> <li>Define the data type of the property as a fixed-length string<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t1 (p1 FIXED_STRING(10)); \n</code></pre> </li> </ul> <ul> <li>Define the data type of the property as a variable-length string<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t2 (p2 STRING); \n</code></pre> </li> </ul> <p>When the fixed-length string you try to write exceeds the length limit:</p> <ul> <li>If the fixed-length string is a property, the writing will succeed, and NebulaGraph will truncate the string and only store the part that meets the length limit.</li> <li>If the fixed-length string is a VID, the writing will fail and NebulaGraph will return an error.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/#escape_characters","title":"Escape characters","text":"<p>Line breaks are not allowed in a string. Escape characters are supported within strings, for example:</p> <ul> <li><code>\"\\n\\t\\r\\b\\f\"</code></li> </ul> <ul> <li><code>\"\\110ello world\"</code></li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>There are some tiny differences between openCypher and Cypher, as well as nGQL. The following is what openCypher requires. Single quotes cannot be converted to double quotes.</p> <pre><code># File: Literals.feature\nFeature: Literals\n\nBackground:\n    Given any graph\n Scenario: Return a single-quoted string\n    When executing query:\n      \"\"\"\n      RETURN '' AS literal\n      \"\"\"\n    Then the result should be, in any order:\n      | literal |\n      | ''      |    # Note: it should return single-quotes as openCypher required.\n    And no side effects\n</code></pre> <p>While Cypher accepts both single quotes and double quotes as the return results. nGQL follows the Cypher way.</p> <pre><code>nebula &gt; YIELD '' AS quote1, \"\" AS quote2, \"'\" AS quote3, '\"' AS quote4\n+--------+--------+--------+--------+\n| quote1 | quote2 | quote3 | quote4 |\n+--------+--------+--------+--------+\n| \"\"     | \"\"     | \"'\"    | \"\"\"    |\n+--------+--------+--------+--------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/","title":"Date and time types","text":"<p>This topic will describe the <code>DATE</code>, <code>TIME</code>, <code>DATETIME</code>, <code>TIMESTAMP</code>, and <code>DURATION</code> types.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#precautions","title":"Precautions","text":"<ul> <li> <p>While inserting time-type property values with <code>DATE</code>, <code>TIME</code>, and <code>DATETIME</code>, NebulaGraph transforms them to a UTC time according to the timezone specified with the <code>timezone_name</code> parameter in the configuration files. </p> <p>Note</p> <p>To change the timezone, modify the <code>timezone_name</code> value in the configuration files of all NebulaGraph services.</p> </li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, and <code>datetime()</code> can convert a time-type property with a specified timezone. For example, <code>datetime(\"2017-03-04 22:30:40.003000+08:00\")</code> or <code>datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\")</code>.</li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, <code>datetime()</code>, and <code>timestamp()</code> all accept empty parameters to return the current date, time, and datetime.</li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, and <code>datetime()</code> all accept the property name to return a specific property value of itself. For example, <code>date().month</code> returns the current month, while <code>time(\"02:59:40\").minute</code> returns the minutes of the importing time.</li> </ul> <ul> <li>For time operations it is recommended to use <code>duration()</code> to calculate the offset of the moment. Addition and subtraction of <code>date()</code> and <code>date()</code>, <code>timestamp()</code> and <code>timestamp()</code> are also supported.</li> </ul> <ul> <li>When setting the year of the time as a negative number, you need to use Map type data.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>In nGQL:</p> <ul> <li>Year, month, day, hour, minute, second, millisecond, and microsecond are supported, while the nanosecond is not supported.</li> </ul> <ul> <li><code>localdatetime()</code> is not supported.</li> </ul> <ul> <li>Most string time formats are not supported. The exceptions are <code>YYYY-MM-DDThh:mm:ss</code> and <code>YYYY-MM-DD hh:mm:ss</code>.</li> </ul> <ul> <li>The single-digit string time format is supported. For example, <code>time(\"1:1:1\")</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#date","title":"DATE","text":"<p>The <code>DATE</code> type is used for values with a date part but no time part. Nebula\u00a0Graph retrieves and displays <code>DATE</code> values in the <code>YYYY-MM-DD</code> format. The supported range is <code>-32768-01-01</code> to <code>32767-12-31</code>.</p> <p>The properties of <code>date()</code> include <code>year</code>, <code>month</code>, and <code>day</code>. <code>date()</code> supports the input of <code>YYYYY</code>, <code>YYYYY-MM</code> or <code>YYYYY-MM-DD</code>, and defaults to <code>01</code> for an untyped month or day.</p> <pre><code>nebula&gt; RETURN DATE({year:-123, month:12, day:3});\n+------------------------------------+\n| date({year:-(123),month:12,day:3}) |\n+------------------------------------+\n| -123-12-03                         |\n+------------------------------------+\n\nnebula&gt; RETURN DATE(\"23333\");\n+---------------+\n| date(\"23333\") |\n+---------------+\n| 23333-01-01   |\n+---------------+\n\nnebula&gt; RETURN DATE(\"2023-12-12\") - DATE(\"2023-12-11\");\n+-----------------------------------------+\n| (date(\"2023-12-12\")-date(\"2023-12-11\")) |\n+-----------------------------------------+\n| 1                                       |\n+-----------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#time","title":"TIME","text":"<p>The <code>TIME</code> type is used for values with a time part but no date part. Nebula\u00a0Graph retrieves and displays <code>TIME</code> values in <code>hh:mm:ss.msmsmsususus</code> format. The supported range is <code>00:00:00.000000</code> to <code>23:59:59.999999</code>.</p> <p>The properties of <code>time()</code> include <code>hour</code>, <code>minute</code>, and <code>second</code>.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#datetime","title":"DATETIME","text":"<p>The <code>DATETIME</code> type is used for values that contain both date and time parts. Nebula\u00a0Graph retrieves and displays <code>DATETIME</code> values in <code>YYYY-MM-DDThh:mm:ss.msmsmsususus</code> format. The supported range is <code>-32768-01-01T00:00:00.000000</code> to <code>32767-12-31T23:59:59.999999</code>.</p> <ul> <li>The properties of <code>datetime()</code> include <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, and <code>second</code>.</li> </ul> <ul> <li><code>datetime()</code> can convert <code>TIMESTAMP</code> to <code>DATETIME</code>. The value range of <code>TIMESTAMP</code> is <code>0~9223372036</code>.</li> </ul> <ul> <li><code>datetime()</code> supports an <code>int</code> argument. The <code>int</code> argument specifies a timestamp.</li> </ul> <pre><code># To get the current date and time.\nnebula&gt; RETURN datetime();\n+----------------------------+\n| datetime()                 |\n+----------------------------+\n| 2022-08-29T06:37:08.933000 |\n+----------------------------+\n\n# To get the current hour.\nnebula&gt; RETURN datetime().hour;\n+-----------------+\n| datetime().hour |\n+-----------------+\n| 6               |\n+-----------------+\n\n# To get date time from a given timestamp.\nnebula&gt; RETURN datetime(timestamp(1625469277));\n+---------------------------------+\n| datetime(timestamp(1625469277)) |\n+---------------------------------+\n| 2021-07-05T07:14:37.000000      |\n+---------------------------------+\n\nnebula&gt; RETURN datetime(1625469277);\n+----------------------------+\n| datetime(1625469277)       |\n+----------------------------+\n| 2021-07-05T07:14:37.000000 |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#timestamp","title":"TIMESTAMP","text":"<p>The <code>TIMESTAMP</code> data type is used for values that contain both date and time parts. It has a range of <code>1970-01-01T00:00:01</code> UTC to <code>2262-04-11T23:47:16</code> UTC.</p> <p><code>TIMESTAMP</code> has the following features:</p> <ul> <li>Stored and displayed in the form of a timestamp, such as <code>1615974839</code>, which means <code>2021-03-17T17:53:59</code>.</li> </ul> <ul> <li>Supported <code>TIMESTAMP</code> querying methods: timestamp and <code>timestamp()</code> function.</li> </ul> <ul> <li>Supported <code>TIMESTAMP</code> inserting methods: timestamp, <code>timestamp()</code> function, and <code>now()</code> function.</li> </ul> <ul> <li><code>timestamp()</code> function accepts empty arguments to get the current timestamp. It can pass an integer arguments to identify the integer as a timestamp and the range of passed integer is: <code>0~9223372036</code>\u3002</li> </ul> <ul> <li><code>timestamp()</code> function can convert <code>DATETIME</code> to <code>TIMESTAMP</code>, and the data type of <code>DATETIME</code> should be a <code>string</code>. </li> </ul> <ul> <li>The underlying storage data type is int64.</li> </ul> <pre><code># To get the current timestamp.\nnebula&gt; RETURN timestamp();\n+-------------+\n| timestamp() |\n+-------------+\n| 1625469277  |\n+-------------+\n\n# To get a timestamp from given date and time.\nnebula&gt; RETURN timestamp(\"2022-01-05T06:18:43\");\n+----------------------------------+\n| timestamp(\"2022-01-05T06:18:43\") |\n+----------------------------------+\n| 1641363523                       |\n+----------------------------------+\n\n# To get a timestamp using datetime().\nnebula&gt; RETURN timestamp(datetime(\"2022-08-29T07:53:10.939000\"));\n+---------------------------------------------------+\n| timestamp(datetime(\"2022-08-29T07:53:10.939000\")) |\n+---------------------------------------------------+\n| 1661759590                                        |\n+---------------------------------------------------+    \n</code></pre> <p>Note</p> <p>The date and time format string passed into <code>timestamp()</code> cannot include any millisecond and microsecond, but the date and time format string passed into <code>timestamp(datetime())</code> can include a millisecond and a microsecond.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#duration","title":"DURATION","text":"<p>The <code>DURATION</code> data type is used to indicate a period of time. Map data that are freely combined by <code>years</code>, <code>months</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, and <code>seconds</code> indicates the <code>DURATION</code>.</p> <p><code>DURATION</code> has the following features:</p> <ul> <li>Creating indexes for <code>DURATION</code> is not supported.</li> </ul> <ul> <li><code>DURATION</code> can be used to calculate the specified time.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#examples","title":"Examples","text":"<ol> <li> <p>Create a tag named <code>date1</code> with three properties: <code>DATE</code>, <code>TIME</code>, and <code>DATETIME</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS date1(p1 date, p2 time, p3 datetime);\n</code></pre> </li> <li> <p>Insert a vertex named <code>test1</code>.</p> <pre><code>nebula&gt; INSERT VERTEX date1(p1, p2, p3) VALUES \"test1\":(date(\"2021-03-17\"), time(\"17:53:59\"), datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\"));\n</code></pre> </li> <li> <p>Query whether the value of property <code>p1</code> on the <code>test1</code> tag is <code>2021-03-17</code>.</p> <pre><code>nebula&gt; MATCH (v:date1)  RETURN v.date1.p1 == date(\"2021-03-17\");\n+----------------------------------+\n| (v.date1.p1==date(\"2021-03-17\")) |\n+----------------------------------+\n| true                             |\n+----------------------------------+\n</code></pre> </li> <li> <p>Return the content of the property <code>p1</code> on <code>test1</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS date1_index ON date1(p1);\nnebula&gt; REBUILD TAG INDEX date1_index;\nnebula&gt; MATCH (v:date1) RETURN v.date1.p1;\n+------------------+\n| v.date1.p1.month |\n+------------------+\n| 3                |\n+------------------+\n</code></pre> </li> <li> <p>Search for vertices with <code>p3</code> property values less than <code>2023-01-01T00:00:00.000000</code>, and return the <code>p3</code> values.</p> <pre><code>nebula&gt; MATCH (v:date1)  \\\nWHERE v.date1.p3 &lt; datetime(\"2023-01-01T00:00:00.000000\") \\\nRETURN v.date1.p3;\n+----------------------------+\n| v.date1.p3                 |\n+----------------------------+\n| 2017-03-04T14:30:40.003000 |\n+----------------------------+\n</code></pre> </li> <li> <p>Create a tag named <code>school</code> with the property of <code>TIMESTAMP</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS school(name string , found_time timestamp);\n</code></pre> </li> <li> <p>Insert a vertex named <code>DUT</code> with a found-time timestamp of <code>\"1988-03-01T08:00:00\"</code>.</p> <pre><code># Insert as a timestamp. The corresponding timestamp of 1988-03-01T08:00:00 is 573177600, or 573206400 UTC.\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", 573206400);\n\n# Insert in the form of date and time.\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", timestamp(\"1988-03-01T08:00:00\"));\n</code></pre> </li> <li> <p>Insert a vertex named <code>dut</code> and store time with <code>now()</code> or <code>timestamp()</code> functions.</p> <pre><code># Use now() function to store time\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", now());\n\n# Use timestamp() function to store time\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", timestamp());\n</code></pre> </li> </ol> <p>You can also use <code>WITH</code> statement to set a specific date and time, or to perform calculations. For example:</p> <pre><code>nebula&gt; WITH time({hour: 12, minute: 31, second: 14, millisecond:111, microsecond: 222}) AS d RETURN d;\n+-----------------+\n| d               |\n+-----------------+\n| 12:31:14.111222 |\n+-----------------+\n\nnebula&gt; WITH date({year: 1984, month: 10, day: 11}) AS x RETURN x + 1;\n+------------+\n| (x+1)      |\n+------------+\n| 1984-10-12 |\n+------------+\n\nnebula&gt; WITH date('1984-10-11') as x, duration({years: 12, days: 14, hours: 99, minutes: 12}) as d \\\n        RETURN x + d AS sum, x - d AS diff;\n+------------+------------+\n| sum        | diff       |\n+------------+------------+\n| 1996-10-29 | 1972-09-23 |\n+------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/5.null/","title":"NULL","text":"<p>You can set the properties for vertices or edges to <code>NULL</code>. Also, you can set the <code>NOT NULL</code> constraint to make sure that the property values are <code>NOT NULL</code>. If not specified, the property is set to <code>NULL</code> by default.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#logical_operations_with_null","title":"Logical operations with NULL","text":"<p>Here is the truth table for <code>AND</code>, <code>OR</code>, <code>XOR</code>, and <code>NOT</code>.</p> a b a AND b a OR b a XOR b NOT a false false false false false true false null false null null true false true false true true true true false false true true false true null null true null false true true true true false false null false false null null null null null null null null null null true null true null null"},{"location":"3.ngql-guide/3.data-types/5.null/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>The comparisons and operations about NULL are different from openCypher. There may be changes later.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#comparisons_with_null","title":"Comparisons with NULL","text":"<p>The comparison operations with NULL are incompatible with openCypher.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#operations_and_return_with_null","title":"Operations and RETURN with NULL","text":"<p>The NULL operations and RETURN with NULL are incompatible with openCypher.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/3.data-types/5.null/#use_not_null","title":"Use NOT NULL","text":"<p>Create a tag named <code>player</code>. Specify the property <code>name</code> as <code>NOT NULL</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string NOT NULL, age int);\n</code></pre> <p>Use <code>SHOW</code> to create tag statements. The property <code>name</code> is <code>NOT NULL</code>. The property <code>age</code> is <code>NULL</code> by default.</p> <pre><code>nebula&gt; SHOW CREATE TAG player;\n+-----------+-----------------------------------+\n| Tag       | Create Tag                        |\n+-----------+-----------------------------------+\n| \"student\" | \"CREATE TAG `player` (            |\n|           |  `name` string NOT NULL,          |\n|           |  `age` int64 NULL                 |\n|           | ) ttl_duration = 0, ttl_col = \"\"\" |\n+-----------+-----------------------------------+\n</code></pre> <p>Insert the vertex <code>Kobe</code>. The property <code>age</code> can be <code>NULL</code>.</p> <pre><code>nebula&gt; INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null);\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/5.null/#use_not_null_and_set_the_default","title":"Use NOT NULL and set the default","text":"<p>Create a tag named <code>player</code>. Specify the property <code>age</code> as <code>NOT NULL</code>. The default value is <code>18</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int NOT NULL DEFAULT 18);\n</code></pre> <p>Insert the vertex <code>Kobe</code>. Specify the property <code>name</code> only.</p> <pre><code>nebula&gt; INSERT VERTEX player(name) VALUES \"Kobe\":(\"Kobe\");\n</code></pre> <p>Query the vertex <code>Kobe</code>. The property <code>age</code> is <code>18</code> by default.</p> <pre><code>nebula&gt; FETCH PROP ON player \"Kobe\" YIELD properties(vertex);\n+--------------------------+\n| properties(VERTEX)       |\n+--------------------------+\n| {age: 18, name: \"Kobe\"}  |\n+--------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/6.list/","title":"Lists","text":"<p>The list is a composite data type. A list is a sequence of values. Individual elements in a list can be accessed by their positions.</p> <p>A list starts with a left square bracket <code>[</code> and ends with a right square bracket <code>]</code>. A list contains zero, one, or more expressions. List elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the list, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#list_operations","title":"List operations","text":"<p>You can use the preset list function to operate the list, or use the index to filter the elements in the list.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#index_syntax","title":"Index syntax","text":"<pre><code>[M]\n[M..N]\n[M..]\n[..N]\n</code></pre> <p>The index of nGQL supports queries from front to back, starting from 0. 0 means the first element, 1 means the second element, and so on. It also supports queries from back to front, starting from -1. -1 means the last element, -2 means the penultimate element, and so on.</p> <ul> <li>[M]: represents the element whose index is M.</li> <li>[M..N]: represents the elements whose indexes are <code>greater or equal to M but smaller than N</code>. Return empty when <code>N</code> is 0.</li> <li>[M..]: represents the elements whose indexes are <code>greater or equal to M</code>.</li> <li>[..N]: represents the elements whose indexes are <code>smaller than N</code>. Return empty when <code>N</code> is 0.</li> </ul> <p>Note</p> <ul> <li>Return empty if the index is out of bounds, while return normally if the index is within the bound.</li> <li>Return empty if <code>M</code>\u2265<code>N</code>.</li> <li>When querying a single element, if <code>M</code> is null, return <code>BAD_TYPE</code>. When conducting a range query, if <code>M</code> or <code>N</code> is null, return <code>null</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/6.list/#examples","title":"Examples","text":"<pre><code># The following query returns the list [1,2,3].\nnebula&gt; RETURN list[1, 2, 3] AS a;\n+-----------+\n| a         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns the element whose index is 3 in the list [1,2,3,4,5]. In a list, the index starts from 0, and thus the return element is 4.\nnebula&gt; RETURN range(1,5)[3];\n+---------------+\n| range(1,5)[3] |\n+---------------+\n| 4             |\n+---------------+\n\n# The following query returns the element whose index is -2 in the list [1,2,3,4,5]. The index of the last element in a list is -1, and thus the return element is 4.\nnebula&gt; RETURN range(1,5)[-2];\n+------------------+\n| range(1,5)[-(2)] |\n+------------------+\n| 4                |\n+------------------+\n\n# The following query returns the elements whose indexes are from 0 to 3 (not including 3) in the list [1,2,3,4,5].\nnebula&gt; RETURN range(1,5)[0..3];\n+------------------+\n| range(1,5)[0..3] |\n+------------------+\n| [1, 2, 3]        |\n+------------------+\n\n# The following query returns the elements whose indexes are greater than 2 in the list [1,2,3,4,5].\nnebula&gt; RETURN range(1,5)[3..] AS a;\n+--------+\n| a      |\n+--------+\n| [4, 5] |\n+--------+\n\n# The following query returns the elements whose indexes are smaller than 3.\nnebula&gt; WITH list[1, 2, 3, 4, 5] AS a \\\n        RETURN a[..3] AS r;\n+-----------+\n| r         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query filters the elements whose indexes are greater than 2 in the list [1,2,3,4,5], calculate them respectively, and returns them.\nnebula&gt; RETURN [n IN range(1,5) WHERE n &gt; 2 | n + 10] AS a;\n+--------------+\n| a            |\n+--------------+\n| [13, 14, 15] |\n+--------------+\n\n# The following query returns the elements from the first to the penultimate (inclusive) in the list [1, 2, 3].\nnebula&gt; YIELD list[1, 2, 3][0..-1] AS a;\n+--------+\n| a      |\n+--------+\n| [1, 2] |\n+--------+\n\n# The following query returns the elements from the first (exclusive) to the third backward in the list [1, 2, 3, 4, 5].\nnebula&gt; YIELD list[1, 2, 3, 4, 5][-3..-1] AS a;\n+--------+\n| a      |\n+--------+\n| [3, 4] |\n+--------+\n\n# The following query sets the variables and returns the elements whose indexes are 1 and 2.\nnebula&gt; $var = YIELD 1 AS f, 3 AS t; \\\n        YIELD list[1, 2, 3][$var.f..$var.t] AS a;\n+--------+\n| a      |\n+--------+\n| [2, 3] |\n+--------+\n\n# The following query returns empty because the index is out of bound. It will return normally when the index is within the bound.\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [0..10] AS a;\n+-----------------+\n| a               |\n+-----------------+\n| [1, 2, 3, 4, 5] |\n+-----------------+\n\nnebula&gt; RETURN list[1, 2, 3] [-5..5] AS a;\n+-----------+\n| a         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns empty because there is a [0..0].\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [0..0] AS a;\n+----+\n| a  |\n+----+\n| [] |\n+----+\n\n# The following query returns empty because of M \u2265 N.\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [3..1] AS a;\n+----+\n| a  |\n+----+\n| [] |\n+----+\n\n# When conduct a range query, if `M` or `N` is null, return `null`.\nnebula&gt; WITH list[1,2,3] AS a \\\n        RETURN a[0..null] as r;\n+----------+\n| r        |\n+----------+\n| __NULL__ |\n+----------+\n\n# The following query calculates the elements in the list [1,2,3,4,5] respectively and returns them without the list head.\nnebula&gt; RETURN tail([n IN range(1, 5) | 2 * n - 10]) AS a;\n+-----------------+\n| a               |\n+-----------------+\n| [-6, -4, -2, 0] |\n+-----------------+\n\n# The following query takes the elements in the list [1,2,3] as true and return.\nnebula&gt; RETURN [n IN range(1, 3) WHERE true | n] AS r;\n+-----------+\n| r         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns the length of the list [1,2,3].\nnebula&gt; RETURN size(list[1,2,3]);\n+-------------------+\n| size(list[1,2,3]) |\n+-------------------+\n| 3                 |\n+-------------------+\n\n# The following query calculates the elements in the list [92,90] and runs a conditional judgment in a where clause.\nnebula&gt; GO FROM \"player100\" OVER follow WHERE properties(edge).degree NOT IN [x IN [92, 90] | x + $$.player.age] \\\n        YIELD dst(edge) AS id, properties(edge).degree AS degree;\n+-------------+--------+\n| id          | degree |\n+-------------+--------+\n| \"player101\" | 95     |\n| \"player102\" | 90     |\n+-------------+--------+\n\n# The following query takes the query result of the MATCH statement as the elements in a list. Then it calculates and returns them.\nnebula&gt; MATCH p = (n:player{name:\"Tim Duncan\"})-[:follow]-&gt;(m) \\\n        RETURN [n IN nodes(p) | n.player.age + 100] AS r;\n+------------+\n| r          |\n+------------+\n| [142, 136] |\n| [142, 141] |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/6.list/#opencypher_compatibility_1","title":"OpenCypher compatibility","text":"<ul> <li>In openCypher, return <code>null</code> when querying a single out-of-bound element. However, in nGQL, return <code>OUT_OF_RANGE</code> when querying a single out-of-bound element.<pre><code>nebula&gt; RETURN range(0,5)[-12];\n+-------------------+\n| range(0,5)[-(12)] |\n+-------------------+\n| OUT_OF_RANGE      |\n+-------------------+\n</code></pre> </li> </ul> <ul> <li> <p>A composite data type (i.e., set, map, and list) CAN NOT be stored as properties for vertices or edges.</p> <p>It is recommended to modify the graph modeling method. The composite data type should be modeled as an adjacent edge of a vertex, rather than its property. Each adjacent edge can be dynamically added or deleted. The rank values of the adjacent edges can be used for sequencing.</p> </li> </ul> <ul> <li>Patterns are not supported in the list. For example, <code>[(src)-[]-&gt;(m) | m.name]</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/7.set/","title":"Sets","text":"<p>The set is a composite data type. A set is a set of values. Unlike a List, values in a set are unordered and each value must be unique.</p> <p>A set starts with a left curly bracket <code>{</code> and ends with a right curly bracket <code>}</code>. A set contains zero, one, or more expressions. Set elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the set, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/7.set/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</li> </ul> <ul> <li>A set is not a data type in openCypher, but in nGQL, users can use the set.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/7.set/#examples","title":"Examples","text":"<pre><code># The following query returns the set {1,2,3}.\nnebula&gt; RETURN set{1, 2, 3} AS a;\n+-----------+\n| a         |\n+-----------+\n| {3, 2, 1} |\n+-----------+\n\n# The following query returns the set {1,2}, Because the set does not allow repeating elements, and the order is unordered.\nnebula&gt; RETURN set{1, 2, 1} AS a;\n+--------+\n| a      |\n+--------+\n| {2, 1} |\n+--------+\n\n# The following query checks whether the set has the specified element 1.\nnebula&gt; RETURN 1 IN set{1, 2} AS a;\n+------+\n| a    |\n+------+\n| true |\n+------+\n\n# The following query counts the number of elements in the set.\nnebula&gt; YIELD size(set{1, 2, 1}) AS a;\n+---+\n| a |\n+---+\n| 2 |\n+---+\n\n# The following query returns a set of target vertex property values.\nnebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD set{properties($$).name,properties($$).age} as a;\n+-----------------------+\n| a                     |\n+-----------------------+\n| {36, \"Tony Parker\"}   |\n| {41, \"Manu Ginobili\"} |\n+-----------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/8.map/","title":"Maps","text":"<p>The map is a composite data type. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using <code>map['key']</code>.</p> <p>A map starts with a left curly bracket <code>{</code> and ends with a right curly bracket <code>}</code>. A map contains zero, one, or more key-value pairs. Map elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the map, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/8.map/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</li> </ul> <ul> <li>Map projection is not supported.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/8.map/#examples","title":"Examples","text":"<pre><code># The following query returns the simple map.\nnebula&gt; YIELD map{key1: 'Value1', Key2: 'Value2'} as a;\n+----------------------------------+\n| a                                |\n+----------------------------------+\n| {Key2: \"Value2\", key1: \"Value1\"} |\n+----------------------------------+\n\n# The following query returns the list type map.\nnebula&gt; YIELD map{listKey: [{inner: 'Map1'}, {inner: 'Map2'}]} as a;\n+-----------------------------------------------+\n| a                                             |\n+-----------------------------------------------+\n| {listKey: [{inner: \"Map1\"}, {inner: \"Map2\"}]} |\n+-----------------------------------------------+\n\n# The following query returns the hybrid type map.\nnebula&gt; RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"} as a;\n+----------------------------------+\n| a                                |\n+----------------------------------+\n| {a: [1, 2], b: {2, 1}, c: \"hee\"} |\n+----------------------------------+\n\n# The following query returns the specified element in a map.\nnebula&gt; RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"}[\"b\"] AS b;\n+--------+\n| b      |\n+--------+\n| {2, 1} |\n+--------+\n\n# The following query checks whether the map has the specified key, not support checks whether the map has the specified value yet.\nnebula&gt; RETURN \"a\" IN MAP{a:1, b:2} AS a;\n+------+\n| a    |\n+------+\n| true |\n+------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/","title":"Type Conversion/Type coercions","text":"<p>Converting an expression of a given type to another type is known as type conversion.</p> <p>NebulaGraph supports converting expressions explicit to other types. For details, see Type conversion functions.</p>"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/#examples","title":"Examples","text":"<pre><code>nebula&gt; UNWIND [true, false, 'true', 'false', NULL] AS b \\\n        RETURN toBoolean(b) AS b;\n+----------+\n| b        |\n+----------+\n| true     |\n| false    |\n| true     |\n| false    |\n| __NULL__ |\n+----------+\n\nnebula&gt; RETURN toFloat(1), toFloat('1.3'), toFloat('1e3'), toFloat('not a number');\n+------------+----------------+----------------+-------------------------+\n| toFloat(1) | toFloat(\"1.3\") | toFloat(\"1e3\") | toFloat(\"not a number\") |\n+------------+----------------+----------------+-------------------------+\n| 1.0        | 1.3            | 1000.0         | __NULL__                |\n+------------+----------------+----------------+-------------------------+\n</code></pre>"},{"location":"nebula-dashboard/1.what-is-dashboard/","title":"What is NebulaGraph Dashboard Community Edition","text":"<p>NebulaGraph Dashboard Community Edition (Dashboard for short) is a visualization tool that monitors the status of machines and services in NebulaGraph clusters.</p> <p>Enterpriseonly</p> <p>Dashboard Enterprise Edition adds features such as visual cluster creation, batch import of clusters, fast scaling, etc. For more information, see Pricing.</p>"},{"location":"nebula-dashboard/1.what-is-dashboard/#features","title":"Features","text":"<p>Dashboard monitors:</p> <ul> <li>The status of all the machines in clusters, including CPU, memory, load, disk, and network.</li> </ul> <ul> <li>The information of all the services in clusters, including the IP addresses, versions, and monitoring metrics (such as the number of queries, the latency of queries, the latency of heartbeats, and so on).</li> </ul> <ul> <li>The information of clusters, including the information of services, partitions, configurations, and long-term tasks.</li> </ul> <ul> <li>Set how often the metrics page refreshes.</li> </ul>"},{"location":"nebula-dashboard/1.what-is-dashboard/#scenarios","title":"Scenarios","text":"<p>You can use Dashboard in one of the following scenarios:</p> <ul> <li>You want to monitor key metrics conveniently and quickly, and present multiple key information of the business to ensure the business operates normally.</li> </ul> <ul> <li>You want to monitor clusters from multiple dimensions (such as the time, aggregate rules, and metrics).</li> </ul> <ul> <li>After a failure occurs, you need to review it and confirm its occurrence time and unexpected phenomena.</li> </ul>"},{"location":"nebula-dashboard/1.what-is-dashboard/#precautions","title":"Precautions","text":"<p>The monitoring data will be retained for 14 days by default, that is, only the monitoring data within the last 14 days can be queried.</p> <p>Note</p> <p>The monitoring service is supported by Prometheus. The update frequency and retention intervals can be modified. For details, see Prometheus.</p>"},{"location":"nebula-dashboard/1.what-is-dashboard/#version_compatibility","title":"Version compatibility","text":"<p>The version correspondence between NebulaGraph and Dashboard Community Edition is as follows.</p> NebulaGraph version Dashboard version 3.5.0 3.4.0 3.4.0 ~ 3.4.1 3.4.0\u30013.2.0 3.3.0 3.2.0 2.5.0 ~ 3.2.0 3.1.0 2.5.x ~ 3.1.0 1.1.1 2.0.1~2.5.1 1.0.2 2.0.1~2.5.1 1.0.1"},{"location":"nebula-dashboard/1.what-is-dashboard/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/","title":"Deploy Dashboard Community Edition","text":"<p>This topic will describe how to deploy NebulaGraph Dashboard in detail.</p> <p>To download and compile the latest source code of Dashboard, follow the instructions on the nebula dashboard GitHub page.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#prerequisites","title":"Prerequisites","text":"<p>Before you deploy Dashboard, you must confirm that:</p> <ul> <li>The NebulaGraph services are deployed and started. For more information, see NebulaGraph Database Manual.</li> </ul> <ul> <li> <p>Before the installation starts, the following ports are not occupied.</p> <ul> <li>9200</li> </ul> <ul> <li>9100</li> </ul> <ul> <li>9090</li> </ul> <ul> <li>8090</li> </ul> <ul> <li>7003</li> </ul> </li> </ul> <ul> <li>The node-exporter is installed on the machines to be monitored. For details on installation, see Prometheus document.</li> </ul>"},{"location":"nebula-dashboard/2.deploy-dashboard/#steps","title":"Steps","text":"<ol> <li> <p>Download the tar packagenebula-dashboard-3.4.0.x86_64.tar.gz  as needed.</p> </li> <li> <p>Run <code>tar -xvf nebula-dashboard-3.4.0.x86_64.tar.gz</code> to decompress the installation package.</p> </li> <li> <p>Modify the <code>config.yaml</code> file in <code>nebula-dashboard</code>.</p> <p>The configuration file contains the configurations of four dependent services and configurations of clusters. The descriptions of the dependent services are as follows.</p> Service Default port Description nebula-http-gateway 8090 Provides HTTP ports for cluster services to execute nGQL statements to interact with the NebulaGraph database. nebula-stats-exporter 9200 Collects the performance metrics in the cluster, including the IP addresses, versions, and monitoring metrics (such as the number of queries, the latency of queries, the latency of heartbeats, and so on). node-exporter 9100 Collects the source information of nodes in the cluster, including the CPU, memory, load, disk, and network. prometheus 9090 The time series database that stores monitoring data. <p>The descriptions of the configuration file are as follows.</p> <pre><code>port: 7003   # Web service port.\ngateway:\n  ip: hostIP   # The IP of the machine where the Dashboard is deployed.\n  port: 8090\n  https: false  # Whether to enable HTTPS.\n  runmode: dev  # Program running mode, including dev, test, and prod. It is used to distinguish between different running environments generally.\nstats-exporter:\n  ip: hostIP   # The IP of the machine where the Dashboard is deployed.\n  nebulaPort: 9200\n  https: false  # Whether to enable HTTPS.\nnode-exporter:\n  - ip: nebulaHostIP_1 # The IP of the machine where the NebulaGraph is deployed.\n    port: 9100\n    https: false # Whether to enable HTTPS.\n# - ip: nebulaHostIP_2\n#   port: 9100\n#   https: false\nprometheus:\n  ip: hostIP    # The IP of the machine where the Dashboard is deployed.\n  prometheusPort: 9090\n  https: false  # Whether to enable HTTPS.\n  scrape_interval: 5s  # The interval for collecting the monitoring data, which is 1 minute by default.\n  evaluation_interval: 5s  # The interval for running alert rules, which is 1 minute by default.\n# Cluster node info\nnebula-cluster:\n  name: 'default' # Cluster name\n  metad:\n    - name: metad0\n      endpointIP: nebulaMetadIP  # The IP of the machine where the Meta service is deployed.\n      port: 9559\n      endpointPort: 19559\n  # - name: metad1\n  #   endpointIP: nebulaMetadIP\n  #   port: 9559\n  #   endpointPort: 19559  \n  graphd:\n    - name: graphd0\n      endpointIP: nebulaGraphdIP  # The IP of the machine where the Graph service is deployed.\n      port: 9669\n      endpointPort: 19669\n  # - name: graphd1\n  #   endpointIP: nebulaGraphdIP\n  #   port: 9669\n  #   endpointPort: 19669  \n  storaged:\n    - name: storaged0\n      endpointIP: nebulaStoragedIP  # The IP of the machine where the Storage service is deployed.\n      port: 9779\n      endpointPort: 19779\n  # - name: storaged1\n  #   endpointIP: nebulaStoragedIP\n  #   port: 9779\n  #   endpointPort: 19779  \n</code></pre> </li> <li> <p>Run <code>./dashboard.service start all</code> to start the services.</p> </li> </ol>"},{"location":"nebula-dashboard/2.deploy-dashboard/#deploy_dashboard_with_docker_compose","title":"Deploy Dashboard with Docker Compose","text":"<p>If you are deploying Dashboard using docker, you should also modify the configuration file <code>config.yaml</code>, and then run <code>docker-compose up -d</code> to start the container.</p> <p>Note</p> <p>If you change the port number in <code>config.yaml</code>, the port number in <code>docker-compose.yaml</code> needs to be consistent as well.</p> <p>Run <code>docker-compose stop</code> to stop the container.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#manage_services_in_dashboard","title":"Manage services in Dashboard","text":"<p>You can use the <code>dashboard.service</code> script to start, restart, stop, and check the Dashboard services.</p> <pre><code>sudo &lt;dashboard_path&gt;/dashboard.service\n[-v] [-h]\n&lt;start|restart|stop|status&gt;  &lt;prometheus|webserver|exporter|gateway|all&gt;\n</code></pre> Parameter Description <code>dashboard_path</code> Dashboard installation path. <code>-v</code> Display detailed debugging information. <code>-h</code> Display help information. <code>start</code> Start the target services. <code>restart</code> Restart the target services. <code>stop</code> Stop the target services. <code>status</code> Check the status of the target services. <code>prometheus</code> Set the prometheus service as the target service. <code>webserver</code> Set the webserver Service as the target service. <code>exporter</code> Set the exporter Service as the target service. <code>gateway</code> Set the gateway Service as the target service. <code>all</code> Set all the Dashboard services as the target services. <p>Note</p> <p>To view the Dashboard version, run the command <code>./dashboard.service -version</code>.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#next_to_do","title":"Next to do","text":"<p>Connect to Dashboard</p>"},{"location":"nebula-dashboard/3.connect-dashboard/","title":"Connect Dashboard","text":"<p>After Dashboard is deployed, you can log in and use Dashboard on the browser.</p>"},{"location":"nebula-dashboard/3.connect-dashboard/#prerequisites","title":"Prerequisites","text":"<ul> <li>The Dashboard services are started. For more information, see Deploy Dashboard.</li> </ul> <ul> <li>We recommend you to use the Chrome browser of the version above 89. Otherwise, there may be compatibility issues.</li> </ul>"},{"location":"nebula-dashboard/3.connect-dashboard/#procedures","title":"Procedures","text":"<ol> <li> <p>Confirm the IP address of the machine where the Dashboard service is installed. Enter <code>&lt;IP&gt;:7003</code> in the browser to open the login page.</p> </li> <li> <p>Enter the username and the passwords of the NebulaGraph database.</p> <ul> <li>If authentication is enabled, you can log in with the created accounts.</li> </ul> <ul> <li>If authentication is not enabled, you can only log in using <code>root</code> as the username and random characters as the password.</li> </ul> <p>To enable authentication, see Authentication.</p> </li> <li> <p>Select the NebulaGraph version to be used.</p> </li> <li> <p>Click Login.</p> </li> </ol>"},{"location":"nebula-dashboard/4.use-dashboard/","title":"Dashboard","text":"<p>NebulaGraph Dashboard consists of three parts: Machine, Service, and Management. This topic will describe them in detail.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#overview","title":"Overview","text":""},{"location":"nebula-dashboard/4.use-dashboard/#machine","title":"Machine","text":"<p>Click Machine-&gt;Overview to enter the machine overview page.</p> <p>On this page, you can view the variation of CPU, Memory, Load, Disk, and Network In/Out quickly.</p> <ul> <li>By default, you can view the monitoring data for a maximum of 14 days. You can also select a time range or quickly select the latest 1 hour, 6 hours, 12 hours, 1 day, 3 days, 7 days, or 14 days.</li> <li>By default, you can view the monitoring data of all the instances in clusters. You can select the instances you want to view in the instance box.</li> <li>By default, the monitoring information page will not be updated automatically. You can set the update frequency of the monitoring information page globally or click the  button to update the page manually.</li> <li>To set a base line, click the  button.</li> <li> <p>To view the detailed monitoring information, click the  button. In this example, select <code>Load</code> for details. The figure is as follows.</p> <p></p> <ul> <li>You can set the monitoring time range, instance, update frequency and base line.</li> <li>You can search for or select the target metric. For details about monitoring metrics, see Metrics.</li> <li>You can temporarily hide nodes that you do not need to view.</li> <li>You can click the  button to view the detailed monitoring information.</li> </ul> </li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#service","title":"Service","text":"<p>Click Service-&gt;Overview to enter the service overview page.</p> <p>On this page, you can view the information of Graph, Meta, and Storage services quickly. In the upper right corner, the number of normal services and abnormal services will be displayed.</p> <p>Note</p> <p>In the  Service page, only two monitoring metrics can be set for each service, which can be adjusted by clicking the Set up button.</p> <ul> <li>By default, you can view the monitoring data for a maximum of 14 days. You can also select a time range or quickly select the latest 1 hour, 6 hours, 12 hours, 1 day, 3 days, 7 days, or 14 days.</li> <li>By default, you can view the monitoring data of all the instances in clusters. You can select the instances you want to view in the instance box.</li> <li>By default, the monitoring information page will not be updated automatically. You can set the update frequency of the monitoring information page globally or click the  button to update the page manually.</li> <li>You can view the status of all the services in a cluster.</li> <li> <p>To view the detailed monitoring information, click the  button. In this example, select <code>Graph</code> for details. The figure is as follows.</p> <p></p> <ul> <li>You can set the monitoring time range, instance, update frequency, period, aggregation and base line.</li> <li>You can search for or select the target metric. For details of monitoring metrics, see Monitor parameter.</li> <li>You can temporarily hide nodes that you do not need to view.</li> <li>You can click the  button to view the detailed monitoring information.</li> <li>The Graph service supports a set of space-level metrics. For more information, see the following section Graph space.</li> </ul> </li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Before using graph space metrics, you need to set <code>enable_space_level_metrics</code> to <code>true</code> in the Graph service. For details, see [Graph Service configuration](../5.configurations-and-logs/1.configurations/3.graph-config.md.</p> <p>Space-level metric incompatibility</p> <p>If a graph space name contains special characters, the corresponding metric data of that graph space may not be displayed. </p> <p>The service monitoring page can also monitor graph space level metrics. Only when the behavior of a graph space metric is triggered, you can specify the graph space to view information about the corresponding graph space metric.</p> <p>Space graph metrics record the information of different graph spaces separately. Currently, only the Graph service supports a set of space-level metrics.</p> <p>For information about the space graph metrics, see Graph space.</p> <p></p>"},{"location":"nebula-dashboard/4.use-dashboard/#management","title":"Management","text":""},{"location":"nebula-dashboard/4.use-dashboard/#overview_info","title":"Overview info","text":"<p>On the Overview Info page, you can see the information of the NebulaGraph cluster, including Storage leader distribution, Storage service details, versions and hosts information of each NebulaGraph service, and partition distribution and details.</p> <p></p>"},{"location":"nebula-dashboard/4.use-dashboard/#storage_leader_distribution","title":"Storage Leader Distribution","text":"<p>In this section, the number of Leaders and the Leader distribution will be shown.</p> <ul> <li>Click the Balance Leader button in the upper right corner to distribute Leaders evenly and quickly in the NebulaGraph cluster. For details about the Leader, see Storage Service.</li> </ul> <ul> <li>Click Detail in the upper right corner to view the details of the Leader distribution.</li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#version","title":"Version","text":"<p>In this section, the version and host information of each NebulaGraph service will be shown. Click Detail in the upper right corner to view the details of the version and host information.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#service_information","title":"Service information","text":"<p>In this section, the information on Storage services will be shown. The parameter description is as follows:</p> Parameter Description <code>Host</code> The IP address of the host. <code>Port</code> The port of the host. <code>Status</code> The host status. <code>Git Info Sha</code> The commit ID of the current version. <code>Leader Count</code> The number of Leaders. <code>Partition Distribution</code> The distribution of partitions. <code>Leader Distribution</code> The distribution of Leaders. <p>Click Detail in the upper right corner to view the details of the Storage service information.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#partition_distribution","title":"Partition Distribution","text":"<p>Select the specified graph space in the upper left corner, you can view the distribution of partitions in the specified graph space. You can see the IP addresses and ports of all Storage services in the cluster, and the number of partitions in each Storage service.</p> <p>Click Detail in the upper right corner to view more details.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#partition_information","title":"Partition information","text":"<p>In this section, the information on partitions will be shown. Before viewing the partition information, you need to select a graph space in the upper left corner. The parameter description is as follows:</p> Parameter Description <code>Partition ID</code> The ID of the partition. <code>Leader</code> The IP address and port of the leader. <code>Peers</code> The IP addresses and ports of all the replicas. <code>Losts</code> The IP addresses and ports of faulty replicas. <p>Click Detail in the upper right corner to view details. You can also enter the partition ID into the input box in the upper right corner of the details page to filter the shown data. </p>"},{"location":"nebula-dashboard/4.use-dashboard/#config","title":"Config","text":"<p>It shows the configuration of the NebulaGraph service. NebulaGraph Dashboard Community Edition does not support online modification of configurations for now.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#others","title":"Others","text":"<p>In the lower left corner of the page, you can:</p> <ul> <li>Sign out</li> </ul> <ul> <li>Switch between Chinese and English</li> </ul> <ul> <li>View the current Dashboard release</li> </ul> <ul> <li>View the user manual and forum</li> </ul> <ul> <li>Fold the sidebar</li> </ul>"},{"location":"nebula-dashboard/6.monitor-parameter/","title":"Metrics","text":"<p>This topic will describe the monitoring metrics in NebulaGraph Dashboard.</p>"},{"location":"nebula-dashboard/6.monitor-parameter/#machine","title":"Machine","text":"<p>Note</p> <ul> <li>All the machine metrics listed below are for the Linux operating system.</li> <li>The default unit in Disk and Network is byte. The unit will change with the data magnitude as the page displays. For example, when the flow is less than 1 KB/s, the unit will be Bytes/s.</li> <li>For versions of Dashboard Community Edition greater than v1.0.2, the memory occupied by Buff and Cache will not be counted in the memory usage.</li> </ul>"},{"location":"nebula-dashboard/6.monitor-parameter/#cpu","title":"CPU","text":"Parameter Description <code>cpu_utilization</code> The percentage of used CPU. <code>cpu_idle</code> The percentage of idled CPU. <code>cpu_wait</code> The percentage of CPU waiting for IO operations. <code>cpu_user</code> The percentage of CPU used by users. <code>cpu_system</code> The percentage of CPU used by the system."},{"location":"nebula-dashboard/6.monitor-parameter/#memory","title":"Memory","text":"Parameter Description <code>memory_utilization</code> The percentage of used memory. <code>memory_used</code> The memory space used (not including caches). <code>memory_free</code> The memory space available."},{"location":"nebula-dashboard/6.monitor-parameter/#load","title":"Load","text":"Parameter Description <code>load_1m</code> The average load of the system in the last 1 minute. <code>load_5m</code> The average load of the system in the last 5 minutes. <code>load_15m</code> The average load of the system in the last 15 minutes."},{"location":"nebula-dashboard/6.monitor-parameter/#disk","title":"Disk","text":"Parameter Description <code>disk_used_percentage</code> The disk utilization percentage. <code>disk_used</code> The disk space used. <code>disk_free</code> The disk space available. <code>disk_readbytes</code> The number of bytes that the system reads in the disk per second. <code>disk_writebytes</code> The number of bytes that the system writes in the disk per second. <code>disk_readiops</code> The number of read queries that the disk receives per second. <code>disk_writeiops</code> The number of write queries that the disk receives per second. <code>inode_utilization</code> The percentage of used inode."},{"location":"nebula-dashboard/6.monitor-parameter/#network","title":"Network","text":"Parameter Description <code>network_in_rate</code> The number of bytes that the network card receives per second. <code>network_out_rate</code> The number of bytes that the network card sends out per second. <code>network_in_errs</code> The number of wrong bytes that the network card receives per second. <code>network_out_errs</code> The number of wrong bytes that the network card sends out per second. <code>network_in_packets</code> The number of data packages that the network card receives per second. <code>network_out_packets</code> The number of data packages that the network card sends out per second."},{"location":"nebula-dashboard/6.monitor-parameter/#service","title":"Service","text":""},{"location":"nebula-dashboard/6.monitor-parameter/#period","title":"Period","text":"<p>The period is the time range of counting metrics. It currently supports 5 seconds, 60 seconds, 600 seconds, and 3600 seconds, which respectively represent the last 5 seconds, the last 1 minute, the last 10 minutes, and the last 1 hour.</p>"},{"location":"nebula-dashboard/6.monitor-parameter/#metric_methods","title":"Metric methods","text":"Parameter Description <code>rate</code> The average rate of operations per second in a period. <code>sum</code> The sum of operations in the period. <code>avg</code> The average latency in the cycle. <code>P75</code> The 75th percentile latency. <code>P95</code> The 95th percentile latency. <code>P99</code> The 99th percentile latency. <code>P999</code> The 99.9th percentile latency. <p>Note</p> <p>Dashboard collects the following metrics from the NebulaGraph core, but only shows the metrics that are important to it. </p>"},{"location":"nebula-dashboard/6.monitor-parameter/#graph","title":"Graph","text":"Parameter Description <code>num_active_queries</code> The number of changes in the number of active queries. Formula: The number of started queries minus the number of finished queries within a specified time. <code>num_active_sessions</code> The number of changes in the number of active sessions. Formula: The number of logged in sessions minus the number of logged out sessions within a specified time.For example, when querying <code>num_active_sessions.sum.5</code>, if there were 10 sessions logged in and 30 sessions logged out in the last 5 seconds, the value of this metric is <code>-20</code> (10-30). <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions_out_of_max_allowed</code> The number of sessions that failed to authenticate logins because the value of the parameter <code>FLAG_OUT_OF_MAX_ALLOWED_CONNECTIONS</code> was exceeded. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_killed_queries</code> The number of killed queries. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries</code> The number of queries. <code>num_query_errors_leader_changes</code> The number of the raft leader changes due to query errors. <code>num_query_errors</code> The number of query errors. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>num_sentences</code> The number of statements received by the Graphd service. <code>num_slow_queries</code> The number of slow queries. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>slow_query_latency_us</code> The latency of slow queries. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>resp_part_completeness</code> The completeness of the partial success. You need to set <code>accept_partial_success</code> to <code>true</code> in the graph configuration first."},{"location":"nebula-dashboard/6.monitor-parameter/#meta","title":"Meta","text":"Parameter Description <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>heartbeat_latency_us</code> The latency of heartbeats. <code>num_heartbeats</code> The number of heartbeats. <code>num_raft_votes</code> The number of votes in Raft. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>num_agent_heartbeats</code> The number of heartbeats for the AgentHBProcessor. <code>agent_heartbeat_latency_us</code> The latency of the AgentHBProcessor. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_send_snapshot</code> The number of times that Raft sends snapshots to other nodes. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>num_start_elect</code> The number of times that Raft starts an election."},{"location":"nebula-dashboard/6.monitor-parameter/#storage","title":"Storage","text":"Parameter Description <code>add_edges_latency_us</code> The latency of adding edges. <code>add_vertices_latency_us</code> The latency of adding vertices. <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>delete_edges_latency_us</code> The latency of deleting edges. <code>delete_vertices_latency_us</code> The latency of deleting vertices. <code>get_neighbors_latency_us</code> The latency of querying neighbor vertices. <code>get_dst_by_src_latency_us</code> The latency of querying the destination vertex by the source vertex. <code>num_get_prop</code> The number of executions for the GetPropProcessor. <code>num_get_neighbors_errors</code> The number of execution errors for the GetNeighborsProcessor. <code>num_get_dst_by_src_errors</code> The number of execution errors for the GetDstBySrcProcessor. <code>get_prop_latency_us</code> The latency of executions for the GetPropProcessor. <code>num_edges_deleted</code> The number of deleted edges. <code>num_edges_inserted</code> The number of inserted edges. <code>num_raft_votes</code> The number of votes in Raft. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Storage service sent to the Meta service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Storaged service sent to the Metad service. <code>num_tags_deleted</code> The number of deleted tags. <code>num_vertices_deleted</code> The number of deleted vertices. <code>num_vertices_inserted</code> The number of inserted vertices. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>lookup_latency_us</code> The latency of executions for the LookupProcessor. <code>num_lookup_errors</code> The number of execution errors for the LookupProcessor. <code>num_scan_vertex</code> The number of executions for the ScanVertexProcessor. <code>num_scan_vertex_errors</code> The number of execution errors for the ScanVertexProcessor. <code>update_edge_latency_us</code> The latency of executions for the UpdateEdgeProcessor. <code>num_update_vertex</code> The number of executions for the UpdateVertexProcessor. <code>num_update_vertex_errors</code> The number of execution errors for the UpdateVertexProcessor. <code>kv_get_latency_us</code> The latency of executions for the Getprocessor. <code>kv_put_latency_us</code> The latency of executions for the PutProcessor. <code>kv_remove_latency_us</code> The latency of executions for the RemoveProcessor. <code>num_kv_get_errors</code> The number of execution errors for the GetProcessor. <code>num_kv_get</code> The number of executions for the GetProcessor. <code>num_kv_put_errors</code> The number of execution errors for the PutProcessor. <code>num_kv_put</code> The number of executions for the PutProcessor. <code>num_kv_remove_errors</code> The number of execution errors for the RemoveProcessor. <code>num_kv_remove</code> The number of executions for the RemoveProcessor. <code>forward_tranx_latency_us</code> The latency of transmission. <code>scan_edge_latency_us</code> The latency of executions for the ScanEdgeProcessor. <code>num_scan_edge_errors</code> The number of execution errors for the ScanEdgeProcessor. <code>num_scan_edge</code> The number of executions for the ScanEdgeProcessor. <code>scan_vertex_latency_us</code> The latency of executions for the ScanVertexProcessor. <code>num_add_edges</code> The number of times that edges are added. <code>num_add_edges_errors</code> The number of errors when adding edges. <code>num_add_vertices</code> The number of times that vertices are added. <code>num_start_elect</code> The number of times that Raft starts an election. <code>num_add_vertices_errors</code> The number of errors when adding vertices. <code>num_delete_vertices_errors</code> The number of errors when deleting vertices. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_delete_tags</code> The number of times that tags are deleted. <code>num_delete_tags_errors</code> The number of errors when deleting tags. <code>num_delete_edges</code> The number of edge deletions. <code>num_delete_edges_errors</code> The number of errors when deleting edges <code>num_send_snapshot</code> The number of times that snapshots are sent. <code>update_vertex_latency_us</code> The latency of executions for the UpdateVertexProcessor. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_update_edge</code> The number of executions for the UpdateEdgeProcessor. <code>delete_tags_latency_us</code> The latency of deleting tags. <code>num_update_edge_errors</code> The number of execution errors for the UpdateEdgeProcessor. <code>num_get_neighbors</code> The number of executions for the GetNeighborsProcessor. <code>num_get_dst_by_src</code> The number of executions for the GetDstBySrcProcessor. <code>num_get_prop_errors</code> The number of execution errors for the GetPropProcessor. <code>num_delete_vertices</code> The number of times that vertices are deleted. <code>num_lookup</code> The number of executions for the LookupProcessor. <code>num_sync_data</code> The number of times the Storage service synchronizes data from the Drainer. <code>num_sync_data_errors</code> The number of errors that occur when the Storage service synchronizes data from the Drainer. <code>sync_data_latency_us</code> The latency of the Storage service synchronizing data from the Drainer."},{"location":"nebula-dashboard/6.monitor-parameter/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Space-level metrics are created dynamically, so that only when the behavior is triggered in the graph space, the corresponding metric is created and can be queried by the user.</p> Parameter Description <code>num_active_queries</code> The number of queries currently being executed. <code>num_queries</code> The number of queries. <code>num_sentences</code> The number of statements received by the Graphd service. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>num_slow_queries</code> The number of slow queries. <code>num_query_errors</code> The number of query errors. <code>num_query_errors_leader_changes</code> The number of raft leader changes due to query errors. <code>num_killed_queries</code> The number of killed queries. <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>slow_query_latency_us</code> The latency of slow queries."},{"location":"reuse/source-monitoring-metrics/","title":"Source monitoring metrics","text":""},{"location":"reuse/source-monitoring-metrics/#graph","title":"Graph","text":"Parameter Description <code>num_active_queries</code> The number of changes in the number of active queries. Formula: The number of started queries minus the number of finished queries within a specified time. <code>num_active_sessions</code> The number of changes in the number of active sessions. Formula: The number of logged in sessions minus the number of logged out sessions within a specified time.For example, when querying <code>num_active_sessions.sum.5</code>, if there were 10 sessions logged in and 30 sessions logged out in the last 5 seconds, the value of this metric is <code>-20</code> (10-30). <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions_out_of_max_allowed</code> The number of sessions that failed to authenticate logins because the value of the parameter <code>FLAG_OUT_OF_MAX_ALLOWED_CONNECTIONS</code> was exceeded. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_killed_queries</code> The number of killed queries. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries</code> The number of queries. <code>num_query_errors_leader_changes</code> The number of the raft leader changes due to query errors. <code>num_query_errors</code> The number of query errors. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>num_sentences</code> The number of statements received by the Graphd service. <code>num_slow_queries</code> The number of slow queries. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>slow_query_latency_us</code> The latency of slow queries. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>resp_part_completeness</code> The completeness of the partial success. You need to set <code>accept_partial_success</code> to <code>true</code> in the graph configuration first."},{"location":"reuse/source-monitoring-metrics/#meta","title":"Meta","text":"Parameter Description <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>heartbeat_latency_us</code> The latency of heartbeats. <code>num_heartbeats</code> The number of heartbeats. <code>num_raft_votes</code> The number of votes in Raft. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>num_agent_heartbeats</code> The number of heartbeats for the AgentHBProcessor. <code>agent_heartbeat_latency_us</code> The latency of the AgentHBProcessor. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_send_snapshot</code> The number of times that Raft sends snapshots to other nodes. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>num_start_elect</code> The number of times that Raft starts an election."},{"location":"reuse/source-monitoring-metrics/#storage","title":"Storage","text":"Parameter Description <code>add_edges_latency_us</code> The latency of adding edges. <code>add_vertices_latency_us</code> The latency of adding vertices. <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>delete_edges_latency_us</code> The latency of deleting edges. <code>delete_vertices_latency_us</code> The latency of deleting vertices. <code>get_neighbors_latency_us</code> The latency of querying neighbor vertices. <code>get_dst_by_src_latency_us</code> The latency of querying the destination vertex by the source vertex. <code>num_get_prop</code> The number of executions for the GetPropProcessor. <code>num_get_neighbors_errors</code> The number of execution errors for the GetNeighborsProcessor. <code>num_get_dst_by_src_errors</code> The number of execution errors for the GetDstBySrcProcessor. <code>get_prop_latency_us</code> The latency of executions for the GetPropProcessor. <code>num_edges_deleted</code> The number of deleted edges. <code>num_edges_inserted</code> The number of inserted edges. <code>num_raft_votes</code> The number of votes in Raft. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Storage service sent to the Meta service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Storaged service sent to the Metad service. <code>num_tags_deleted</code> The number of deleted tags. <code>num_vertices_deleted</code> The number of deleted vertices. <code>num_vertices_inserted</code> The number of inserted vertices. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>lookup_latency_us</code> The latency of executions for the LookupProcessor. <code>num_lookup_errors</code> The number of execution errors for the LookupProcessor. <code>num_scan_vertex</code> The number of executions for the ScanVertexProcessor. <code>num_scan_vertex_errors</code> The number of execution errors for the ScanVertexProcessor. <code>update_edge_latency_us</code> The latency of executions for the UpdateEdgeProcessor. <code>num_update_vertex</code> The number of executions for the UpdateVertexProcessor. <code>num_update_vertex_errors</code> The number of execution errors for the UpdateVertexProcessor. <code>kv_get_latency_us</code> The latency of executions for the Getprocessor. <code>kv_put_latency_us</code> The latency of executions for the PutProcessor. <code>kv_remove_latency_us</code> The latency of executions for the RemoveProcessor. <code>num_kv_get_errors</code> The number of execution errors for the GetProcessor. <code>num_kv_get</code> The number of executions for the GetProcessor. <code>num_kv_put_errors</code> The number of execution errors for the PutProcessor. <code>num_kv_put</code> The number of executions for the PutProcessor. <code>num_kv_remove_errors</code> The number of execution errors for the RemoveProcessor. <code>num_kv_remove</code> The number of executions for the RemoveProcessor. <code>forward_tranx_latency_us</code> The latency of transmission. <code>scan_edge_latency_us</code> The latency of executions for the ScanEdgeProcessor. <code>num_scan_edge_errors</code> The number of execution errors for the ScanEdgeProcessor. <code>num_scan_edge</code> The number of executions for the ScanEdgeProcessor. <code>scan_vertex_latency_us</code> The latency of executions for the ScanVertexProcessor. <code>num_add_edges</code> The number of times that edges are added. <code>num_add_edges_errors</code> The number of errors when adding edges. <code>num_add_vertices</code> The number of times that vertices are added. <code>num_start_elect</code> The number of times that Raft starts an election. <code>num_add_vertices_errors</code> The number of errors when adding vertices. <code>num_delete_vertices_errors</code> The number of errors when deleting vertices. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_delete_tags</code> The number of times that tags are deleted. <code>num_delete_tags_errors</code> The number of errors when deleting tags. <code>num_delete_edges</code> The number of edge deletions. <code>num_delete_edges_errors</code> The number of errors when deleting edges <code>num_send_snapshot</code> The number of times that snapshots are sent. <code>update_vertex_latency_us</code> The latency of executions for the UpdateVertexProcessor. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_update_edge</code> The number of executions for the UpdateEdgeProcessor. <code>delete_tags_latency_us</code> The latency of deleting tags. <code>num_update_edge_errors</code> The number of execution errors for the UpdateEdgeProcessor. <code>num_get_neighbors</code> The number of executions for the GetNeighborsProcessor. <code>num_get_dst_by_src</code> The number of executions for the GetDstBySrcProcessor. <code>num_get_prop_errors</code> The number of execution errors for the GetPropProcessor. <code>num_delete_vertices</code> The number of times that vertices are deleted. <code>num_lookup</code> The number of executions for the LookupProcessor. <code>num_sync_data</code> The number of times the Storage service synchronizes data from the Drainer. <code>num_sync_data_errors</code> The number of errors that occur when the Storage service synchronizes data from the Drainer. <code>sync_data_latency_us</code> The latency of the Storage service synchronizing data from the Drainer."},{"location":"reuse/source-monitoring-metrics/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Space-level metrics are created dynamically, so that only when the behavior is triggered in the graph space, the corresponding metric is created and can be queried by the user.</p> Parameter Description <code>num_active_queries</code> The number of queries currently being executed. <code>num_queries</code> The number of queries. <code>num_sentences</code> The number of statements received by the Graphd service. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>num_slow_queries</code> The number of slow queries. <code>num_query_errors</code> The number of query errors. <code>num_query_errors_leader_changes</code> The number of raft leader changes due to query errors. <code>num_killed_queries</code> The number of killed queries. <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>slow_query_latency_us</code> The latency of slow queries."},{"location":"reuse/source_connect-to-nebula-graph/","title":"Source connect to nebula graph","text":"<p>This topic provides basic instruction on how to use the native CLI client NebulaGraph Console to connect to NebulaGraph.</p> <p>Caution</p> <p>When connecting to NebulaGraph for the first time, you must register the Storage Service before querying data.</p> <p>NebulaGraph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. For more information, see the client list.</p>"},{"location":"reuse/source_connect-to-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have started NebulaGraph services.</li> </ul> <ul> <li>The machine on which you plan to run NebulaGraph Console has network access to the Graph Service of NebulaGraph.</li> </ul> <ul> <li> <p>The NebulaGraph Console version is compatible with the NebulaGraph version.</p> <p>Note</p> <p>NebulaGraph Console and NebulaGraph of the same version number are the most compatible. There may be compatibility issues when connecting to NebulaGraph with a different version of NebulaGraph Console. The error message <code>incompatible version between client and server</code> is displayed when there is such an issue.</p> </li> </ul>"},{"location":"reuse/source_connect-to-nebula-graph/#steps","title":"Steps","text":"<ol> <li> <p>On the NebulaGraph Console releases page, select a NebulaGraph Console version and click Assets.</p> <p>Note</p> <p>It is recommended to select the latest version.</p> </li> <li> <p>In the Assets area, find the correct binary file for the machine where you want to run NebulaGraph Console and download the file to the machine.</p> </li> <li> <p>(Optional) Rename the binary file to <code>nebula-console</code> for convenience.</p> <p>Note</p> <p>For Windows, rename the file to <code>nebula-console.exe</code>.</p> </li> <li> <p>On the machine to run NebulaGraph Console, grant the execute permission of the nebula-console binary file to the user.</p> <p>Note</p> <p>For Windows, skip this step.</p> <pre><code>$ chmod 111 nebula-console\n</code></pre> </li> <li> <p>In the command line interface, change the working directory to the one where the nebula-console binary file is stored.</p> </li> <li> <p>Run the following command to connect to NebulaGraph.</p> <ul> <li>For Linux or macOS:</li> </ul> <pre><code>$ ./nebula-console -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <ul> <li>For Windows:</li> </ul> <pre><code>&gt; nebula-console.exe -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP address of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the storage path of the certification authority file. <code>-ssl_cert_path</code> Sets the storage path of the certificate file. <code>-ssl_private_key_path</code> Sets the storage path of the private key file. <p>For information on more parameters, see the project repository.</p> </li> </ol>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/","title":"Source install nebula graph by rpm or deb","text":"<p>RPM and DEB are common package formats on Linux systems. This topic shows how to quickly install NebulaGraph with the RPM or DEB package.</p> <p>Note</p> <p>The console is not complied or packaged with NebulaGraph server binaries. You can install nebula-console by yourself.</p>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#prerequisites","title":"Prerequisites","text":"<ul> <li>The tool <code>wget</code> is installed.</li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#step_1_download_the_package_from_cloud_service","title":"Step 1: Download the package from cloud service","text":"<p>Note</p> <p>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </p> <ul> <li>Download the released version.<p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the release package <code>3.6.0</code> for <code>Centos 7.5</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>Download the release package <code>3.6.0</code> for <code>Ubuntu 1804</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/3.6.0/nebula-graph-3.6.0.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul> <ul> <li> <p>Download the nightly version.</p> <p>Danger</p> <ul> <li>Nightly versions are usually used to test new features. Do not use it in a production environment.</li> <li>Nightly versions may not be built successfully every night. And the names may change from day to day.</li> </ul> <p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the <code>Centos 7.5</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>For example, download the <code>Ubuntu 1804</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#step_2_install_nebulagraph","title":"Step 2: Install NebulaGraph","text":"<ul> <li> <p>Use the following syntax to install with an RPM package.</p> <pre><code>$ sudo rpm -ivh --prefix=&lt;installation_path&gt; &lt;package_name&gt;\n</code></pre> <p>The option <code>--prefix</code> indicates the installation path. The default path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install an RPM package in the default path for the 3.6.0 version, run the following command.</p> <pre><code>sudo rpm -ivh nebula-graph-3.6.0.el7.x86_64.rpm\n</code></pre> </li> </ul> <ul> <li> <p>Use the following syntax to install with a DEB package.</p> <pre><code>$ sudo dpkg -i &lt;package_name&gt;\n</code></pre> <p>Note</p> <p>Customizing the installation path is not supported when installing NebulaGraph with a DEB package. The default installation path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install a DEB package for the 3.6.0 version, run the following command.</p> <pre><code>sudo dpkg -i nebula-graph-3.6.0.ubuntu1804.amd64.deb\n</code></pre> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula/</code>.</p> </li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#next_to_do","title":"Next to do","text":"<ul> <li>Start NebulaGraph </li> </ul> <ul> <li>Connect to NebulaGraph</li> </ul>"},{"location":"reuse/source_manage-service/","title":"Source manage service","text":"<p>NebulaGraph supports managing services with scripts. </p>"},{"location":"reuse/source_manage-service/#manage_services_with_script","title":"Manage services with script","text":"<p>You can use the <code>nebula.service</code> script to start, stop, restart, terminate, and check the NebulaGraph services.</p> <p>Note</p> <p><code>nebula.service</code> is stored in the <code>/usr/local/nebula/scripts</code> directory by default. If you have customized the path, use the actual path in your environment.</p>"},{"location":"reuse/source_manage-service/#syntax","title":"Syntax","text":"<pre><code>$ sudo /usr/local/nebula/scripts/nebula.service\n[-v] [-c &lt;config_file_path&gt;]\n&lt;start | stop | restart | kill | status&gt;\n&lt;metad | graphd | storaged | all&gt;\n</code></pre> Parameter Description <code>-v</code> Display detailed debugging information. <code>-c</code> Specify the configuration file path. The default path is <code>/usr/local/nebula/etc/</code>. <code>start</code> Start the target services. <code>stop</code> Stop the target services. <code>restart</code> Restart the target services. <code>kill</code> Terminate the target services. <code>status</code> Check the status of the target services. <code>metad</code> Set the Meta Service as the target service. <code>graphd</code> Set the Graph Service as the target service. <code>storaged</code> Set the Storage Service as the target service. <code>all</code> Set all the NebulaGraph services as the target services."},{"location":"reuse/source_manage-service/#start_nebulagraph","title":"Start NebulaGraph","text":"<p>Run the following command to start NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service start all\n[INFO] Starting nebula-metad...\n[INFO] Done\n[INFO] Starting nebula-graphd...\n[INFO] Done\n[INFO] Starting nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"reuse/source_manage-service/#stop_nebulagraph","title":"Stop NebulaGraph","text":"<p>Danger</p> <p>Do not run <code>kill -9</code> to forcibly terminate the processes. Otherwise, there is a low probability of data loss.</p> <p>Run the following command to stop NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service stop all\n[INFO] Stopping nebula-metad...\n[INFO] Done\n[INFO] Stopping nebula-graphd...\n[INFO] Done\n[INFO] Stopping nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"reuse/source_manage-service/#check_the_service_status","title":"Check the service status","text":"<p>Run the following command to check the service status of NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service status all\n</code></pre> <ul> <li> <p>NebulaGraph is running normally if the following information is returned.</p> <pre><code>INFO] nebula-metad(33fd35e): Running as 29020, Listening on 9559\n[INFO] nebula-graphd(33fd35e): Running as 29095, Listening on 9669\n[WARN] nebula-storaged after v3.0.0 will not start service until it is added to cluster.\n[WARN] See Manage Storage hosts:ADD HOSTS in https://docs.nebula-graph.io/\n[INFO] nebula-storaged(33fd35e): Running as 29147, Listening on 9779\n</code></pre> <p>Note</p> <p>After starting NebulaGraph, the port of the <code>nebula-storaged</code> process is shown in red. Because the <code>nebula-storaged</code> process waits for the <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p> </li> </ul> <ul> <li>If the returned result is similar to the following one, there is a problem. You may also go to the NebulaGraph community for help.<pre><code>[INFO] nebula-metad: Running as 25600, Listening on 9559\n[INFO] nebula-graphd: Exited\n[INFO] nebula-storaged: Running as 25646, Listening on 9779\n</code></pre> </li> </ul> <p>The NebulaGraph services consist of the Meta Service, Graph Service, and Storage Service. The configuration files for all three services are stored in the <code>/usr/local/nebula/etc/</code> directory by default. You can check the configuration files according to the returned result to troubleshoot problems.</p>"},{"location":"reuse/source_manage-service/#next_to_do","title":"Next to do","text":"<p>Connect to NebulaGraph</p>"}]}